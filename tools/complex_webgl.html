<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>The Complex Grapher (WebGL)</title>

    <style>
        #canvas,
        #grid-canvas {
            position: fixed;
            margin: 0;
            border: 0;
            padding: 0;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }

        #grid-canvas {
            opacity: 0.6;
            mix-blend-mode: exclusion;
        }

        #control {
            position: fixed;
            left: 20px;
            top: 20px;
            background-color: rgba(92, 92, 92, 0.7);
            width: 240px;
            padding: 20px;
            color: white;
            white-space: nowrap;
        }

        #function-input {
            width: 170px;
        }

        #control>#title,
        #title a {
            margin: 0px 0px 1em 0px;
            padding: 0px 3px;
            font-family: Consolas;
            font-style: italic;
            font-weight: 800;
            font-size: 20px;
            color: orange;
            text-shadow: 1.5px 1.5px 1px maroon;
            text-decoration: none;
        }
    </style>

</head>

<body>
    <canvas id="canvas"></canvas>
    <canvas id="grid-canvas"></canvas>

    <div id="control">
        <div id="title"><a id='copy-link' href="javascript:copyLink()" title='click to copy shareable link'>The Complex
                Grapher</a></div>
        <hr />

        <p style='margin-bottom: 0.4em;'>Function to graph:</p>
        <input type='text' id="function-input" oninput="updateGraphingParameters(event)"
            onkeydown="if (event.keyCode==13) { recompileShader(); }"></input>&nbsp;<button
            onclick="recompileShader();">Update</button>
        <br /><br />

        <input type='checkbox' id='checkbox-show-axes' onchange="updateGraphingParameters()" />
        <label for='checkbox-show-axes'>show axes</label>
        <input type='checkbox' id='checkbox-axes-numbers' onchange="updateGraphingParameters()" />
        <label for='checkbox-axes-numbers'>axes numbers</label>
        <br />
        <input type='checkbox' id='checkbox-grid-major' onchange="updateGraphingParameters()" />
        <label for='checkbox-grid-major'>major grid</label>
        <input type='checkbox' id='checkbox-grid-minor' onchange="updateGraphingParameters()" />
        <label for='checkbox-grid-minor'>minor grid</label>
        <br />
        <br />

        <input type='checkbox' id='checkbox-contour-linear' onchange="updateGraphingParameters()" />
        <label for='checkbox-contour-linear'>linear contour</label>
        <br />
        <input type='checkbox' id='checkbox-contour-logarithmic' onchange="updateGraphingParameters()" />
        <label for='checkbox-contour-logarithmic'>logarithmic contour</label>
        <br />
        <br />

        Brightness (0-1):&nbsp;<input type='text' id='brightness-input' value='0.5' style='width:40px;'
            oninput="updateGraphingParameters()" />
        <br />
        <br />

        <span style='white-space:normal;'>Doesn’t work as expected?
            Check the <a id="js-link" href="complex.html" target='_blank' style='color:white;'>Javascript
                version</a>.</span>

    </div>



    <script>
        "use strict";
        function $(s) { return document.querySelector(s); }
        const canvas = $("#canvas");
        const grid_canvas = $("#grid-canvas");


        function Complex(e, t) {
            this.re = e,
                this.im = t,
                this.Re = function () {
                    return this.re
                }
                ,
                this.Im = function () {
                    return this.im
                }
                ,
                this.ToString = function () {
                    return ((this.re >= 0) ? "" : " −") + Math.abs(this.re.toFixed(2)) + ((this.im >= 0) ? " + " : " − ")
                        + ((Math.abs(this.im.toFixed(2)) == 1) ? "" : Math.abs(this.im.toFixed(2))) + "i";
                }
        }
        const compE = new Complex(Math.E, 0)
            , compI = new Complex(0, 1)
            , comp2I = new Complex(0, 2)
            , comp1 = new Complex(1, 0)
            , comp2 = new Complex(2, 0)
            , compPi = new Complex(Math.PI, 0);

        // a list of function names
        const FC = ["EXP", "LOG", "SQR",
            "SIN", "COS", "TAN", "CSC", "SEC", "COT", "SNH", "CSH", "TNH", "CCH", "SCH", "CTH",
            "ASN", "ACS", "ATN", "ACC", "ASC", "ACT", "ASH", "ACH", "ATH", "AXH", "AGH", "AKH",
            "GMA", "REL", "IMA", "ABS", "ARG"];

        // parse equation to reverse polish notation 
        function parseExpression(str) {
            if (str.match('&'))
                throw ("Invalid character detected");
            if (str.length < 1 || str.length > 1024)
                throw ("Invalid string length");

            // replace function names
            str = str.replace(/ /g, "");
            var replaceFuncName = function replaceFuncName() {
                for (var i = 0; i < src.length; i++) {
                    while (str.match(src[i])) str = str.replace(src[i], rep[i]);
                }
            }
            var src = ["arsinh", "arcosh", "artanh", "arcsch", "arsech", "arcoth", "arcsinh", "arccosh", "arctanh", "arccsch", "arcsech", "arccoth"];
            var rep = ["ASH", "ACH", "ATH", "AXH", "AGH", "AKH", "ASH", "ACH", "ATH", "AXH", "AGH", "AKH"];
            replaceFuncName();
            src = ["asinh", "acosh", "atanh", "acsch", "asech", "acoth", "sinh", "cosh", "tanh", "csch", "sech", "coth"];
            rep = ["ASH", "ACH", "ATH", "AXH", "AGH", "AKH", "SNH", "CSH", "TNH", "CCH", "SCH", "CTH"];
            replaceFuncName();
            src = ["asin", "acos", "atan", "acsc", "asec", "acot", "arsin", "arcos", "artan", "arcsc", "arsec", "arcot", "arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"];
            rep = ["ASN", "ACS", "ATN", "ACC", "ASC", "ACT", "ASN", "ACS", "ATN", "ACC", "ASC", "ACT", "ASN", "ACS", "ATN", "ACC", "ASC", "ACT"];
            replaceFuncName();
            src = ["ln", "log", "exp", "sqrt", "sin", "cos", "tan", "csc", "sec", "cot", "asin", "acos", "atan", "acsc", "asec", "acot", "gamma"];
            rep = ["LOG", "LOG", "EXP", "SQR", "SIN", "COS", "TAN", "CSC", "SEC", "COT", "ASN", "ACS", "ATN", "ACC", "ASC", "ACT", "GMA"];
            replaceFuncName();
            src = ["real", "re", "imaginary", "imag", "im", "pi"];
            rep = ["REL", "REL", "IMA", "IMA", "IMA", "π"];
            replaceFuncName();

            if (!(/z/.test(str)) && (/x/.test(str))) str = str.replace(/x/g, "z");

            // Shunting-Yard algorithm, copied from https://www.complexgrapher.com/scripts.min.js

            str = str.replace(/\*\*/g, '^');

            for (var t = 0; t < str.length; t++)
                t < str.length - 1 && /[zeπi\)]/.test(str[t]) && (/[zeπi\(0-9.]/.test(str[t + 1]) || FC.indexOf(str.slice(t + 1, t + 4)) >= 0) && (str = str.slice(0, t + 1) + "*" + str.slice(t + 1, str.length)),
                    t < str.length - 1 && /\d/.test(str[t]) && FC.indexOf(str.slice(t + 1, t + 4)) >= 0 && (str = str.slice(0, t + 1) + "*" + str.slice(t + 1, str.length)),
                    t > 0 && /[zeπi\(]/.test(str[t]) && /[zeπi\)0-9.]/.test(str[t - 1]) && (str = str.slice(0, t) + "*" + str.slice(t, str.length));

            for (var t = 0; t < str.length; t++)
                "-" == str[t] && (0 == t || "(" == str[t - 1]) && (str = str.slice(0, t) + "0" + str.slice(t, str.length));

            for (var n = [], t = 0; t < str.length; t++) {
                var token = str[t];
                if (/[zeπi+*-\/\^\(\)]/.test(token))
                    n.push(token);
                else if (/[0-9.]/.test(token)) {
                    for (t++; /[0-9.]/.test(str[t]);)
                        token += str[t],
                            t++;
                    if (t--,
                        (token.match(/[.]/g) || []).length > 1)
                        throw "Invalid Expression";
                    n.push(token)
                } else {
                    if (!(FC.indexOf(str.slice(t, t + 3)) >= 0))
                        throw "Invalid Expression";
                    if (n.push(str.slice(t, t + 3)),
                        t += 2,
                        "(" != str[t + 1])
                        throw "Invalid Expression"
                }
            }

            var prec = function prec(e) {
                const dict = {
                    "+": 1, "-": 1, "*": 2, "/": 2, "^": 3,
                    "SIN": 4, "COS": 4, "TAN": 4, "EXP": 4, "LOG": 4, "SQR": 4, "ASN": 4, "ACS": 4, "ATN": 4, "SNH": 4, "CSH": 4, "TNH": 4, "ASH": 4, "ACH": 4, "ATH": 4, "COT": 4, "CSC": 4, "SEC": 4, "ACC": 4, "ASC": 4, "ACT": 4, "CCH": 4, "SCH": 4, "CTH": 4, "AXH": 4, "AGH": 4, "AKH": 4, "GMA": 4, "REL": 4, "IMA": 4, "ABS": 4, "ARG": 4,
                };
                var res = dict[e];
                if (res === undefined) return -1;
                return res;
            }
            for (var a = [], i = [], t = 0; t < n.length; t++)
                if (token = n[t],
                    /[0-9.]/.test(token[0]) || /^[zeπi]/.test(token))
                    i.push(token);
                else if (/[+*-\/\^]/.test(token) || FC.indexOf(token) >= 0) {
                    if (a.length > 0)
                        for (; (prec(a[a.length - 1]) > prec(token) || prec(a[a.length - 1]) == prec(token) && "^" != a[a.length - 1]) && (i.push(a.pop()),
                            0 != a.length);)
                            ;
                    a.push(token)
                } else if ("(" == token)
                    a.push(token);
                else if (")" == token) {
                    if (!(a.length > 0)) break;
                    for (; "(" != a[a.length - 1];)
                        if (i.push(a.pop()),
                            0 == a.length) break;
                    a.pop()
                }

            for (; a.length > 0;) {
                if ("(" == a[a.length - 1]) a.pop();
                i.push(a.pop())
            }

            for (var t = 0; t < i.length; t++)
                "i" == i[t] ? i[t] = compI : "e" == i[t] ? i[t] = compE : "π" == i[t] ? i[t] = compPi : /[0-9.]/.test(i[t][0]) && (i[t] = new Complex(Number(i[t]), 0));

            return i;

        }

        // opposite of parsing, convert to executable code string
        function stringfyExpression(arr) {
            var str = "";
            var stack = [];
            for (var i = 0; i < arr.length; i++) {
                var token = arr[i];
                if (typeof token == "string" && token != 'z') {
                    if (!(FC.indexOf(token) >= 0)) {
                        if (stack.length < 2) throw "Invalid Expression";
                        var b = stack.pop(), a = stack.pop(), r = "";
                        if (typeof a != "string")
                            a = "vec2(" + String(a.re) + "," + String(a.im) + ")";
                        if (typeof b != "string")
                            b = "vec2(" + String(b.re) + "," + String(b.im) + ")";
                        switch (token) {
                            case "+": r = 'ADD(' + a + ',' + b + ')'; break;
                            case "-": r = 'SUB(' + a + ',' + b + ')'; break;
                            case "*": r = 'MUL(' + a + ',' + b + ')'; break;
                            case "/": r = 'DIV(' + a + ',' + b + ')'; break;
                            case "^": r = 'POW(' + a + ',' + b + ')'; break;
                        }
                        stack.push(r);
                    }
                    else {
                        var a = stack.pop();
                        var r = token + '(' + a + ')';
                        stack.push(r);
                    }
                }
                else stack.push(token);
            }
            if (1 != stack.length)
                throw "Invalid Expression";
            return stack.pop();
        }



        // graph information
        var state = {
            // function
            fun_string: "",
            // viewport
            xmin: NaN,
            xmax: NaN,
            ymin: NaN,
            ymax: NaN,
            xRes: window.innerWidth,
            yRes: window.innerHeight,
            // graphing parameters
            showAxes: false,
            showMajorGrid: false,
            showMinorGrid: false,
            showAxesNumbers: false,
            showLinearContour: false,
            showLogarithmicContour: false,
            brightness: 0.5,
            // sharing
            share_hash: ""
        };

        function highlightError(i) {
            i.style.boxShadow = "0px 0px 3px rgb(255,0,0)";
            i.style.color = "red";
            i.style.fontWeight = "600";
        }
        function dehighlightError(i) {
            i.style.boxShadow = "none";
            i.style.color = "black";
            i.style.fontWeight = "normal";
        }

        function getGraphingParametersFromHash() {
            try {
                var hash = document.location.hash.replace('#', '');
                if (hash == "") return;
                hash = hash.split('&').reduce(function (res, s) {
                    s = s.split('=');
                    res[s[0]] = decodeURIComponent(s[1]);
                    return res;
                }, {});
                // read function
                if (hash['f'] != undefined) $('#function-input').value = hash['f'];
                // read graph
                var cx = hash['cx'] == undefined ? 0.0 : Number(hash['cx']);
                var cy = hash['cy'] == undefined ? 0.0 : Number(hash['cy']);
                var rx = hash['rx'] == undefined ? 6.0 : Number(hash['rx']);
                var ry = hash['ry'] == undefined ? 4.0 : Number(hash['ry']);
                var xRes = window.innerWidth, yRes = window.innerHeight;
                var sc = Math.sqrt((rx * ry) / (xRes * yRes));
                state.xmax = cx + sc * xRes;
                state.xmin = cx - sc * xRes;
                state.ymax = cy + sc * yRes;
                state.ymin = cy - sc * yRes;
                // read brightness
                $("#brightness-input").value = hash['a'] == undefined ? '0.5' : hash['a'];
                // read contour option
                var contour = Number(hash['contour']);
                if (!(contour >= 0 && contour < 3)) contour = 0;
                if (contour == 1) $("#checkbox-contour-linear").checked == true, $("#checkbox-contour-logarithmic").checked = false;
                else if (contour == 2) $("#checkbox-contour-linear").checked == false, $("#checkbox-contour-logarithmic").checked = true;
                else $("#checkbox-contour-linear").checked == false, $("#checkbox-contour-logarithmic").checked = false;
                // read boolean values
                var parseBool = function (s) {
                    try {
                        return Boolean(eval(s));  // undefined => false
                    } catch (e) { return false; }
                };
                $("#checkbox-show-axes").checked = parseBool(hash['showaxes']);
                $("#checkbox-axes-numbers").checked = parseBool(hash['showaxesnumbers']);
                $("#checkbox-grid-major").checked = parseBool(hash['majorgrid']);
                $("#checkbox-grid-minor").checked = parseBool(hash['minorgrid']);
                console.log(window.location);
            } catch (e) {
                console.error(e);
            }
            window.location.hash = "";
            updateGraphingParameters();
        }

        function updateGraphingParameters(event) {
            // get parameters
            try {
                var str = $("#function-input").value;
                state.fun_string = stringfyExpression(parseExpression(str));
            } catch (e) { state.fun_string = ""; }
            state.showAxes = $("#checkbox-show-axes").checked;
            state.showAxesNumbers = $("#checkbox-axes-numbers").checked;
            state.showMajorGrid = $("#checkbox-grid-major").checked;
            state.showMinorGrid = $("#checkbox-grid-minor").checked;
            state.showLinearContour = $("#checkbox-contour-linear").checked;
            state.showLogarithmicContour = $("#checkbox-contour-logarithmic").checked;
            state.brightness = Number($("#brightness-input").value);
            if (!(state.brightness > 0. && state.brightness < 1.))
                highlightError($("#brightness-input"));
            else dehighlightError($("#brightness-input"));

            updateHash();
            replot(event);
        }

        function updateHash() {
            var hash = 'f=' + encodeURIComponent(document.querySelector("#function-input").value);
            hash += '&cx=' + encodeURIComponent((0.5 * (state.xmin + state.xmax)).toFixed(2));
            hash += '&cy=' + encodeURIComponent((0.5 * (state.ymin + state.ymax)).toFixed(2));
            var area = (state.xmax - state.xmin) * (state.ymax - state.ymin);
            hash += '&rx=' + encodeURIComponent(Math.sqrt(0.375 * area).toFixed(2));
            hash += '&ry=' + encodeURIComponent(Math.sqrt(area / 6.).toFixed(2));
            hash += '&a=' + encodeURIComponent(state.brightness.toFixed(2));
            hash += "&contour=" + (state.showLinearContour ? "1" : state.showLogarithmicContour ? "2" : "0");
            if (state.showAxes) hash += "&showaxes=1";
            if (state.showAxesNumbers) hash += "&showaxesnumbers=1";
            if (state.showMajorGrid) hash += "&majorgrid=1";
            if (state.showMinorGrid) hash += "&minorgrid=1";
            state.share_hash = hash;
            document.querySelector("#js-link").href = "complex.html#" + hash;
        }

        function copyLink() {
            var link = window.location.href;
            if (link.search('#', 0) != -1)
                link = link.substring(0, link.search('#', 0));
            link = link + '#' + state.share_hash;

            // https://stackoverflow.com/a/30810322

            function fallbackCopyTextToClipboard(text) {
                var textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.top = "0";
                textArea.style.left = "0";
                textArea.style.position = "fixed";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    var successful = document.execCommand('copy');
                    var msg = successful ? 'successful' : 'unsuccessful';
                    alert('Link copy was ' + msg);
                } catch (err) {
                    alert('Error copying link: ', err);
                }
                document.body.removeChild(textArea);
            }
            function copyTextToClipboard(text) {
                if (!navigator.clipboard) {
                    fallbackCopyTextToClipboard(text);
                    return;
                }
                navigator.clipboard.writeText(text).then(function () {
                    alert('Link copied to clipboard');
                }, function (err) {
                    alert('Error copying link: ', err);
                });
            }

            copyTextToClipboard(link);

        }



        function recompileShader() {
            if (!(state.brightness > 0. && state.brightness < 1.)) {
                highlightError(document.querySelector("#brightness-input"));
                return false;
            }
            else dehighlightError(document.querySelector("#brightness-input"));

            try {
                updateGraphingParameters();
                init_WebGL();
                dehighlightError(document.querySelector("#function-input"));
            } catch (e) {
                highlightError(document.querySelector("#function-input"));
            }
            replot();
        }

        // point and coordinate transform
        function vec2(x, y) { return { x: x, y: y }; }
        function fromGraphX(x) { return (x - state.xmin) / (state.xmax - state.xmin) * state.xRes; }
        function fromGraphY(y) { return state.yRes - (y - state.ymin) / (state.ymax - state.ymin) * state.yRes; }
        function fromGraph(p) { return { x: fromGraphX(p.x), y: fromGraphY(p.y) }; }
        function fromCanvasX(x) { return x / state.xRes * (state.xmax - state.xmin) + state.xmin; }
        function fromCanvasY(y) { return (state.yRes - y) / state.yRes * (state.ymax - state.ymin) + state.ymin; }
        function fromCanvas(p) { return { x: fromCanvasX(p.x), y: fromCanvasY(p.y) }; }


        // user parameters
        var mouseDown = false;
        var mouseDownPos = vec2(NaN, NaN);
        var mousePos = vec2(NaN, NaN);
        var isDraggingXAxis = false;
        var isDraggingYAxis = false;
        var xAxisOnScreen = 0;  // y of x-axis on screen coordinate
        var yAxisOnScreen = 0;  // x of y-axis on screen coordinate
        var altZoomingStartPos = vec2(NaN);  // click Alt to zoom in


        function plotAxesAndGrid(event) {
            var ctx = grid_canvas.getContext("2d");
            ctx.clearRect(0, 0, state.xRes, state.yRes);

            var vfloor = function (x) {
                var xm = Math.pow(10., Math.floor(Math.log(x) / Math.log(10)));
                var xq = x / xm;
                return xm * (xq < 2. ? 1. : xq < 5. ? 2. : 5.);
            };

            // origin on canvas
            var c = fromGraph(vec2(0, 0));
            var dx = state.xmax - state.xmin;
            var dy = state.ymax - state.ymin;
            xAxisOnScreen = c.y < 0 ? 0 : c.y > state.yRes ? state.yRes : c.y;
            yAxisOnScreen = c.x < 0 ? 0 : c.x > state.xRes ? state.xRes : c.x;

            // grid
            {
                var xd = vfloor(dx / state.xRes * 120.);
                var yd = vfloor(dy / state.yRes * 120.);
                // minor gridlines
                {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ffffffcc';
                    ctx.lineWidth = 0.5;
                    if (state.showMinorGrid) { // x
                        var x0 = Math.floor(state.xmin / (.2 * xd)) * (.2 * xd);
                        for (var x = x0; x <= state.xmax; x += .2 * xd) {
                            var xc = fromGraphX(x);
                            ctx.moveTo(xc, 0);
                            ctx.lineTo(xc, state.yRes);
                        }
                    }
                    if (state.showMinorGrid) { // y
                        var y0 = Math.floor(state.ymin / (.2 * yd)) * (.2 * yd);
                        for (var y = y0; y <= state.ymax; y += .2 * yd) {
                            var yc = fromGraphY(y);
                            ctx.moveTo(0, yc);
                            ctx.lineTo(state.xRes, yc);
                        }
                    }
                    ctx.stroke();
                }
                // major gridlines
                {
                    ctx.beginPath();
                    ctx.strokeStyle = '#ffffffaa';
                    ctx.lineWidth = 0.5;
                    if (state.showMajorGrid) { // x
                        var x0 = Math.floor(state.xmin / xd) * xd;
                        for (var x = x0; x <= state.xmax; x += xd) {
                            var xc = fromGraphX(x);
                            ctx.moveTo(xc, 0);
                            ctx.lineTo(xc, state.yRes);
                        }
                    }
                    if (state.showMajorGrid) { // y
                        var y0 = Math.floor(state.ymin / yd) * yd;
                        for (var y = y0; y <= state.ymax; y += yd) {
                            var yc = fromGraphY(y);
                            ctx.moveTo(0, yc);
                            ctx.lineTo(state.xRes, yc);
                        }
                    }
                    ctx.stroke();
                }
                // numbers
                {
                    ctx.font = "10px sans-serif";
                    ctx.fillStyle = "white";
                    if (state.showAxesNumbers) {  // x
                        ctx.textAlign = "center";
                        var y = Math.min(Math.max(c.y, 0) + 10, state.yRes - 2);
                        var x0 = Math.floor(state.xmin / xd) * xd;
                        for (var x = x0; x <= state.xmax; x += xd) {
                            if (Math.abs(x) > 1e-12) {
                                var xc = fromGraphX(x);
                                var xr = Number(x.toPrecision(12));
                                ctx.fillText(Math.abs(xr) >= 1e6 || Math.abs(xr) <= 1e-6 ?
                                    xr.toExponential(6).replace(/0+e/, 'e').replace('.e', 'e') :
                                    xr.toString(), xc, y);
                            }
                        }
                    }
                    if (state.showAxesNumbers) {  // y
                        var x = Math.min(Math.max(c.x - 4, 2), state.xRes - 2);
                        ctx.textAlign = x <= 5 ? "left" : "right";
                        var y0 = Math.floor(state.ymin / yd) * yd;
                        for (var y = y0; y <= state.ymax; y += yd) {
                            if (Math.abs(y) > 1e-12) {
                                var yc = fromGraphY(y);
                                var yr = Number(y.toPrecision(12));
                                ctx.fillText(Math.abs(yr) >= 1e6 || Math.abs(yr) <= 1e-6 ?
                                    yr.toExponential(6).replace(/0+e/, 'e').replace('.e', 'e') :
                                    yr.toString(), x, yc + 4);
                            }
                        }
                    }
                }
            }

            // axes
            {
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#ffffffff';
                if (state.showAxes) { // x
                    ctx.beginPath();
                    ctx.moveTo(0, c.y);
                    ctx.lineTo(state.xRes, c.y);
                    ctx.stroke();
                }
                if (state.showAxes) { // y
                    ctx.beginPath();
                    ctx.moveTo(c.x, 0);
                    ctx.lineTo(c.x, state.yRes);
                    ctx.stroke();
                }
            }
        }


        var WebGL = {
            context: undefined,  // getContext("webgl")
            programInfo: {
                // shader program
                program: undefined,
                // attribute and uniform variable locations
                aVertexPosition: undefined,
                uPmin: undefined,
                uPmax: undefined,
                LINEAR_CONTOUR: undefined,
                LOGARITHMIC_CONTOUR: undefined,
                brightness: undefined,
            },
            positionBuffer: undefined,
        };

        function init_WebGL() {

            // initialize shader program
            function initShaderProgram(gl, vsSource, fsSource) {

                // function: create a shader of the given type, upload and compile source
                function loadShader(gl, type, source) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        var error_message = "Shader compile error: " + gl.getShaderInfoLog(shader);
                        gl.deleteShader(shader);
                        throw error_message;
                    }
                    return shader;
                }
                // load shaders
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

                // create shader program
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    throw "Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram);
                }
                return shaderProgram;
            }


            // initialize GL context
            const gl = canvas.getContext("webgl");
            if (gl === null) throw "Unable to initialize WebGL";
            WebGL.context = gl;

            // vertex shader source
            // run at each vertex of the shape to transform input vertex to clip space coordinate system
            // each axis has range from -1.0 to 1.0
            const vsSource = `
                    attribute vec4 aVertexPosition;  // to be interpolated

                    uniform vec2 uPmin;  // bottom-left position
                    uniform vec2 uPmax;  // top-right position

                    varying vec2 vPos;  // send to fragment shader

                    void main() {
                        gl_Position = aVertexPosition;
                        vec2 pos = vec2(0.5)+0.5*gl_Position.xy;
                        vPos = uPmin + pos * (uPmax - uPmin);
                    }`;
            // fragment shader source
            // called once at every pixel after the vertices have been processed by vertex shader
            // calculate the color of the pixel
            const fsSource = `// fragment shader for WebGL complex grapher

precision highp float;
varying vec2 vPos;

uniform bool LINEAR_CONTOUR;
uniform bool LOGARITHMIC_CONTOUR;

uniform float brightness;


#define sinh(x) (0.5*(exp(x)-exp(-x)))
#define cosh(x) (0.5*(exp(x)+exp(-x)))
//#define tanh(x) (1.0-2./(exp(2.*x)+1))
#define tanh(x) (sinh(x)/cosh(x))

// complex arithmetic
float Mag(vec2 a) { return length(a); }
float Arg(vec2 a) { return atan(a.y, a.x); }
float logMag(vec2 a) {
    //return 0.5*log(dot(a,a));
    return log(length(a));
}
vec2 ADD(vec2 a, vec2 b) { return a + b; }
vec2 SUB(vec2 a, vec2 b) { return a - b; }
vec2 MUL(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }
vec2 DIV(vec2 a, vec2 b) { return (1.0/dot(b,b)) * vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y); }
vec2 POW(vec2 e, vec2 t) {
    float a = Arg(e), r = logMag(e), c = exp(t.x*r-t.y*a), s = t.x*a+t.y*r;
    return c * vec2(cos(s), sin(s));
}
vec2 EXP(vec2 e) { return exp(e.x) * vec2(cos(e.y),sin(e.y)); }
vec2 LOG(vec2 e) { return vec2(logMag(e), Arg(e)); }
vec2 SQR(vec2 e) {
    float m = Mag(e);
    return e.y>0. ? vec2(sqrt(0.5*(m+e.x)), sqrt(0.5*(m-e.x))) :
        vec2(sqrt(0.5*(m+e.x)), -sqrt(0.5*(m-e.x)));
}
vec2 INV(vec2 e) { return (1./dot(e,e)) * vec2(e.x, -e.y); }

vec2 SIN(vec2 e) { return vec2(sin(e.x)*cosh(e.y), cos(e.x)*sinh(e.y)); }
vec2 COS(vec2 e) { return vec2(cos(e.x)*cosh(e.y), -sin(e.x)*sinh(e.y)); }
vec2 TAN(vec2 e) {
    float a = 2.*e.x, b = 2.*e.y, d = cos(a)+cosh(b);
    return (1./d) * vec2(sin(a), sinh(b));
}
vec2 COT(vec2 e) {
    float a = 2.*e.x, b = 2.*e.y, d = cos(a)-cosh(b);
    return (1./d) * vec2(-sin(a), sinh(b));
}
vec2 SEC(vec2 e) {
    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) + 0.5*cos(2.*a);
    return (1./d) * vec2(cos(a)*cosh(b), sin(a)*sinh(b));
}
vec2 CSC(vec2 e) {
    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) - 0.5*cos(2.*a);
    return (1./d) * vec2(sin(a)*cosh(b), -cos(a)*sinh(b));
}
vec2 SNH(vec2 e) { return vec2(sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y)); }
vec2 CSH(vec2 e) { return vec2(cosh(e.x)*cos(e.y), sinh(e.x)*sin(e.y)); }
vec2 TNH(vec2 e) {
    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)+cos(b);
    return (1./d) * vec2(sinh(a), sin(b));
}
vec2 CTH(vec2 e) {
    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)-cos(b);
    return (1./d) * vec2(sinh(a), -sin(b));
}
vec2 CCH(vec2 e) {
    float d = cos(2.*e.y) - cosh(2.*e.x);
    return (2./d) * vec2(-sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y));
}
vec2 SCH(vec2 e) {
    float d = cos(2.*e.y) + cosh(2.*e.x);
    return (2./d) * vec2(cosh(e.x)*cos(e.y), -sinh(e.x)*sin(e.y));
}

vec2 ASN(vec2 e) {
    float a = e.x, b = e.y;
    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));
    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));
    return vec2(t2.y, -t2.x);
}
vec2 ACS(vec2 e) {
    float a = e.x, b = e.y;
    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));
    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));
    return vec2(1.570796327-t2.y, t2.x);
}
vec2 ATN(vec2 e) {
    float a = e.x, b = e.y, d = a*a + (1.-b)*(1.-b);
    vec2 t1 = LOG(vec2((1.-b*b-a*a)/d, -2.*a/d));
    return vec2(-0.5*t1.y, 0.5*t1.x);
}
vec2 ACT(vec2 e) { return ATN(INV(e)); }
vec2 ASC(vec2 e) { return ACS(INV(e)); }
vec2 ACC(vec2 e) { return ASN(INV(e)); }
vec2 ASH(vec2 e) { vec2 r = ASN(vec2(e.y,-e.x)); return vec2(-r.y,r.x); }
vec2 ACH(vec2 e) { vec2 r = ACS(e); return r.y<=0.?vec2(-r.y,r.x):vec2(r.y,-r.x); }
vec2 ATH(vec2 e) {
    float a = e.x, b = e.y;
    float oneMinus = 1.-a, onePlus = 1.+a, d = oneMinus*oneMinus + b*b;
    vec2 x = (1./d) * vec2(onePlus*oneMinus-b*b, b*oneMinus+b*onePlus);
    return vec2(0.5*logMag(x), 0.5*Arg(x));
}
vec2 AKH(vec2 e) { return ATH(INV(e)); }
vec2 AXH(vec2 e) { return ASH(INV(e)); }
vec2 AGH(vec2 e) { return ACH(INV(e)); }



// HSL to RGB conversion
float hue2rgb(float p, float q, float t) {
    if (t < 0.) t += 1.;
    if (t > 1.) t -= 1.;
    if (t < 1./6.) return p + (q - p) * 6. * t;
    if (t < 1./2.) return q;
    if (t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;
    return p;
}
vec3 hslToRgb(float h, float s, float l) {
    if (s == 0.) return vec3(l);
    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
    float p = 2. * l - q;
    return vec3(
        hue2rgb(p, q, h + 1./3.),
        hue2rgb(p, q, h),
        hue2rgb(p, q, h - 1./3.)
    );
}


// main function
void main() {
    vec2 z = vPos.xy;
    vec2 fz = ${state.fun_string};
    float h = Arg(fz) * 0.15915494309189535;
    float s = 1.0;
    if (LINEAR_CONTOUR) s *= 0.5 + 0.5 * sqrt(abs(sin(3.141592653569793 * Mag(fz))));
    if (LOGARITHMIC_CONTOUR) s *= 0.5 + 0.5 * sqrt(abs(sin(1.3643763538418412 * logMag(fz))));
    float l = 1.0 - pow(1.0 - brightness, log(log(Mag(fz) + 1.0) + 1.05));
    vec3 hsl = hslToRgb(h, s, l);
    if (hsl.x + min(brightness, 0.0) != hsl.x) hsl = vec3(1.0);  // NaN, set to white for some reason
    gl_FragColor = vec4(hsl, 1);
}
`;

            // create shader program
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // get variable locations
            WebGL.programInfo.program = shaderProgram;
            WebGL.programInfo.aVertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            WebGL.programInfo.uPmax = gl.getUniformLocation(shaderProgram, 'uPmax');
            WebGL.programInfo.uPmin = gl.getUniformLocation(shaderProgram, 'uPmin');
            WebGL.programInfo.LINEAR_CONTOUR = gl.getUniformLocation(shaderProgram, 'LINEAR_CONTOUR');
            WebGL.programInfo.LOGARITHMIC_CONTOUR = gl.getUniformLocation(shaderProgram, 'LOGARITHMIC_CONTOUR');
            WebGL.programInfo.brightness = gl.getUniformLocation(shaderProgram, 'brightness');

            // create the buffer for vertex positions
            const positions = [
                -1.0, 1.0,
                1.0, 1.0,
                -1.0, -1.0,
                1.0, -1.0,
            ];
            WebGL.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, WebGL.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        }

        function replot_WebGL(event) {
            const gl = WebGL.context;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0., 0., 0., 1.);  // clear to vec4(0,0,0,1)
            gl.clearDepth(1.0);  // clear everything
            gl.enable(gl.DEPTH_TEST);  // enable depth testing
            gl.depthFunc(gl.LEQUAL);  // near objects obscure far objects

            // clear the canvas
            gl.clear(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT);

            // tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute
            {
                const numComponents = 2;  // pull out 2 values per iteration
                const type = gl.FLOAT;  // data in the buffer is 32bit float
                const normalize = false;  // do not normalize
                const stride = 0;  // how many bytes to get from one set of values to next; 0: same as numComponents
                const offset = 0;  // how many bytes inside the buffer to start from
                gl.bindBuffer(gl.ARRAY_BUFFER, WebGL.positionBuffer);
                gl.vertexAttribPointer(
                    WebGL.programInfo.aVertexPosition,
                    numComponents, type, normalize, stride, offset);
                gl.enableVertexAttribArray(
                    WebGL.programInfo.aVertexPosition);
            }

            // tell WebGL to use the program when drawing
            gl.useProgram(WebGL.programInfo.program);

            // set shader uniforms
            gl.uniform2fv(WebGL.programInfo.uPmin, [state.xmin, state.ymin]);
            gl.uniform2fv(WebGL.programInfo.uPmax, [state.xmax, state.ymax]);
            gl.uniform1i(WebGL.programInfo.LINEAR_CONTOUR, state.showLinearContour);
            gl.uniform1i(WebGL.programInfo.LOGARITHMIC_CONTOUR, state.showLogarithmicContour);
            if (state.brightness > 0. && state.brightness < 1.)
                gl.uniform1f(WebGL.programInfo.brightness, state.brightness);

            const offset = 0;
            const vertexCount = 4;
            gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);

        }



        function replot(event) {
            if (isNaN((state.xmax - state.xmin) * (state.ymax - state.ymin)))
                resizeState();
            if (WebGL.context == undefined)
                init_WebGL();
            replot_WebGL();
            plotAxesAndGrid(event);
        }


        // translate the viewport
        function translateState(delta) {
            state.xmin -= delta.x, state.xmax -= delta.x;
            state.ymin -= delta.y, state.ymax -= delta.y;
        }
        // scale the viewport about a point on the graph
        function scaleState(p, sc) {
            // sc must be positive
            // zoom in when sc<1 and zoom out when sc>1
            state.xmin = p.x + (state.xmin - p.x) * sc.x;
            state.xmax = p.x + (state.xmax - p.x) * sc.x;
            state.ymin = p.y + (state.ymin - p.y) * sc.y;
            state.ymax = p.y + (state.ymax - p.y) * sc.y;
        }
        // call this after window resizing
        function resizeState() {
            var xRes = window.innerWidth;
            var yRes = window.innerHeight;
            if (!((state.xmax - state.xmin) * (state.ymax - state.ymin) > 0)) {
                // make the area of each quadrant 6x4=24
                var sc = Math.sqrt(24 / (xRes * yRes));
                state.xmin = -(state.xmax = sc * xRes);
                state.ymin = -(state.ymax = sc * yRes);
            }
            else if (xRes > 50 && yRes > 50 && state.xRes > 50 && state.yRes > 50) {
                var sc = Math.sqrt(state.xRes * state.yRes) / Math.sqrt(xRes * yRes);
                scaleState(
                    vec2(0.5 * (state.xmin + state.xmax), 0.5 * (state.ymin + state.ymax)),
                    vec2(sc * xRes / state.xRes, sc * yRes / state.yRes)
                );
            }
            state.xRes = xRes, state.yRes = yRes;
            grid_canvas.width = canvas.width = state.xRes;
            grid_canvas.height = canvas.height = state.yRes;
        }
        // call this after mouse up/leave
        function mouseUp() {
            mouseDown = false;
        }


        window.onload = function () {
            // choose a random equation from the list
            var random_list = [
                "1/z^2",
                "(z^3-4)^2",
                "10/ln(z^5)^2*(-i-1)",
                "sin(ln(z^2.8))",
                "(z^6+z)^6+z",
                "sin(7/z^1.5)",
                "cos(7/z^2.5)",
                "z*atan(1-z^2)",
                "sqrt(2*pi*z)*(z/e)^z",
            ];
            document.querySelector("#function-input").value
                = random_list[Math.floor(Math.random() * random_list.length)];
            getGraphingParametersFromHash();
            resizeState();
            updateGraphingParameters();
            replot(event);
        };
        window.addEventListener("hashchange", function () {
            getGraphingParametersFromHash();
            recompileShader();
            replot();
        });
        window.addEventListener("resize", function () {
            resizeState();
            updateHash();
            replot(event);
        });
        grid_canvas.addEventListener("mousedown", function (event) {
            mouseDown = true;
            //event.preventDefault();
            mouseDownPos = mousePos = vec2(event.clientX, event.clientY);
            replot(event);
        });
        grid_canvas.addEventListener("mouseup", function (event) {
            if (!mouseDown) return;
            event.preventDefault();
            mouseUp();
            replot(event);
        });
        grid_canvas.addEventListener("mouseleave", function (event) { mouseUp(); });
        grid_canvas.addEventListener("mouseout", function (event) { mouseUp(); });
        grid_canvas.addEventListener("mousemove", function (event) {
            if (mouseDown) {
                event.preventDefault();
                var delta = vec2(event.clientX - mousePos.x, event.clientY - mousePos.y);
                mousePos = vec2(event.clientX, event.clientY);
                delta = vec2(
                    delta.x * (state.xmax - state.xmin) / state.xRes,
                    -delta.y * (state.ymax - state.ymin) / state.yRes
                );
                translateState(delta);
                updateHash();
                replot(event);
            }
            mousePos = vec2(event.clientX, event.clientY);
        });
        grid_canvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            var p = fromCanvas(vec2(event.clientX, event.clientY));
            var scf = Math.exp(0.001 * event.deltaY);
            var sc = vec2(scf, scf);
            scaleState(p, sc);
            updateHash();
            replot(event);
        }, { passive: false });



    </script>

</body>

</html>