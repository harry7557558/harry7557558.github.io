[{"ver":"0.1","info":{"id":"ssKGWR","date":"1631369800","viewed":164,"name":"3D SDF Visualizer","username":"harry7557558","description":"Debugging an SDF, try to use a previous volume rendering shader to visualize its discontinuity.\n\nmouse-able","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["volume","sdf","debug","discontinuity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Debugging an SDF, visualize its discontinuity\n\n\/\/ orange-blue: SDF isosurfaces\n\/\/ red-black: discontinuity (high numerical gradient)\n\/\/ green-pink: surface gradient lower\/higher than 1\n\n#define PI 3.1415926\n\n\n\/\/ a debugging SDF, heavily inspired by iq's Snail\nfloat mapShell(in vec3 p0) {\n    p0 -= vec3(1.3, 0, 0);\n    vec3 p = p0;\n\n    const float b = 0.17;\n\n    float r = length(p.xy);\n    float a = mix(0.0, 0.8, smoothstep(0.0, 1.0, 0.5*(r-0.6)));\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;\n    float t = atan(p.y, p.x);\n \n    float n = (log(r)\/b-t)\/(2.0*PI);\n    n = min(n, 0.0);\n\n    float n0 = floor(n), n1 = ceil(n);\n    float x0 = exp(b*(t+2.0*PI*n0));\n    float x1 = exp(b*(t+2.0*PI*n1));\n    float r0 = 1.0*x0;\n    float r1 = 1.0*x1;\n\n    float h0 = p.z + 0.4*(x0-1.0);\n    float h1 = p.z + 0.4*(x1-1.0);\n    float d0 = length(vec2(x0-r,h0)) - r0;\n    float d1 = length(vec2(x1-r,h1)) - r1;\n\n    float d, dx, dy;\n    if (d0 < 0.0) d = d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0 && d1<-d0) d = -d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0) d = d1, dx = x1-r, dy = h1;\n    else if (d0 < d1) d = d0, dx = x0-r, dy = h0;\n    else d = d1, dx = x1-r, dy = h1;\n\n    d += 0.002*r*sin(40.*t);\n    d += 0.002*r*sin(40.*atan(dy,dx));\n\n    d = abs(d)-0.1*r;\n    d = max(d, p0.x);\n    return d;\n}\n\n\/\/ test SDF\nfloat mapTest(vec3 p) {\n    vec3 r = vec3(1.5,1.0,0.6);\n    float k1 = length(p\/r);\n    float k2 = length(p\/(r*r));\n    return k1*(k1-1.0)\/k2+0.1*sign(p.x+p.y+p.z);\n}\n\nfloat sdf(in vec3 p) {\n    \/\/return mapTest(p);\n    return mapShell(p);\n}\n\nvec3 sdfGrad(in vec3 p, in float e) {\n\tfloat a = sdf(p+vec3(e,e,e));\n\tfloat b = sdf(p+vec3(e,-e,-e));\n\tfloat c = sdf(p+vec3(-e,e,-e));\n\tfloat d = sdf(p+vec3(-e,-e,e));\n\treturn (.25\/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n\/\/ raymarching parameters\nconst vec3 BoxRadius = vec3(2.0, 2.0, 2.0);\n#define STEP 0.01\n#define MAX_STEP 120.\n\n\n\/\/ rendering parameters\n#define FIELD_EMISSION 0.3\n#define DISCONTINUITY_OPACITY 0.1\n#define SURFACE_GRADIENT 10.0\n\n\/\/ light direction as global variable\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n\/\/ colormaps - https:\/\/www.shadertoy.com\/view\/NsSSRK\nvec3 colorSdf(float t) {\n  float r = .385+.619*t+.238*cos(4.903*t-2.61);\n  float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 colorNormal(float t) {\n  float r = .529-.054*t+.55*cos(5.498*t+2.779);\n  float g = .21+.512*t+.622*cos(4.817*t-1.552);\n  float b = .602-.212*t+.569*cos(5.266*t+2.861);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\n\n\/\/ modified from a volume rendering demo\n\/\/ https:\/\/github.com\/harry7557558\/Graphics\/blob\/master\/raytracing\/webgl_volume\/fs-source.glsl\nvec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)\/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) \/ step_count;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old, v;\n    for (t = t0; t < t1; t += dt) {\n        v = sdf(ro+rd*t);\n        vec3 col = colorSdf(0.5+0.5*sin(8.0*PI*v));\n        \/\/float grad = length(sdfGrad(ro+rd*t,dt));\n        float grad = t==t0 ? 0.0 : abs(v-v_old)\/dt;\n        float grad_abs = (1.0-grad)\/dt;\n        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));\n        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v < 0.0) break;\n        v_old = v;\n    }\n    if (v > 0.0) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = sdf(ro+rd*t);\n            if (v*v_old<0.0) break;\n        }\n    }\n    vec3 grad = sdfGrad(ro+rd*t, 1e-3);\n    vec3 col = colorNormal(0.5+0.5*tanh(SURFACE_GRADIENT*(0.5*length(grad)-0.5)));\n    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);\n    return totcol + col * totabs;\n}\n\n\n\/\/ ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set camera\n    float rx = iMouse.z>0. ? 3.14*(iMouse.y\/iResolution.y)-1.57 : 0.3;\n    float rz = iMouse.z>0. ? -iMouse.x\/iResolution.x*4.0*3.14 : -0.6;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec3 ro = 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    \/\/ calculate pixel color\n    light = normalize(w+0.5*u+0.1*v);\n\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = render(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wsfBRX","date":"1588824572","viewed":41,"name":"ASM2O CPT","username":"harry7557558","description":"School project appropriating The Archer by Henry Moore. The animation is not as good as expected.\nA realtime software renderer written in C++ uses bounding boxes to accelerate raymarching, but this one doesn't.","likes":2,"published":2,"flags":0,"usePreview":0,"tags":["ring","loop","hand","archer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Time (iTime-1.0)\n\nconst vec3 light_pos = 5.0*vec3(0.7,-2.0,1.8);\n\n#define eps 0.001\n\nvec3 castRay(vec3 p, vec3 d) {\n    float t = 0.0, dt, mt=1e12;\n\tfor (int i = min(iFrame,0); i < 256; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        if (dt<-eps) return vec3(1,0,0);\n\t\tif (dt<eps) break;\n\t\tif (t>20.0) return vec3(0.0);\n\t}\n\tp = p + t * d;\n    vec3 n = calcGrad(p, Time);\n    d-=2.0*dot(d,n)*n;\n\tvec3 light = normalize(light_pos-p);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n  #if 1\n    t=0.1, d=light;\n\tfor (int i = min(iFrame,0); i < 64; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        mt=min(mt,0.5+5.0*dt\/t);\n        if (t>10.0) {dif*=clamp(mt,0.0,1.0);break;}\n        if (dt<0.01) {dif*=0.5;break;}\n\t}\n  #endif\n    float m = exp(-0.1*dot(p.xy,p.xy));\n    m*=1.0-exp(-2.0*iTime);\n    m*=1.0-exp(2.0*(iTime-39.));\n    return m*(dif+spc);\n}\n\n\n#define AA 1\n#define SC 2.0\n\nfloat sstep(float x) {\n    x=clamp(x,0.,1.);\n    return x*x*(3.-2.*x);\n}\n\n#define res iResolution.xy\nvec3 Ctr = vec3(0,0.5,0.2);\n\nvec3 CamP, ScrO, ScrA, ScrB;\nvoid setCamera(float rz, float rx, float dist, float unit){\n    float cx=cos(rx), sx=sin(rx), cz=cos(rz), sz=sin(rz);\n    vec3 u=vec3(-sz,cz,0.), v=vec3(-cz*sx,-sz*sx,cx), w=vec3(cz*cx,sz*cx,sx);\n    u*=0.5*res.x\/unit, v*=0.5*res.y\/unit, w*=dist;\n    CamP=Ctr+w;\n    ScrO=Ctr-(u+v), ScrA=u*2.0,ScrB=v*2.0;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord ){\n#if 0\n    vec2 p = iMouse.w>0.?iMouse.xy:-iMouse.zw;\n    float t = 2.0*PI*(p.x\/res.x-0.5);\n    float a = PI*(p.y\/res.y-0.5);\n#else\n    float t = 0.3, a=0.2, c;\n    if (iTime>6.0) c=sstep(2.0*(iTime-6.)),t=mix(t,-0.1,c),a=mix(a,-0.6,c),Ctr=mix(Ctr,vec3(0,0.5,0.4),c);\n    if (iTime>19.0) c=sstep(0.8*(iTime-19.)),a=mix(a,-0.4,c),Ctr=mix(Ctr,vec3(0,0.5,0.6),c);\n    if (iTime>26.0) c=sstep(2.0*(iTime-26.)),t=mix(t,0.2,c),a=mix(a,0.3,c),Ctr=mix(Ctr,vec3(0,0.2,0.6),c);\n    if (iTime>30.0) c=sstep(2.0*(iTime-30.)),t=mix(t,-0.2,c),a=mix(a,-0.2,c),Ctr=mix(Ctr,vec3(0,0.2,0.2),c);\n    if (iTime>36.0) c=sstep(2.0*(iTime-36.)),t=mix(t,0.1,c),a=mix(a,-0.7,c),Ctr=mix(Ctr,vec3(0,0.2,-0.3),c);\n#endif\n    float CamSC = length(res);\n    setCamera(-1.5+t,0.8+a,6000.\/CamSC,0.2*CamSC);\n    \n    vec3 col=vec3(0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv = (coord+vec2(i,j)\/float(AA))\/res;\n        vec3 d = normalize(ScrO+uv.x*ScrA+uv.y*ScrB - CamP);\n        col += castRay(CamP,d);\n    }\n    col\/=float(AA*AA);\n\n    \/\/col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    color = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\n\/\/ all sdf functions copy-pasted from iq ;)\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p\/r);\n  float k1 = length(p\/(r*r));\n  return k0*(k0-1.0)\/k1;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))\/baba;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nmat3 axisAngle(vec3 a, float t) {  \/\/ actually returns its inverse\/transpose\n\ta = normalize(a); float ct = cos(t), st = sin(t);\n\treturn mat3(\n\t\tct + a.x*a.x*(1.-ct), a.x*a.y*(1.-ct) - a.z*st, a.x*a.z*(1.-ct) + a.y*st,\n\t\ta.y*a.x*(1.-ct) + a.z*st, ct + a.y*a.y*(1.-ct), a.y*a.z*(1.-ct) - a.x*st,\n\t\ta.z*a.x*(1.-ct) - a.y*st, a.z*a.y*(1.-ct) + a.x*st, ct + a.z*a.z*(1.-ct)\n\t);\n}\n\n\n\/\/ ===================================== Animate =====================================\n\nvec3 animatePath(float t){\n    t*=4.0;\n    float d = 0.57*t;\n    float rx=1.0-exp(-0.4*t), ry=1.0-exp(-0.2*t), h=1.0-exp(-3.*t);\n    vec3 q = vec3(cos(t+d),sin(1.3*t+d),sin(2.*t));\n    q*=vec3(rx,ry,h)*vec3(0.2,0.2,0.2);\n    return q;\n}\n\n\/\/ ===================================== Archer =====================================\n\n\/\/ unlisted initial modeling: https:\/\/www.shadertoy.com\/view\/Wdsfzj\n\nvec3 MapC = vec3(0.0,0.5,0.6);\n\nfloat mapArch(vec3 p){\n    \/\/vec3 q = axisAngle(vec3(0,-1,0),0.15)*axisAngle(vec3(1,0,0),0.2)*(p-vec3(0,0,0.97));\n    vec3 q=mat3(0.988771,0,-0.149438,-0.0296888,0.980067,-0.196438,0.146459,0.198669,0.969061)*(p-vec3(0,0,0.97));\n    float c = sdEllipsoid(q,vec3(0.3,1.0,1.0-0.1*p.z));\n    q = p-vec3(0,-16,-0.4);\n\tfloat pz2 = (p.z-1.)*(p.z-1.);\n    c = smax(c,sdEllipsoid(q,vec3(2.0,15.8,16.0)),smax(0.05*(1.0-pz2),0.0,0.01));\n    float h = sdCapsule(p,vec3(0.05,-0.3,0.97),vec3(0.2+exp(0.15*p.y)-1.0,0.35,0.9),0.25+0.08*p.y-pz2);\n    float s = length(p-vec3(0.27,0.35,1.0))-0.25;\n    float v = sdCylinder(p,vec3(0.35,0.3,0.9),vec3(0.55,0.3,0.9),0.55*(p.y-0.1)+0.2*(p.x-0.3));\n    h=smin(h,v,0.1);\n    return smin(c,h,0.1);\n}\nfloat mapArm(vec3 p){\n    \/\/vec3 q = axisAngle(vec3(0,0,1),-0.3)*axisAngle(vec3(0,-1,0),0.1)*axisAngle(vec3(1,0,0),0.1)*(p-vec3(0.43,-0.37,1.0));\n    vec3 q = mat3(0.950564,0.294044,-0.0998334,-0.303565,0.947618,-0.0993347,0.0653952,0.12473,0.990033)*(p-vec3(0.43,-0.37,1.0));\n    return sdEllipsoid(q,vec3(0.05,0.11,0.25));\n}\nfloat mapBody(vec3 p){\n    float b = length(p.xy-vec2(-0.1,0.4-0.1*p.z))-0.21+0.01*p.z;\n    b = smax(b,abs(p.z-0.5)-0.5,0.05);\n    float c = sdEllipsoid(p-vec3(-0.1,0.35,0.9),vec3(0.35,0.4,0.35));\n    c = smin(b,c,0.2);\n    float u = length(p.xy-vec2(-0.1,0.47))-max(0.23-p.x*p.x,0.);\n    u = smax(u,abs(p.z-0.1*p.y-1.35)-0.35,max(0.1*(2.0-p.z),0.));\n    c = smin(u,c,0.2);\n    return c;\n}\nfloat archerTotal(vec3 p, float t) {\n\tfloat a = mapArch(p);\n\tfloat b = mapBody(p);\n\tfloat sd = smin(a, b, 0.2);\n\tfloat am = mapArm(p);\n\tsd = smin(sd, am, 0.05);\n\treturn mix(sd, length(p-vec3(0.0,0.0,0.8))-0.8, t);\n}\n\nvec3 archerPath(float t){\n    t-=4.7; if (t<0.) return vec3(0,0,1e12);\n    t=max(t-0.3,0.);\n    float h = 0.2+exp(-t*t)\/t;\n    vec3 p= animatePath(t-0.1)+vec3(0.0,0.5,h);\n    float m=sin(5.*t); m=m*m;\n    p.z=mix(p.z,m,clamp(0.5*(t-13.),0.,1.))+0.07;\n    p+=max(pow(12.*(t-16.9),3.),0.)*vec3(0,-1,1.5);\n    return p;\n}\nmat3 archerOrientation(float t){\n    t-=0.1;\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.7*(0.5-1.\/(t-3.))*sin(2.*t);\n    rx+=max(30.*(t-21.9),0.);\n    vec3 i=normalize(vec3(0,-1,0.3-rx)), j=normalize(vec3(1,0,0)), k=cross(i,j);\n    return transpose(mat3(i,j,k));\n}\n\nfloat archMeta(float t){\n    return clamp(2.0*(8.5-t),0.,1.);\n}\n\nfloat mapArcher(vec3 p, float t){\n    const float SC = 0.6;\n    mat3 R=archerOrientation(t)*(1.\/SC);\n    p=R*(p-archerPath(t));\n    return SC*archerTotal(p,archMeta(t));\n}\n\n\n\/\/ ===================================== Hand =====================================\n\nvec3 handPath(float t){\n    t-=4.7;\n    if (t<0.) return vec3(0,0,t*t*t);\n    t=max(t-0.3,0.);\n    vec3 p= animatePath(t);\n    p*=max(1.-exp(3.*(t-15.)),0.);\n    p+=max(pow(8.*(t-16.9),3.),0.)*vec3(0,-1,0.8);\n    if (t>18.0) p=vec3(0,0,0.5*pow(21.5-t,3.));\n    return p;\n}\nmat3 handOrientation(vec3 p, float t){\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.5*(0.5-1.\/(t-3.))*sin(2.*t);\n    rx*=max(1.-exp(5.*(t-20.5)),0.);\n    rx+=max(20.*(t-21.9),0.);\n    if (t>23.0) rx=0.1*sin(t);\n    vec3 i=normalize(vec3(1,0,0)), j=normalize(vec3(0,1,rx)), k=cross(i,j);\n    return (mat3(i,j,k));\n}\n\nfloat mapHand(vec3 p, float t){\n    mat3 M = handOrientation(p,t);\n    vec3 A0 = M*vec3(-0.2,-0.5,0.08);\n    vec3 A1 = M*vec3(-0.5,-0.18,-0.01);\n    vec3 A2 = M*vec3(-0.68,0.15,0.03);\n    vec3 A3 = M*vec3(-0.98,0.3,0.03);\n    vec3 B1 = M*vec3(-0.26,0.31,-0.05);\n    vec3 B2 = M*vec3(-0.36,0.65,-0.14);\n    vec3 B3 = M*vec3(-0.42,0.86,-0.15);\n    vec3 B4 = M*vec3(-0.50,1.12,-0.08);\n    vec3 C1 = M*vec3(-0.04,0.28,-0.08);\n    vec3 C2 = M*vec3(0,0.74,-0.23);\n    vec3 C3 = M*vec3(0,1,-0.16);\n    vec3 C4 = M*vec3(0,1.25,-0.08);\n    vec3 D1 = M*vec3(0.17,0.2,-0.08);\n    vec3 D2 = M*vec3(0.3,0.65,-0.17);\n    vec3 D3 = M*vec3(0.34,0.84,-0.12);\n    vec3 D4 = M*vec3(0.41,1.09,0);\n    vec3 E0 = M*vec3(0.23,-0.5,0.1);\n    vec3 E1 = M*vec3(0.39,0.10,-0.06);\n    vec3 E2 = M*vec3(0.53,0.36,-0.09);\n    vec3 E3 = M*vec3(0.62,0.51,-0.04);\n    vec3 E4 = M*vec3(0.68,0.75,0.09);\n    float r = 0.1;\n    \n    float d = 1e12;\n    p-=handPath(t);\n    #define CS(a,b) d=smin(d,sdCapsule(p,a,b,r),0.05)\n\tCS(A0,A1); CS(A1,A2); CS(A2,A3);\n\tCS(B1,B2); CS(B2,B3); CS(B3,B4);\n\tCS(C1,C2); CS(C2,C3); CS(C3,C4);\n\tCS(D1,D2); CS(D2,D3); CS(D3,D4);\n\tCS(E0,E1); CS(E1,E2); CS(E2,E3); CS(E3,E4);\n    #undef CS\n    return d;\n\n}\n\n\n\/\/ ===================================== Ring =====================================\n\nconst float Ground_Z = -1.0;\n\n#define ringR 0.15\n#define ringr 0.04\n\nvec3 ringPath(float t){\n    float t0=t;\n    const vec3 g = vec3(0,0,-9.8);\n    vec3 p=vec3(0.8,1.2,2.0), v=vec3(-0.5,-0.2,0.0);\n    float mt=0.0;\n    for (int i=min(int(t),0);i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)\/g.z;\n        if (mt>t){\n            return p+t*(v+0.5*g*t);\n        }\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    t=t0-2.5;\n    if (t<0.) return p;\n    if (t<.5) return p+0.5*t*t*g;\n    if (t0<23.) return handPath(t0)+handOrientation(vec3(0.0),t0)*vec3(0.3,0.6,-0.17);\n    p=vec3(0.5,0.7,5.0), v=vec3(0,0,-1), mt=0.0,t=t0-29.0;\n    if (t<0.) return vec3(0,0,1e12);\n    for (int i=min(int(t),0);i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)\/g.z;\n        if (mt>t){\n            return p+t*(v+0.5*g*t);\n        }\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    if (t0<33.5) return p;\n    return vec3(p.xy,max(p.z-0.5*(t0-33.5),Ground_Z+ringr));\n}\nmat3 ringOrientation(float t){\n    if (t<3.0) return mat3(1.0);\n    vec3 i=normalize(vec3(1.0,-0.3,0.0)),k=vec3(0,0,1),j=cross(k,i);\n    if (t<23.) transpose(handOrientation(vec3(0.0),t)*mat3(i,j,k));\n    t-=33.5;\n    if (t<0.) return mat3(1.0);\n    float a=clamp(5.*t,0.,.5*PI);\n    return mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a));\n}\n\nfloat mapRing(vec3 p, float t){\n    p = ringOrientation(t) * (p - ringPath(t));\n    return sdTorus(p,vec2(ringR,ringr));\n}\n\nfloat ringsm(float t){\n    if (t<2.5) return 0.0;\n    if (t<3.0) return t-2.5;\n    if (t>25.0) return 0.0;\n    return 0.1;\n}\n\n\n\/\/ ===================================== Together =====================================\n\n\nfloat map(vec3 p, float t){\n    float a=1e12,h=1e12,r=1e12,g=1e12;\n    a = 0.5*mapArcher(p,t);\n    h = mapHand(p,t);\n    r = mapRing(p,t);\n    g = p.z-Ground_Z;\n    if (t<0.) return g;\n    return min(a,min(smin(h,g,0.1),smin(r,g,ringsm(t))));\n}\n\n\nvec3 calcGrad(vec3 p, float t){\n    const float e = .001;\n#if 0\n\tfloat a = map(p+vec3(e,e,e),t);\n\tfloat b = map(p+vec3(e,-e,-e),t);\n\tfloat c = map(p+vec3(-e,e,-e),t);\n\tfloat d = map(p+vec3(-e,-e,e),t);\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n#else\n    vec3 n = vec3(0.0);\n    for(int i=min(int(t),0); i<4; i++){\n        vec3 h = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += h*map(p+h*e,t);\n    }\n    return normalize(n);\n#endif\n}\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"wljSDt","date":"1567533000","viewed":148,"name":"Burning-Ship ++","username":"harry7557558","description":"a zoom in to the Burning Ship Fractal","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* Also check:\n * Mandelbrot Fractal: https:\/\/www.shadertoy.com\/view\/wl2SWt\n * Burning-Ship Fractal: https:\/\/www.shadertoy.com\/view\/wljSDt\n * Forest Fractal: https:\/\/www.shadertoy.com\/view\/tt2SDt\n * Crown Fractal: https:\/\/www.shadertoy.com\/view\/tl2SDt\n *\/\n\n#define AA 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(-1.932246,6e-6);\n    vec2 p1 = vec2(-0.5,0.55);\n    float m1 = 6.0\/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0\/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5\/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)\/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*z.x-z.y*z.y,-abs(2.0*z.x*z.y))+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n\/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)\/20.0),6.0),\n                      pow(sin((m+1.0)\/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)\/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)\/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)\/20.0),6.0),\n                      pow(sin((n-2.0)\/20.0),4.0),\n                      0.8*pow(sin((n+2.0)\/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)\/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col\/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ws2yz1","date":"1586141443","viewed":90,"name":"COVID, Stop!","username":"harry7557558","description":"Today's Google Doodle: Stay Home. Save Lives: Help Stop Coronavirus.\n\n(of course, you don't your home to have virus.)\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["virus","coronavirus","covid19","covid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Shadertoy version of https:\/\/www.desmos.com\/calculator\/59x14hqpt3\n\/\/ I made this because that one is too slow\n\n#define res iResolution.xy\n#define t (1.2*iTime)\n#define PI 3.14159265358979\n\n#define cp(x) clamp(x,0.,1.)\n#define ss(x) (x)*(x)*(x)*((6.*(x)-15.)*(x)+10.)\n\nfloat smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-0.5\/k*d*d+a+b-.5*k);\n}\n\n\n\/\/ Virus Modeling\n\n#define R 0.74\n#define r 0.25\n#define n 8.\n#define df 0.058\n#define ff 14.4\n#define rc 1.06\nfloat u(vec2 p){ return length(vec2(rc*(p.x+df*cos(ff*p.y)-(R+r)),p.y))-r; }\n\n#define sm 0.156\nfloat V(vec2 p, float td, inout vec3 col){\n    float a = mod(atan(p.y,p.x)-td, 2.*PI\/n)-PI\/n;\n    vec2 q = length(p)*vec2(cos(a),sin(a));\n    float d = smin(u(q),length(p)-R,sm);\n    if (d<0.) col-=sqrt(dot(p,p)+.1)*vec3(0,1,1);\n    return d;\n}\n\n\n\/\/ Virus Crowd\n\n#define P1 vec2(-0.82,-0.35)\n#define v1 -0.5\n#define s1 0.85\n#define m1 0.095\n#define f1 3.\n#define P2 vec2(0.81,0.54)\n#define to 2.56\n#define v2 0.625\n#define s2 0.58\n#define m2 0.044\n#define f2 4.\n\nfloat Vs(vec2 p, inout vec3 col){\n    vec3 c1; float d1 = V((p-P1)\/s1+vec2(0,m1*sin(f1*t)),v1*t,c1);\n    vec3 c2; float d2 = V((p-P2)\/s2+vec2(0,m2*sin(f2*(t+to))),v2*(t+to),c2);\n    col += c1 + c2;\n    return min(d1,d2);\n}\n\n\n\/\/ Liquid\n\n#define wf 6.77\n#define wm 0.14\n#define wv 5.\n#define whf 0.15\nfloat whfs(float x) { return x<0.5?0.:x<1.5?ss(x-0.5):x<2.?1.:1.-ss(x-2.); }\n\nfloat W(float x, float y, inout vec3 col){\n    float wh = 4.*whfs(mod(whf*t,3.))-2.5;\n    float d = y-(wm*exp(sin(wf*x+wv*t))+wh);\n    if (d<0.) col-=(1.-exp(y-wh-3.*wm))*vec3(1,.8,0);\n    return d;\n}\n\n\n\/\/ Main\n\nfloat scene(vec2 p, inout vec3 col){\n    float clip = max(abs(p.x)-3.,abs(p.y)-2.);\n    float sd = smin(Vs(p,col),W(p.x,p.y,col),0.1);\n    if (clip>0.) col=vec3(1.);\n    return max(clip,sd);\n}\n\nfloat house(vec2 p){\n    vec2 b = abs(p);\n    float u = max(b.x-3.,b.y-2.);\n    float v = min(p.y+2.,min(3.-b.x,(7.-2.*p.y-b.x)\/sqrt(5.)));\n    return min(abs(u),abs(v));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    col.xyz = vec3(1.0);\n    float S = min(res.x,res.y);\n    vec2 p = 7.0*(coord-0.5*res)\/S-vec2(0,-.5);\n    float ds = scene(p,col.xyz);\n    float d = abs(ds)\/length(vec2(dFdx(ds),dFdy(ds))) - .001*S;\n    col.xyz *= cp(d)*cp(house(p)*.14*S-.001*S);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"sddXWj","date":"1633995209","viewed":321,"name":"Cook-Torrance IS Attempt","username":"harry7557558","description":"Attempt to implement importance sampling for Cook-Torrance BRDF, somehow cannot get it right.\nLeft\/Right: without\/with importance sampling, look slightly different.\nIf someone could point out the problem or give a fix I'd appreciate :)","likes":17,"published":1,"flags":32,"usePreview":1,"tags":["sampling","sample","pbr","cooktorrance","importance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ see Buffer A\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Left: without importance sampling\n\/\/ Right: with importance sampling for GGX normal\n\/\/ The two versions look slightly different. Should be the same.\n\n\/\/ if there is no bug with GGX importance sampling,\n\/\/ left and right should be the same when this is set to 1\n#define DEBUG_GGX 0\n\n\/\/ References:\n\/\/ http:\/\/www.codinglabs.net\/article_physically_based_rendering_cook_torrance.aspx\n\/\/ https:\/\/pbr-book.org\/3ed-2018\/Reflection_Models\/Microfacet_Models\n\/\/ https:\/\/agraphicsguy.wordpress.com\/2015\/11\/01\/sampling-microfacet-brdf\/\n\/\/ https:\/\/www.shadertoy.com\/view\/3slSzn\n\/\/ https:\/\/computergraphics.stackexchange.com\/questions\/4394\/path-tracing-the-cook-torrance-brdf\n\n\/\/ A Desmos implementation of the BRDF:\n\/\/ https:\/\/www.desmos.com\/calculator\/zccocbuygk\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\n\/\/ random number generator\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat rand01() { return float(randu()) * (1.\/4294967296.); }\n\n\n\/\/ cubemap lighting\nvec3 light(vec3 rd) {\n    vec3 col = texture(iChannel1, rd.yzx).xyz;\n    vec3 bri = vec3(1.0) + vec3(2.0) * pow(max(dot(rd, normalize(vec3(-0.2, -0.5, 0.5))), 0.), 4.);\n    return col * bri;\n}\n\n\n\/\/ sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.0) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n\/\/ sample hemisphere distributions\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\nvec3 sampleUniformHemisphere(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rz = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(1.0-rz*rz) * vec2(cos(an), sin(an));\n    return rh.x * u + rh.y * v + rz * n;\n}\n\n\n\/\/ sample GGX, return weight (Fr divided by PDF)\n\/\/ At least one of the two functions have a bug\nfloat sampleGgxSimple(in vec3 wi, in float alpha, out vec3 wo) {\n    wo = sampleUniformHemisphere(vec3(0, 0, 1));\n    vec3 m = normalize(wi+wo);\n    float denom = (alpha*alpha-1.)*m.z*m.z+1.;\n    float Fr = alpha*alpha \/ (PI * denom*denom);\n    return Fr \/ (1.0\/(2.0*PI));\n}\nfloat sampleGgxImportance(in vec3 wi, in float alpha, out vec3 wo) {\n    float su = 2.0*PI*rand01();\n    float sv = rand01();\n    \/\/sv = acos(sqrt((1.0-sv)\/((alpha*alpha-1.)*sv+1.)));\n    sv = atan(alpha*sqrt(sv\/(1.0-sv)));\n    vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n    wo = -(wi-2.0*dot(wi,h)*h);\n    return wo.z<0. ? 0. : 4.0*dot(wi, h);\n}\n\n\n\/\/ as global variable\nbool ImportanceSampling;\n\n\n\/\/ return random output ray direction, multiply m_col by weight\nvec3 sampleCookTorrance(\n    vec3 wi, vec3 n,\n    float alpha,  \/\/ roughness\n    float f0,  \/\/ ratio of reflection along the normal\n    float lambertian,  \/\/ ratio of lambertian coefficient\n    vec3 lambert_col,  \/\/ lambertian color\n    vec3 microfacet_col,  \/\/ microfacet color\n    inout vec3 m_col\n    ) {\n\n#if !DEBUG_GGX\n    if (ImportanceSampling) {\n        if (rand01() < lambertian) {\n            vec3 wo = sampleCosWeighted(n);\n            m_col *= lambert_col;\n            return wo;\n        }\n    }\n#endif\n\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wo, m;  \/\/ out and half vector\n\n    \/\/ GGX divided by PDF\n    float D;\n    if (ImportanceSampling) D = sampleGgxImportance(wi, alpha, wo);\n    else D = sampleGgxSimple(wi, alpha, wo);\n    \/\/ uncomment to see if lambert sampling is ok\n    \/\/D = sampleGgxSimple(wi, alpha, wo);\n\n    \/\/ debug GGX importance sampling\n#if DEBUG_GGX\n    m_col *= 0.25*D*wo.z; return wo.x*u+wo.y*v+wo.z*n;\n#endif\n    m = normalize(wi+wo);\n\n    \/\/ Geometry\n    float tan2_theta_i = (1.0-wi.z*wi.z)\/(wi.z*wi.z);\n    float tan2_theta_o = (1.0-wo.z*wo.z)\/(wo.z*wo.z);\n    float lambda_i = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_i)-1.0);\n    float lambda_o = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_o)-1.0);\n    float G = 1.0\/(1.0+lambda_i+lambda_o);\n\n    \/\/ Fresnel\n    float F = f0 + (1.0-f0)*pow(1.0-dot(wi, m), 5.0);\n\n    \/\/ Put all together\n    float Fr = D*G*F \/ (4.0*wi.z*wo.z+1e-4);\n    float Fr_cos = Fr * wo.z;  \/\/ wo is the direction of light in path tracing\n    if (ImportanceSampling) {\n        m_col *= Fr_cos * microfacet_col;\n    }\n    else {\n        vec3 col = lambertian * lambert_col \/ (1.0\/2.0) + (1.0-lambertian) * microfacet_col * Fr;\n        m_col *= col * wo.z;\n    }\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n\/\/ path tracing\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    const int background = -1;\n    const int lambertian = 0;\n    const int mat_floor = 1;\n\n    vec3 m_col = vec3(1.0), col;\n    bool is_inside = false;\n\n    for (int step = int(ZERO); step < 64; step++) {\n        ro += 1e-4f*rd;\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        int material = background;\n\n        \/\/ plane\n        t = -ro.z \/ rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            col = vec3(0.9, 0.95, 0.98);\n            \/\/material = lambertian;\n            material = mat_floor;\n        }\n\n        \/\/ objects\n        for (float i = 0.; i < 6.; i++) {\n            t = min_t;\n            vec3 pos = vec3(2.2*vec2(cos(2.*PI*i\/6.), sin(2.*PI*i\/6.)), 1.0+1e-4);\n            if (intersectSphere(pos, 1.0, ro, rd, t, n)) {\n                min_t = t, min_n = n;\n                col = vec3(1.0);\n                material = int(i)+2;\n            }\n        }\n\n        \/\/ update ray\n        if (material == background) {\n            col = light(rd);\n            return m_col * col;\n        }\n        ro = ro + rd * min_t;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;\n        if (material == lambertian) rd = sampleCosWeighted(min_n), m_col *= col;\n        if (material == mat_floor) rd = sampleCookTorrance(-rd, min_n, 0.3, 0.4, 0.2, col, col, m_col);\n        if (material == 2) rd = sampleCookTorrance(-rd, min_n, 0.8, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 3) rd = sampleCookTorrance(-rd, min_n, 0.4, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 4) rd = sampleCookTorrance(-rd, min_n, 0.1, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 5) rd = sampleCookTorrance(-rd, min_n, .02, 0.4, 0.0, vec3(1.0), col, m_col);\n        if (material == 6) rd = sampleCookTorrance(-rd, min_n, 0.1, 0.4, 0.5, vec3(0.8,0.4,0.1), vec3(1.0), m_col);\n        if (material == 7) rd = sampleCookTorrance(-rd, min_n, .01, 0.4, 0.2, vec3(0.8,1.0,0.8), vec3(0.6,0.6,1.0), m_col);\n        if (m_col == vec3(0.0)) break;\n        if (dot(rd, min_n) < 0.0) is_inside = !is_inside;\n        if (is_inside) return vec3(1, 0, 0);  \/\/ should not happen\n    }\n    return m_col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ImportanceSampling = fragCoord.x > 0.5*iResolution.x;\n\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW by David Hoskins, MIT licence\n    vec3 p3 = fract(vec3(fragCoord\/iResolution.xy, sin(0.001*float(iFrame))) * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    seed = uint(16777216.*h);\n\n    \/\/ camera\n    vec2 mouse_uv = iMouse.z==0. ? vec2(0.6,0.4) : iMouse.xy\/iResolution.xy;\n    float rx = 1.8*mouse_uv.y-0.3;\n    float rz = -mouse_uv.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(rand01(),rand01())-0.5)\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 1.8*length(iResolution.xy));\n    rd = normalize(rd);\n\n    \/\/ calculate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)\/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tl2SDt","date":"1567534664","viewed":105,"name":"Crown-Fractal++","username":"harry7557558","description":"a zoom in to fractal defined by iteration z\u21a6Re(z\u00b3)-|Im(z\u00b3)|i+c","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* Also check:\n * Mandelbrot Fractal: https:\/\/www.shadertoy.com\/view\/wl2SWt\n * Burning-Ship Fractal: https:\/\/www.shadertoy.com\/view\/wljSDt\n * Forest Fractal: https:\/\/www.shadertoy.com\/view\/tt2SDt\n * Crown Fractal: https:\/\/www.shadertoy.com\/view\/tl2SDt\n *\/\n\n#define AA 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(0.0,1.285023);\n    vec2 p1 = vec2(0.0,0.4);\n    float m1 = 6.0\/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0\/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5\/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)\/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*(z.x*z.x-3.0*z.y*z.y),-abs(z.y*(3.0*z.x*z.x-z.y*z.y)))+c;\n            float h = dot(z,z);\n            if (h>2.8243e+11){\n                float n = float(i)-log(0.5*log(h)\/log(3.0))\/log(3.0)+4.0;\n                float m = exp(-n*n\/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)\/20.0),6.0),\n                      pow(sin((m+1.0)\/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)\/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)\/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)\/20.0),6.0),\n                      pow(sin((n-2.0)\/20.0),4.0),\n                      0.8*pow(sin((n+2.0)\/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)\/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col\/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wtfyWj","date":"1593051545","viewed":123,"name":"Ellipse Distance Comparison","username":"harry7557558","description":"Comparing two ellipse distance methods found on the internet.\n\nmouseable","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","ellipse","compare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Comparing two ellipse distance methods found on the internet\n\/\/ The solution that solves a quartic equation is in Common\n\/\/ The iteration method works ~1.2 times faster than the analytical one\n\/\/ Step length may need to be reduced when using the iteration method in raymarching\n\n\n\n\/\/ This iteration method is introduced in\n\/\/ https:\/\/wet-robots.ghost.io\/simple-method-for-distance-to-ellipse\/\n\n\/\/ Line 23: the asin() is removed to increase performance\n\nfloat sdEllipse_iter(vec2 p, vec2 ab){\n    p = abs(p);\n    float t = 0.785398;\n    vec2 xy;\n    for (int i=0;i<3;i++){\n        vec2 cs = vec2(cos(t),sin(t));\n        xy = ab*cs;\n        vec2 e = (ab.x*ab.x-ab.y*ab.y)*vec2(1,-1)*cs*cs*cs\/ab;\n        vec2 r = xy-e, q = p-e;\n        \/\/float rm = length(r), qm = length(q);\n        \/\/float dc = rm*asin((r.x*q.y-r.y*q.x)\/(rm*qm));\n        float dc = (r.x*q.y-r.y*q.x)\/length(q);\n        float dt = dc\/sqrt(dot(ab,ab)-dot(xy,xy));\n        t += dt;\n        t = min(1.570796,max(0.,t));\n    }\n    vec2 q = p\/ab;\n    return sign(dot(q,q)-1.)*length(p-xy);\n}\n\n\n\n\n#define res iResolution.xy\n#define AA 16\n\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 ab = vec2(1.+.8*cos(iTime),1.);\n    float SC = 7.\/res.x;\n    float T = iMouse.z>0.?SC*(iMouse.x-.5*res.x):1e8;\n    vec2 p0 = SC*(Pos-.5*res);\n    \n    \/\/ use AA to waste time to compare performance\n    float d = 0.;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 p = p0+SC*vec2(i,j)\/float(AA);\n        if (p.x<T) d += sdEllipse_iter(p,ab);\n        else d += sdEllipse(p,ab);\n    }\n    d \/= float(AA*AA);\n    \n    \/\/ color\n    vec3 col = vec3(.8)-sign(d)*vec3(.1,.4,.2);\n    col *= (.2*cos(60.*d)+.8)*(1.-exp(-5.*abs(d)));\n    col = mix(col,vec3(1,1,0),clamp(2.-60.*abs(d),0.,1.));\n    col = mix(col,vec3(1),clamp(2.-60.*abs(p0.x-T),0.,1.));\n    Col = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Ellipse distance function copy-pasted from iq\n\/\/ https:\/\/iquilezles.org\/articles\/ellipsedist\n\n\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = abs( z ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x\/l; float m2 = m*m;\n    float n = ab.y*p.y\/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)\/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q\/c3)\/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)\/(rx*ry) - m)\/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0\/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0\/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry\/sqrt(rm-rx);\n        co = (p + 2.0*g\/rm - m)\/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"wsfyzB","date":"1585167026","viewed":168,"name":"Exponential Regression","username":"harry7557558","description":"Fitting the number of COVID-19 daily reported cases in four countries using regression. Click and drag to read the value.\n\nAny idea about how can I make the compilation faster?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["leastsquare","coronavirus","covid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ COVID-19 daily reported cases since Mar.1\n\/\/ Data source: https:\/\/www.worldometers.info\/coronavirus\/\n#define N 26\nint US[N] = int[N](75,100,124,158,221,319,435,541,704,994,1301,1697,2247,2943,3680,4663,6411,9259,13789,19383,24207,33566,43734,54856,68211,85435);  \/\/ US\nint IT[N] = int[N](1701,2036,2502,3089,3858,4636,5883,7375,9172,10149,12462,15113,17660,21157,24747,27980,31506,35713,41035,47021,53578,59138,63927,69176,74386,80589);  \/\/ IT\nint ES[N] = int[N](84,120,165,228,282,401,525,674,1231,1695,2277,3146,5232,6391,7988,9942,11826,14769,18077,21571,25496,28768,35136,42058,49515,57786);  \/\/ ES\nint DE[N] = int[N](130,165,203,262,545,670,800,1040,1224,1565,1966,2745,3675,4599,5813,7272,9367,12327,15320,19848,22364,24873,29056,32991,37323,43938);  \/\/ DE\n\/\/int FR[N] = int[N](130,191,212,285,423,653,949,1209,1412,1784,2281,2876,3661,4499,5423,6633,7730,9134,10995,12612,14459,16018,19856,22304,25233,29155);  \/\/ FR\n\/\/int GB[N] = int[N](36,39,51,87,116,164,209,278,321,383,460,590,798,1140,1391,1543,1950,2626,3269,3983,5018,5683,6650,8077,9529,11658);  \/\/ UK\n\n\n\n\/*================================ Fitting Code ================================*\/\n\n\/\/ linear and quadratic regression\n#define LinearReg float m=1.0\/(s*sx2-sx*sx); a=m*(s*sxy-sx*sy), b=m*(sx2*sy-sx*sxy);\n#define QuadReg float r0=sx2*s-sx*sx,r1=sx3*s-sx*sx2,r2=sx3*sx-sx2*sx2,r21=sx4*sx-sx2*sx3,m=1.0\/(sx4*r0-sx3*r1+sx2*r2); a=(sx2y*r0-sxy*r1+sy*r2)*m, b=-(sx2y*r1-sxy*(sx4*s-sx2*sx2)+sy*r21)*m, c=(sx2y*r2-sxy*r21+sy*(sx4*sx2-sx3*sx3))*m;\n\n\/\/#define Z min(0,iFrame)\n#define Z 0\n\n\/\/ Method 1: y = exp(ax+b), minimum \u03a3 [ln(y)-(ax+b)]\u00b2\nvoid fitLinear(in int[N] Y, out float a, out float b){\n\tfloat s = float(N), sx = .5*s*(s-1.), sx2 = sx*(2.*s-1.)\/3.,\n        sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat y = log(float(Y[i]));\n\t\tsy += y, sxy += float(i)*y;\n\t}\n\tLinearReg\n}\n\n\/\/ Method 2: y = exp(ax+b), minimum \u03a3 y\u00b7[ln(y)-(ax+b)]\u00b2\nvoid fitLinear_S(in int[N] Y, out float a, out float b){\n\tfloat s = 0., sx = 0., sx2 = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), ey = float(Y[i]), y = log(ey);\n\t\tsx2 += x*x*ey, sx += x*ey, s += ey, sxy += x*y*ey, sy += y*ey;\n\t}\n\tLinearReg\n}\n\n\/\/ Method 3: y = exp(ax\u00b2+bx+c), minimum \u03a3 [ln(y)-(ax\u00b2+bx+c)]\u00b2\nvoid fitQuadratic(in int[N] Y, out float a, out float b, out float c){\n\tfloat s=float(N), sx=.5*s*(s-1.), sx2=sx*(2.*s-1.)\/3., sx3=sx*sx, sx4=.2*sx2*(s*(s-1.)*3.-1.),\n        sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), y = log(float(Y[i]));\n\t\tsx2y += x*x*y, sxy += x*y, sy += y;\n\t}\n    QuadReg\n}\n\n\/\/ Method 4: y = exp(ax\u00b2+bx+c), minimum \u03a3 y\u00b7[ln(y)-(ax\u00b2+bx+c)]\u00b2\nvoid fitQuadratic_S(in int[N] Y, out float a, out float b, out float c){\n\tfloat s = 0., sx = 0., sx2 = 0., sx3 = 0., sx4 = 0., sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), e = float(Y[i]), y = log(e), x2 = x*x;\n\t\tsx4 += x2*x2*e, sx3 += x2*x*e, sx2 += x2*e, sx += x*e, s += e;\n\t\tsx2y += x2*y*e, sxy += x*y*e, sy += y*e;\n\t}\n    QuadReg\n}\n\n\/\/ Method 4 should work best, but I don't think it can\n\/\/ be used for prediction because quadratic functions don't converge\n\n\n\n\/*================================ Visualizing Code ================================*\/\n\n#define res iResolution.xy\n#define Clamp(x) clamp(x,0.,1.)\n#define length2(p) dot(p,p)\n#define S sqrt(res.x*res.y)\n\n#define W 30.\n#define H 100000.\n#define SW (W\/res.x)\n#define SH (res.y\/H)\n\nvoid drawData(in int[N] K, vec3 bcol, vec2 p, inout vec3 col){\n    float a, b, c;\n    float x = p.x*SW, y, dy, sd;\n    \/\/ linear regression for log\n    fitLinear(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)\/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.02*(1.-Clamp(sd-.010*S)));\n    \/\/ weighted linear regression for log\n    fitLinear_S(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)\/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.2),0.2), 0.2*(1.-Clamp(sd-.006*S)));\n    \/\/ quadratic regression for log\n    fitQuadratic(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)\/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.04*(1.-Clamp(sd-.008*S)));\n    \/\/ weighted quadratic regression for log\n    fitQuadratic_S(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)\/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.5),0.2), 0.8*(1.-Clamp(sd-.0045*S)));\n    \/\/ data points\n    sd = 1e8;\n    for (int i=0; i<N; i++){\n        vec2 q = vec2(i,K[i])*res\/vec2(W,H);\n        sd = min(sd,length2(p-q));\n    }\n    col = mix(bcol, col, Clamp(sqrt(sd)-.008*S));\n}\n\n\/\/ distance to fitted curve\nfloat dist(in int[N] K, vec2 p) {\n    float a,b,c; fitQuadratic_S(K,a,b,c);\n    float x=p.x*SW, y=exp((a*x+b)*x+c)*SH, dy=(2.*a*x+b)*SW*y;\n    return y>res.y?res.y:abs(y-p.y)\/sqrt(dy*dy+1.0);\n}\n\n#define _(c) T+=u.x<.0||u.x>1.||u.y<0.||u.y>1.?vec4(0):textureGrad(iChannel0,u\/16.+fract(vec2(c,15-(c)\/16)\/16.),dFdx(u\/16.),dFdy(u\/16.));u.x-=.5;\nfloat text(vec2 p, int d, int n) {\n    vec4 T = vec4(0);\n    vec2 u = p-vec2(0,.5); _(77)_(97)_(114)_(46)_(d\/10+48)_(d%10+48);\n    u = p+vec2(0,.5); _(n\/10000+48)_(46)_(n\/1000%10+48)_(n\/100%10+48)_(107)_(32);\n    return T.w==0.?-1.:T.x;\n}\n\n#define pad 0.1\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 p = (1.0+2.*pad)*(coord-0.5*res);\n    vec3 col = max(abs(p.x)-.5*res.x,abs(p.y)-.5*res.y)>0. ? vec3(0.9) : vec3(1.0);\n    p+=0.5*res;\n    if (iMouse.z>0.) {\n        \/\/ initial and current mouse position\n        vec2 mp = (1.+2.*pad)*iMouse.zw-pad*res;\n        vec2 ms = (1.+2.*pad)*iMouse.xy-pad*res;\n        \/\/ find the curve that is closest to the initial mouse position\n        int K[N]; float d, md=1e9;\n        if ((d=dist(US,mp))<md){md=d; K=US;}\n        if ((d=dist(IT,mp))<md){md=d; K=IT;}\n        if ((d=dist(ES,mp))<md){md=d; K=ES;}\n        if ((d=dist(DE,mp))<md){md=d; K=DE;}\n        \/\/ visualize that curve\n        drawData(K,vec3(1,.5,0),p,col);  \/\/ fitting curve\n        col = mix(vec3(1,0,1),col,Clamp(abs(ms.x-p.x)-0.0005*S));  \/\/ vertical line\n        float a,b,c; fitQuadratic_S(K,a,b,c);  \/\/ curve params\n        vec2 I; I.x=ms.x, I.y=exp((a*SW*I.x+b)*I.x*SW+c)*SH;  \/\/ value point\n        col = mix(vec3(1,0,0),col,Clamp(length(I-p)-0.01*S));  \/\/ render value point\n        if (I.x>0.&&I.x<res.x&&I.y>0.&&I.y<res.y){  \/\/ render text\n            vec2 T = I-vec2(-5,10);\n            float c = text(25.*(p-I)\/S+vec2(-.3,.2), int(W*I.x\/res.x)+1, int(I.y\/SH));\n            if (c>=0.) col = mix(mix(col,vec3(.8),0.7),vec3(0),c);\n        }\n    }\n    else {\n    \tdrawData(DE,vec3(.84,.0,.0),p,col);\n    \tdrawData(ES,vec3(.78,.37,.0),p,col);\n    \tdrawData(IT,vec3(.0,.55,.25),p,col);\n    \tdrawData(US,vec3(.25,.25,.4),p,col);\n    }\n    color = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wly3WG","date":"1579723999","viewed":272,"name":"Fitting Arc using B\u00e9zier","username":"harry7557558","description":"Least square fitting an unit arc using cubic bezier curve. \nEllipse fitting can be done by simply applying a linear transform. ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["bezier","circle","approximation","arc","fitting","leastsquare","2021"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tFitting an unit arc using cubic bezier curve\n\tEllipse fitting can be done by simply applying a linear transform.\n\n\tBasic Idea:\n\n\tLet the start point be A(0,1) and the endpoint be B(cos\u03b8,sin\u03b8), the two other \n\tcontrol points be C(1,x) and D=B+x*(sin\u03b8,-cos\u03b8). Let the equation of the bezier \n\tcurve be P(t)=(1-t)\u00b3\u00b7A+3t(1-t)\u00b2\u00b7B+3t\u00b2(1-t)\u00b7C+t\u00b3\u00b7D and the error be \n\tE(x)=Integral[(P\u00b2-1)\u00b2,t,0,1]. This integral is be a quartic polynomial \n\tabout x. Let its derivative equal to zero and solve for x, thus determine \n\tcontrol point B and C.\n\n\tSince the calculation is very machanical and error-prone, I used WolframAlpha \n\tto do expanding, integration and differentiation.\n\n\tAs one can see, when \u03b8<2rad, it's not easy to notice the difference between the \n\tcircle and the fitted curve.\n\n\t2020-03-05:\n\tAdd numerical approximation solutions generated by polynomial regression.\n\t(Simpson's integration in [0,2], 2\u00d7100000 samples, Gaussian elimination, double-precision)\n*\/\n\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\n#define Clamp(x) clamp(x,0.,1.)\n\nstruct Bezier3{\n    vec2 A, B, C, D;\n};\n\n\n\/\/ ========================= Fitting Code =========================\n\n\nvoid fitArc(float a, out Bezier3 R) {\n    float S = sin(a), C = cos(a), x;\n#if 1\n    \/\/ derivative of error: error'=ax\u00b3+bx\u00b2+cx+d\n\tfloat s2 = S * S, c2 = C * C, sc2 = s2 + c2, sc22 = sc2 * sc2;\n\ta = 1. \/ (756.*(sc22 + 1.) + 810.*s2 - 1890.*(sc2 + 1.)*C + 2430.*c2);\n\tfloat c = (2520.*sc22 + 2736.*s2 + (-507.*sc2 - 6600.*C + 7215.)*C - 2628.) * a,\n\t\tb = (3996.*(sc2 + 1.) - 6750.*C)*S * a, d = (3439.*sc2 + 4276.*C - 7715.)*S * a;\n    \/\/ solve the cubic equation to determine the minima\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b \/ 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tx = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5*_13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    \/\/ 450+ time unit\n#else\n    \/\/ numerical approximation\n    \/\/ 12 time unit, ERR = 2.75e-04, RMSE = 8.02e-05, notable error\n    x = ((0.008561080643*a-0.002518989170)*a+0.334292025655)*a;\n    \/\/ 23 time unit, ERR = 2.51e-06, RMSE = 6.29e-07, few error\n    x = ((((0.000223623140*a-0.000237833794)*a+0.007216725971)*a-0.000130686154)*a+0.333353941704)*a;\n    \/\/ 28 time unit, ERR = 2.71e-07, RMSE = 6.11e-08, no visible error\n    x = (((((0.000027936409*a+0.000060660755)*a+0.000117720501)*a+0.006861171676)*a+0.000027337977)*a+0.333330238084)*a;\n#endif\n    \/\/ apply the solution of the equation to the control points\n    R.A=vec2(1,0), R.B=vec2(1,x), R.C=vec2(C+x*S,S-x*C), R.D=vec2(C,S);\n}\n\nfloat sdBezier3(in Bezier3 R, in vec2 p) {\n\tvec2 A = R.D-R.A+3.*(R.B-R.C), B = 3.*(R.C-2.*R.B+R.A), C = 3.*(R.B-R.A);\n\tvec2 a=vec2(1,0), b, pa=p-a, ba, q;\n\tfloat d = dot(pa,pa);\n\tfor (float dt=.02, t = dt; t < 1.; t += dt) {\n\t\tb = ((A*t + B)*t + C)*t + R.A;\n\t\tpa=p-a, ba=b-a, q=pa-ba*Clamp(dot(pa,ba)\/dot(ba,ba));\n\t\td = min(d, dot(q,q));\n\t\ta = b;\n\t}\n\treturn sqrt(d);\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-.5*res)\/length(res);\n    float h = .2*length(res); \t\/\/ hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x), a;\n    if (iMouse.z>0.){\n        vec2 d = iMouse.xy-.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    }\n    else a = sin(iTime), a=PI*a*a;\n    if (ang<0.) ang+=2.*PI; if (a<0.) a+=2.*PI;\n\n    \/\/ axis\n    vec2 axis = Clamp(h*(abs(p)-.02));\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),min(axis.x,axis.y));\n\n    \/\/ circle\n    float circ = Clamp(h*(abs(length(p)-1.)-.02));\n    vec3 c = mix(ang<a?vec3(1,0,0):vec3(.7),bkg,circ);\n\n    \/\/ bezier curve\n    Bezier3 R;\n    fitArc(a, R);\n    float d = sdBezier3(R,p);\n    c = mix(vec3(0),c,Clamp(h*(d-.01)));\n\n    \/\/ vertexes\n    d = min(length(p-R.B),length(p-R.C))-.04;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.002)));\n    d = min(length(p-R.A),length(p-R.D))-.05;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.005)));\n\n    col = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tttSRH","date":"1580425863","viewed":98,"name":"Fitting Arc using B\u00e9zier 2","username":"harry7557558","description":"Cubic version see there: [url]https:\/\/www.shadertoy.com\/view\/wly3WG[\/url]\nThese fitting functions are used to convert ellipse arcs in an SVG path into uniform bezier curve, because I don't want to write hundreds of lines of code specifically for ellipses.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier","circle","arc","fitting","leastsquare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tFitting an unit arc using a quadratic bezier curve\n\tCubic version: https:\/\/www.shadertoy.com\/view\/wly3WG\n\n\tAs one can see, cubic fitting is much better than quadratic fitting.\n\n    Since rendering quadratic is much faster than cubic, fitting the arc\/ellipse\n    using multiple quadratic bezier curves is still better. It's not easy to notice \n    the C0 continuety.\n\n*\/\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\nstruct Bezier2{\n    vec2 A, B, C;\n};\n\n\n\/\/ ========================= Fitting Code =========================\n\n\n#if 0\n\n\/\/ along the tangent\nvoid fitArc(in float theta, out Bezier2 R) {\n    float c = cos(theta), s = sin(theta);\n    float k = theta==0.0 ? 0.0 : (1.0 - c) \/ s;\n    R.A = vec2(1.0, 0.0), R.B = vec2(1.0, k), R.C = vec2(c, s);\n}\n\n#else\n\n\/\/ least square, let the control point be k*(cos(\u03b8\/2),sin(\u03b8\/2))\nvoid fitArc(in float theta, out Bezier2 R) {\n    \/\/ derivative of error: error'=ax\u00b3+bx\u00b2+cx+d\n    \/\/ thanks https:\/\/www.integral-calculator.com\/ for helping me integrate that disgusting function!\n    float alpha = 0.5 * theta;\n\tfloat s1 = sin(alpha), s2 = s1 * s1, s4 = s2 * s2, s6 = s4 * s2,\n\t\tc1 = cos(alpha), c2 = c1 * c1, c3 = c2 * c1, c4 = c3 * c1, c5 = c4 * c1, c6 = c4 * c2, c7 = c5 * c2;\n    float a = 32.*s4+64.*c2*s2+32.*c4,\n        b = (60.*c1*s4+(120.*c3+60.*c1)*s2+60.*c5+60.*c3) \/ a,\n        c = (20.*s6+(100.*c2-16.)*s4+(140.*c4+32.*c2-148.)*s2+60.*c6+48.*c4-108.*c2) \/ a,\n        d = (35.*c1*s6+(105.*c3-5.*c1)*s4+(105.*c5+10.*c3-131.*c1)*s2+35.*c7+15.*c5-111.*c3-91.*c1) \/ a;\n    \/\/ calculate the minima (zero derivative), solve a the cubic function\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b \/ 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tfloat k = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5 * _13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    \/\/ apply the solution of the equation to the control points\n    R.A = vec2(1.0, 0.0), R.B = k * vec2(c1, s1), R.C = vec2(c1*c1-s1*s1, 2.0*c1*s1);\n}\n\n#endif\n\n\n\n\/\/ ========================= Rendering Code =========================\n\n\n\/\/ quadratic bezier distance approximation by tayholliday: https:\/\/www.shadertoy.com\/view\/XsX3zf\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf\/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n  float t=clamp((ap+bp)\/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t);\n}\nfloat sdBezier2(in Bezier2 R, in vec2 p) {\n  return length(get_distance_vector(R.A-p, R.B-p, R.C-p));\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-0.5*res)\/length(res);\n    float h = 0.2*length(res); \t\/\/ hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x);\n    if (ang<0.0) ang += 2.0*PI;\n    float a = sin(0.6*iTime); a=1.8*PI*a*a;\n    int n = int(abs(a)\/1.5) + 1;\n    float da = a \/ float(n);\n    if (iMouse.z>0.0){\n        vec2 d = iMouse.xy-0.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    \tif (a<0.0) a += 2.0*PI;\n        n=1, da=a;\n    }\n\n    \/\/ axis\n    vec2 axis = clamp(h*(abs(p)-0.02),0.0,1.0);\n    float bk = min(axis.x,axis.y);\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),bk);\n\n    \/\/ circle\n    float circ = clamp(h*(abs(length(p)-1.0)-0.02),0.0,1.0);\n    vec3 c = (ang<a)?vec3(1,0,0):vec3(0.7);\n    c = mix(c,bkg,circ);\n\n    \/\/ bezier curve\n    Bezier2 R;\n    fitArc(da, R);\n    if (ang<a){\n        float t = mod(ang,da);\n        vec2 q = length(p)*vec2(cos(t),sin(t));\n    \tfloat d = sdBezier2(R,q);\n    \tc = mix(vec3(0),c,clamp(h*(d-0.01),0.0,1.0));\n    }\n\n    \/\/ control points\n    float d = length(p-R.B)-0.04;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.002),0.0,1.0));\n    d = min(length(p-R.A),length(p-R.C))-0.05;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.005),0.0,1.0));\n\n    col = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WsySWt","date":"1575254924","viewed":157,"name":"Float Limit Exceed","username":"harry7557558","description":"sawtooth effect produced by exceeding of float point accuracy limit","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["graph","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f(in float x){\n    return 0.25*(pow(exp(x)+exp(-x),2.0)-pow(exp(x)-exp(-x),2.0)); \t\/\/ always equal to 1\n}\n\nfloat grad(in float x){\n    const float eps = 1e-2;\n    float a = (f(x+eps)-f(x-eps))\/(2.0*eps);\n    return sqrt(a*a+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.05*(sin(iTime)+2.0)*length(iResolution.xy);\n    vec2 p = (fragCoord-0.5*iResolution.xy)\/s+vec2(10.0*sin(0.2*iTime),1.0);\n    float sd = 1.0-min(0.2*s*(abs(p.x)-0.008),1.0);\n    vec3 col = vec3(0,0,sd);\n    sd = min(s*(abs(p.y)-0.03),1.0);\n    col = mix(vec3(1,0,0),col,sd);\n\tsd = (f(p.x)-p.y)\/grad(p.x);\n    sd = clamp(0.0,1.0,s*(abs(sd)-0.03));\n    col = mix(vec3(0,1,0),col,sd);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wlySDy","date":"1583483570","viewed":52,"name":"Float Limit Exceed +=\u2212=","username":"harry7557558","description":"On my machine (test on both CPU and GPU):\niTime < 30: procedural fBM effect\niTime > 30: wider and wider stripes\n","likes":2,"published":2,"flags":0,"usePreview":0,"tags":["bug","floatpoint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n    In C:\n    \n    \tfloat sum = 0.0f;\n    \tfor (int i = 1; i <= 10000000; i++) sum += 1.0f \/ (float)i;\n    \tfor (int i = 1; i <= 10000000; i++) sum -= 1.0f \/ (float)i;\n    \tprintf(\"%.16f\\n\", sum);\n    \n    Output:\n    \n    \t-1.2963572740554810\n*\/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float x = 0.0;\n    int m = int(fragCoord.x+60.0*iTime);\n    for (int i=1; i<=m; i++) x+=1.0\/float(i);\n    for (int i=1; i<=m; i++) x-=1.0\/float(i);\n    if (x==0.0) fragColor = vec4(0,0,1,1);\n    else x*=1e5, fragColor = x>0.0?vec4(x,0,x,1):vec4(0,x,x,1);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3tK3z3","date":"1579497743","viewed":117,"name":"Float Limit Exceed 95 chars","username":"harry7557558","description":"mirroring an oblique ellipse x\u00b2 + y\u00b2 - |x|\u00b7y = r\u00b2\nresult may be different on different hardware","likes":3,"published":2,"flags":0,"usePreview":0,"tags":["heart","pink","short","cyan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mainImage(c,p) \\\n\tc.xy = 4.*p-iResolution.xy; \\\n\tc = sin(dot(c,c)-abs(c.x)*c.y+iTime+vec4(3,2,0,0))","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tt2SDt","date":"1567533859","viewed":105,"name":"Forest-Fractal++","username":"harry7557558","description":"a zoom in to fractal defined by iteration z\u21a6|Re(z\u00b2)|-|Im(z\u00b2)|i+c","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* Also check:\n * Mandelbrot Fractal: https:\/\/www.shadertoy.com\/view\/wl2SWt\n * Burning-Ship Fractal: https:\/\/www.shadertoy.com\/view\/wljSDt\n * Forest Fractal: https:\/\/www.shadertoy.com\/view\/tt2SDt\n * Crown Fractal: https:\/\/www.shadertoy.com\/view\/tl2SDt\n *\/\n\n#define AA 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/vec2 p0 = vec2(-1.9989191770689436,0.000002058504218357831); \/\/ I made a deep zoom in to this position with double-precision float and it looks very nice\n    vec2 p0 = vec2(-1.6837324337509336,1e-5);\n    vec2 p1 = vec2(-0.65,0.55);\n    float m1 = 6.0\/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0\/(exp(3.0-0.5*iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5\/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)\/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(abs(z.x*z.x-z.y*z.y),-abs(2.0*z.x*z.y))+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n\/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)\/20.0),6.0),\n                      pow(sin((m+1.0)\/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)\/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)\/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)\/20.0),6.0),\n                      pow(sin((n-2.0)\/20.0),4.0),\n                      0.8*pow(sin((n+2.0)\/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)\/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col\/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WdKXDt","date":"1575344149","viewed":299,"name":"Frozen Fractals","username":"harry7557558","description":"And one thought crystallizes like an icy blast...\n\nFake snowflakes generated by mirroring complex fractals. \n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","iteration","snowflake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define AA 3\n\nint sn; \t\/\/ index of snowflake\n\nvec3 fractal(vec2 p){\n    p.x=-p.x-(cos(iTime)+5.0)\/3.0;\n    vec3 col=vec3(0.0);\n    vec2 z = vec2(0.0);\n    int i;\n    for (i=0;i<64;i++){\n\n        \/\/ different iteration functions generate different snowflakes\n        if (sn==0) z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+p;\n        else if (sn==3) z=vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+p;\n        else if (sn==1) z=vec2(abs(z.x*z.x-z.y*z.y),2.0*z.x*z.y)+p;\n        else if (sn==4) z=vec2(abs(z.x*z.x-z.y*z.y),-2.0*z.x*z.y)+p;\n        else if (sn==2) z=vec2(z.x*z.x-z.y*z.y,-abs(2.0*z.x*z.y))+p;\n\n        \/\/ color function for Mandelbrot (https:\/\/www.shadertoy.com\/view\/wl2SWt)\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(.5*log2(h))+4.;\n            float m = exp(-n*n\/20000.);\n            n = mix(4.*pow((log(n+1.)+1.),2.),n,m);\n            m = 5.*sin(.1*(n-6.))+n;\n            col += vec3(\n                pow(sin((m-8.)\/20.),6.),\n                pow(sin((m+1.)\/20.),4.),\n                (.8*pow(sin((m+2.)\/20.),2.)+.2)*(1.-pow(abs(sin((m-14.)\/20.)),12.))\n            );\n            break;\n        }\n    }\n    if (i==64) col=vec3(1.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.3*length(iResolution.xy);\n    vec3 col=vec3(0.0);\n    sn = int(iTime\/(2.*PI))%5;\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n    \t\tvec2 p = (fragCoord+vec2(u,v)\/float(AA)-0.5*iResolution.xy)\/s;\n            \/\/ rotation and mirroring\n    \t\tfloat m = length(p);\n    \t\tfloat a = abs(mod(atan(p.y,p.x)+iTime,PI\/3.0)-PI\/6.0);\n    \t\tcol += fractal(vec2(m*cos(a),m*sin(a)));\n        }\n    }\n    fragColor = vec4(col\/float(AA*AA),1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Nt2yW3","date":"1656617803","viewed":270,"name":"Functional Conch","username":"harry7557558","description":"My second attempt to create a conch after the [url=https:\/\/www.shadertoy.com\/view\/sdVGWh]nautilus shell[\/url] shader.\nThe conch was modeled in a functional graphing calculator. Place it on a more decent beach.","likes":29,"published":3,"flags":0,"usePreview":0,"tags":["water","spiral","function","logarithmic","sand","beach","seashell","moana","conch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Common: Modeling\n\/\/ Image: Rendering\n\n\/\/ The conch was modeled in a \"graphing calculator\" I made.\n\/\/ (see Common for link and details)\n\n\/\/ I was inspired by:\n\/\/  - my childhood fascination with the spiral shells of mollusks\n\/\/  - my fascination with the sea that lasts to this day\n\/\/  - a certain Disney movie\n\/\/  - some thoughts when leaving high school for university\n\n\/\/ Mouse-able.\n\n\/\/ Also check my \"Nautilus Shell\" shader (modeled in GLSL):\n\/\/ https:\/\/www.shadertoy.com\/view\/sdVGWh\n\n\n\/* CONCH INTERSECTION *\/\n\n\/\/ Intersect with the bounding box, used to speed up rendering\nbool boxIntersection(float offset, vec3 ro, vec3 rd, out float tn, out float tf) {\n    ro -= vec3(-0.1,0.1,0.6); \/\/ translation\n    vec3 inv_rd = 1.0 \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*(vec3(0.9,1.3,0.7)+offset); \/\/ offset is positive for shadow\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\nbool intersectConch(vec3 ro, vec3 rd, inout float t, float tf, float eps) {\n    \/\/ intersect bounding box\n    float t0, t1;\n    if (!boxIntersection(0.0, ro, rd, t0, t1)) return false;\n    t1 = min(t1, tf);\n    if (t1 < t0) return false;\n    t = t0;\n    \/\/ raymarching, eps is the minimum step\n    float v0=0.0, v, dt;\n    for (int i=ZERO; i<80; i++) {\n        v = mapShell(ro+rd*t);\n        if (v*v0 < 0.0) { \/\/ intersect\n            t -= dt * v\/(v-v0); \/\/ linear interpolation\n            return true;\n        }\n        dt = max(abs(v), eps);\n        t += dt;\n        if (t > t1) return false; \/\/ too far\n        v0 = v;\n    }\n    return true;\n    \/\/return false;\n}\n\n\/\/ Soft shadow\nfloat calcShadow(vec3 ro, vec3 rd) {\n    \/\/ check bounding box\n    float t0, t1;\n    if (!boxIntersection(0.2, ro, rd, t0, t1)) return 1.0;\n    \/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n    float sh = 1.;\n    float t = max(t0, 0.01) + 0.02*hash22(rd.xy).x;\n    for (int i=ZERO; i<40; i++) {\n        float h = 0.8*mapShell(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 20.0*h\/t));\n        t += clamp(h, 0.02, 0.5);\n        if (h<0.) return 0.0;\n        if (t>t1) break;\n    }\n    return max(sh, 0.);\n}\n\n\n\/* BEACH INTERSECTION *\/\n\nbool intersectBeach(vec3 ro, vec3 rd, out float t, float tf) {\n    \/\/t = -ro.z\/rd.z; if (t < 0.0) return false;\n    t = 0.01;\n    float v0 = 0.0, v, dt;\n    for (int i = int(ZERO); i < 50; i++) {  \/\/ raymarching\n        if (t>tf) return false;\n        v = mapGround(ro+rd*t).x;\n        if (v*v0 < 0.0) break;\n        dt = i==int(ZERO)?v:dt*v\/abs(v-v0); \/\/ divide by line derivative\n        dt = sign(dt)*clamp(abs(dt), 0.02, 1.0);\n        t += dt;\n        v0 = v;\n    }\n    t -= dt * clamp(v\/(v-v0), 0., 1.); \/\/ linear interpolation\n    return true;\n}\n\n\n\/* SKY *\/\n\nvec3 sundir = normalize(vec3(0.3,0.3,1.0));\n\nvec3 getSkyCol(vec3 rd) {\n    rd = normalize(vec3(rd.xy,max(rd.z,0.))); \/\/ prevent below horizon\n    vec3 sky = mix(vec3(0.8,0.9,1.0), vec3(0.3,0.6,0.9), rd.z); \/\/ higher => darker\n    vec3 sun = 1.5*vec3(0.95,0.9,0.5)*pow(max(dot(rd,sundir),0.), 8.); \/\/ warm color\n    return sky + sun;\n}\n\n\n\/* MAIN *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \/\/ pass uniforms to Common\n    ZERO = min(iFrame, 0);\n    uTime = iTime;\n\n    \/\/ set camera\n    float rx = iMouse.z!=0.0 ? 1.65*(iMouse.y\/iResolution.y)-0.05 : 0.12; \/\/ azimuthal angle\n    float rz = iMouse.z!=0.0 ? -iMouse.x\/iResolution.x*4.0*3.14 : 0.5; \/\/ polar angle\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  \/\/ far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  \/\/ left to right\n    vec3 v = cross(w,u);  \/\/ down to up\n    vec3 ro = vec3(0,0,0.5)+6.0*w-0.5*u+0.2*v;  \/\/ ray origin\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  \/\/ ray direction\n\n    \/\/ ray intersection\n    float t, t1=40.;\n    int intersect_id = -1;\n    if (intersectBeach(ro, rd, t, t1)) intersect_id=0, t1=t;\n    if (intersectConch(ro, rd, t, t1, 0.02)) intersect_id=1, t1=t;\n    t = t1;\n    \n    \/\/ shading\n    vec3 p = ro+rd*t;\n    vec3 col; \/\/ final color\n    float shadow = calcShadow(p, sundir);\n    if (intersect_id == -1) { \/\/ background\n        col = vec3(1.0); \/\/ this will be blended to sky color later\n    }\n    if (intersect_id == 0) { \/\/ beach\/sea\n        vec3 n = normalize(gradGround(p));\n        \/\/n *= -sign(dot(n,rd)); \/\/ faceforward\n        vec3 albedo = mapGround(p).yzw; \/\/ raw color\n        vec3 amb = 0.2*albedo; \/\/ ambient\n        vec3 dif = 0.6*(0.3+0.7*shadow) * max(dot(n,sundir),0.0) * albedo; \/\/ diffuse\n        vec3 spc = intersectConch(p,reflect(rd,n),t1,2.,0.05) \/\/ reflection\n            ? vec3(0.05,0.045,0.04) \/\/ occluded, conch color\n            : vec3(0.2-0.1*tanh(0.5*p.y)) * getSkyCol(reflect(rd,n)); \/\/ sky color, wetter reflects more\n        col = amb+dif+spc;\n    }\n    if (intersect_id == 1) { \/\/ shell\n        vec3 n0 = gradShell(p); \/\/ raw gradient\n        \/\/n0 *= -sign(dot(n0,rd)); \/\/ faceforward\n        vec3 n = normalize(n0); \/\/ normal\n        vec3 albedo = albedoShell(p, n0); \/\/ color based on gradient\n        vec3 amb = (0.4-0.1*dot(rd,n))*albedo; \/\/ ambient light\n        vec3 dif = albedo*(\n            vec3(0.45,0.4,0.35)*max(dot(n,sundir),0.0)+ \/\/ sunlight, warm\n            vec3(0.2,0.3,0.4)*max(n.z,0.)); \/\/ skylight, blueish\n        col = pow(amb+dif, vec3(0.8));\n    }\n    col = mix(getSkyCol(rd), col, exp(-0.04*max(t-5.,0.))); \/\/ sky blending\/fog\n    col += 0.5*vec3(0.8,0.5,0.6)*pow(max(dot(rd,sundir),0.),1.5);  \/\/ sun haze\n    col = pow(0.95*col, vec3(1.25)); \/\/ adjustment\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Common: Modeling\n\/\/ Image: Rendering\n\n\n\/\/ Constants\/Uniforms\nint ZERO;\nfloat uTime;\n\n\n\/* SHELL *\/\n\n\/\/ Functional shell manually exported from this \"graphing calculator\":\n\/\/ https:\/\/harry7557558.github.io\/tools\/raymarching-implicit\/index.html\n#define _uv float u, float v\n#define _xyz float x, float y, float z\n#define PI 3.1415926\nconst float a_o = 0.16*PI; \/\/ half of opening angle\nconst float b = 0.6; \/\/ r=e^bt\nfloat s_min(float a, float b, float k) { return -1.\/k*log(exp(-k*a)+exp(-k*b)); } \/\/ smoothed minimum\n\n\/\/ Cross section\nfloat C_m(_uv) { return 1.-(1.-0.01*exp(sin(12.*PI*(u+2.*v))))*exp(-5.*v*5.*v); } \/\/ mid rod\nfloat C_s(_uv) { \/\/ basic cross section\n    float _x = u-exp(-16.*v);\n    float _y = v*(1.-0.2*exp(-4.*sqrt(u*u+.1*.1)))-0.5+0.5*exp(-v)*sin(4.*u)+.2*cos(2.*u)*exp(-v);\n    return (sqrt(_x*_x+_y*_y)-0.55)*tanh(5.*sqrt(2.*u*u+(v-1.2)*(v-1.2)))+.01*sin(40.*u)*sin(40.*v)*exp(-(u*u+v*v));\n}\nfloat C_0(_uv) { return abs(C_s(u,v))*C_m(u,v); } \/\/ single layer\nfloat n_1(_uv) { return log(sqrt(u*u+v*v))\/b+2.; } \/\/ index of layer\nfloat a_1(_uv) { return atan(v,u)\/a_o; } \/\/ opening angle, 0-1\nfloat d_1(_uv, float s_d) { \/\/ map to layer\n    float n = n_1(u,v);\n    return 0.5*sqrt(u*u+v*v)*C_0(n>0.?n-s_d:fract(n)-s_d,a_1(u,v));\n}\nfloat C(_uv) { return min(d_1(u,v,0.5),d_1(u,v,1.5)); } \/\/ result cross section\n\n\/\/ Spiral\nfloat l_p(float x, float y) { return exp(b*atan(y,x)\/(2.*PI)); } \/\/ a multiplying factor\nfloat U(_xyz) { return exp(log(-z)+b*atan(y,x)\/(2.*PI)); } \/\/ xyz to cross section u\nfloat V(_xyz) { return sqrt(x*x+y*y)*l_p(x,y); } \/\/ xyz to cross section v\nfloat S_s(_xyz) { return C(U(x,y,z),V(x,y,z))\/l_p(x,y); } \/\/ body\nfloat S_o(_xyz) { return sqrt(pow(C(exp(log(-z)-b\/2.),-x*exp(-b\/2.))*exp(b\/2.),2.)+y*y); } \/\/ opening\nfloat S_t(_xyz) { return d_1(-z,sqrt(x*x+y*y),0.5); } \/\/ tip\nfloat S_a(_xyz) { return -z>0.?min(S_s(x,y,z),S_o(x,y,z)):S_t(x,y,z); } \/\/ body+tip\nfloat S_0(_xyz) { return S_a(x,y,z)-0.01-0.01*pow(x*x+y*y+z*z,0.4)\n    -0.02*sqrt(x*x+y*y)*exp(cos(8.*atan(y,x)))\n    -0.007*(0.5-0.5*tanh(10.*(z+1.+8.*sqrt(3.*x*x+y*y)))); } \/\/ subtract thickness\nfloat S_r(_xyz) { return -s_min(-S_0(x,y,z),z+1.7,10.); } \/\/ clip bottom\nfloat r_a(_xyz) { return -0.1*sin(3.*z)*tanh(2.*(x*x+y*y-z-1.5)); } \/\/ thicken the bottom \"rod\"\nfloat S(_xyz) { return S_r(x-r_a(x,y,z)*y,y+r_a(x,y,z)*x,z-0.8); }\n\n\n\/\/ Rotation matrices\nmat3 rotx(float a) { return mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a)); }\nmat3 rotz(float a) { return mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1); }\n\n\/\/ Returns the SDF of the shell\nfloat mapShell(vec3 p) {\n    \/\/ position and orientation\n    vec3 q = rotz(0.125*PI)*rotx(0.38*PI)*(0.7*p-vec3(0,0,0.26));\n    \/\/ a relatively cheap bounding box to speed up rendering and reduce discontinuities\n    float bound = length(vec3(vec2(1.2,1.4)*exp(q.z*q.z),1.)*q)\/exp(q.z*q.z)-1.0;\n    bound = max(bound, length(vec3(1.2,1.4,1)*(q+vec3(0,0.1,0)))-1.);\n    float boundw = 0.2;  \/\/ padding of the bounding box for continuous transition\n    if (bound > 0.0) return bound+boundw;  \/\/ outside bound\n    else {\n        float v = S(q.x,q.y,q.z); \/\/ sample raw SDF\n        \/\/ do some hacking to reduce the high gradient and discontinuities\n        \/\/ Adjusted with the help of this SDF visualizer:\n        \/\/ - https:\/\/www.shadertoy.com\/view\/ssKGWR\n        \/\/ - https:\/\/github.com\/harry7557558\/Shadertoy\/blob\/master\/spiral\/functional_conch.glsl\n        float k = 1.0-0.9\/length(vec3(4.*q.xy,1.0*abs(q.z+0.7)+1.));  \/\/ reduce gradient at the bottom\n        k = 0.7*mix(k, 1.0, clamp(10.*max(-q.x,q.z-.7*q.x+0.5), 0., 1.));  \/\/ reduce a discontinuity\n        v = k*v\/0.7;  \/\/ dividing by 0.7 is due to scaling\n        \/\/ continuous transition between bound and SDF\n        v = mix(v, bound+boundw, smoothstep(0.,1.,(bound+boundw)\/boundw));\n        \/\/return v; return min(v,1.0);  \/\/ this two are broken in Firefox for me\n        return min(v,0.1);\n    }\n}\n\n\/\/ Numerical gradient of the shell SDF\nvec3 gradShell(vec3 p) {\n    \/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\/\n    const float h = 0.001;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapShell(p+e*h);\n    }\n    return n*(.25\/h);\n}\n\n\/\/ Color calculated from position and gradient\n\/\/ Interpolating two colors based on gradient magnitude\nvec3 albedoShell(vec3 p, vec3 g) {\n    \/\/ gradient magnitude => interpolation parameter\n    float t = 0.5-0.5*cos(2.0*log(0.6*length(g)));\n    t += 0.05*sin(40.*p.x)*sin(40.*p.y)*sin(20.*p.z); \/\/ some noise\n    vec3 col = mix(vec3(0.9,0.9,0.85), vec3(0.75,0.55,0.3), t); \/\/ interpolation\n    col = min(1.2*col, vec3(1.0)); \/\/ adjustments\n    return col;\n}\n\n\n\/* NOISE *\/\n\n\/\/ Hash function by David Hoskins, https:\/\/www.shadertoy.com\/view\/4djSRW, MIT license\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\/\/ Gradient noise\nfloat GradientNoise2D(vec2 xy) {\n    float i0 = floor(xy.x), i1 = i0 + 1.0;\n    float j0 = floor(xy.y), j1 = j0 + 1.0;\n    float v00 = dot(2.0 * hash22(vec2(i0, j0)) - 1.0, xy - vec2(i0, j0));\n    float v01 = dot(2.0 * hash22(vec2(i0, j1)) - 1.0, xy - vec2(i0, j1));\n    float v10 = dot(2.0 * hash22(vec2(i1, j0)) - 1.0, xy - vec2(i1, j0));\n    float v11 = dot(2.0 * hash22(vec2(i1, j1)) - 1.0, xy - vec2(i1, j1));\n    float xf = xy.x - i0; xf = xf * xf * xf * (10.0 + xf * (-15.0 + xf * 6.0));\n    float yf = xy.y - j0; yf = yf * yf * yf * (10.0 + yf * (-15.0 + yf * 6.0));\n    return v00 + (v10 - v00)*xf + (v01 - v00)*yf + (v00 + v11 - v01 - v10) * xf*yf;\n}\n\n\n\/* SEA + BEACH *\/\nvec4 smin(vec4 a, vec4 b, float k) {\n    \/\/ smoothed blending with color\n    float h = clamp(0.5 + 0.5 * (b.x - a.x) \/ k, 0., 1.);\n    float d = mix(b.x, a.x, h) - k * h * (1.0 - h);\n    return vec4(d, mix(b.yzw, a.yzw, h));\n}\nvec4 mapGround(vec3 p) {\n    \/\/ returns drgb\n    float time = 0.25*PI*uTime; \/\/ animation time\n    float beach = 0.4*tanh(0.2*p.y)-0.2*GradientNoise2D(0.5*p.xy); \/\/ height\n    beach *= smoothstep(0.,1., 0.5*(1.+exp(0.3*p.x))\n        * (length(vec2(1.4,1.0)*p.xy-vec2(-0.2,-0.2))-0.5)); \/\/ shell \"pit\"\n    float sea = -0.2+0.1*exp(sin(time)); \/\/ animated sea level\n    if (abs(p.z-sea)<0.1)  \/\/ sea wave\n        sea += 0.005*tanh(2.*max(sea-beach,0.)) * \/\/ fade when close to beach\n            sin(10.*(p.x-uTime-sin(p.y)))*sin(10.*(p.y+uTime-sin(p.x)));\n    if (abs(p.z-beach)<0.1)  \/\/ sand grains\n        beach += 0.005*tanh(5.*max(beach-sea,0.)) \/\/ fade when close to sea\n            * GradientNoise2D(50.0*p.xy);\n    vec3 seacol = mix(vec3(0.65,0.85,0.8),vec3(0.2,0.55,0.45),\n        smoothstep(0.,1.,-0.1*p.y)); \/\/ sea color, deeper when further\n    seacol = mix(vec3(1.), seacol, clamp(4.*(sea-beach),0.,1.)); \/\/ white foam\n    seacol = mix(vec3(1.1), seacol, clamp(20.*(sea-beach),0.,1.)); \/\/ whiter foam\n    vec3 beachcol = mix(vec3(0.7,0.7,0.6),vec3(0.9,0.85,0.8),\n        clamp(5.*(beach-sea),0.,1.)); \/\/ beach color, darker when wetter\n    vec4 ground = smin(vec4(-sea,seacol), vec4(-beach,beachcol), \/\/ water-sand transition\n        0.01-0.005*cos(time)); \/\/ sharper when rising, smoother when falling\n    return vec4(p.z+ground.x, min(ground.yzw,1.));\n}\nvec3 gradGround(vec3 p) {\n    \/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\/\n    const float h = 0.01;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapGround(p+e*h).x;\n    }\n    return n*(.25\/h);\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"sljSzD","date":"1627249345","viewed":99,"name":"Gamma (complex function grapher)","username":"harry7557558","description":"Manipulated from [url]https:\/\/harry7557558.github.io\/tools\/complex_webgl.html[\/url], but for 3D.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["domain","complex","gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ZERO min(int(iTime),0)\n\nconst vec3 CTR = vec3(0.0, 0.0, 1.0);  \/\/ center of viewport\nconst vec3 RAD = vec3(3.0, 2.0, 1.5);  \/\/ bounding box radius\n\n\n\/\/ function to graph\nvec2 fun(vec2 z) {\n    \/\/ some interesting functions you may try\n    \/\/return CSC(2.0*z);\n    \/\/return TAN(2.0*z);\n    \/\/return SIN(INV(MUL(z,z)));\n    \/\/return 0.5*SQR(LOG(POW(z,vec2(6,0))));\n    \n    \/\/ gamma function product formula, zoom to fit\n    z *= 1.5;\n    vec2 c = INV(z);\n    for (float n=float(ZERO)+1.; n<10.; n++) {\n        c = MUL(c, DIV(POW(vec2(1.+1.\/n,0),z), vec2(1,0)+z\/n) );\n    }\n    return c\/2.0;\n}\n\n\n\/\/ sdf and gradient\nvec3 sdf_grad(vec3 p) {\n    const float eps = 0.01;\n    float dh_x = length(fun(p.xy+vec2(eps,0)))-length(fun(p.xy-vec2(eps,0)));\n    float dh_y = length(fun(p.xy+vec2(0,eps)))-length(fun(p.xy-vec2(0,eps)));\n    return vec3(vec2(dh_x,dh_y)\/(2.*eps), 1.0);\n}\nfloat sdf(vec3 p) {\n    float h = length(fun(p.xy));\n    vec3 n = sdf_grad(p);\n    return (p.z-h)\/length(n);\n}\n\n\/\/ raymarching shape\nfloat raymarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin + 1e-2;\n    for (int i=ZERO; i<100; i++) {\n        float dt = 0.2*sdf(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) return t;\n        if (t > tmax || t < tmin) return -1.0;\n    }\n    \/\/return -1.0;\n    return t;\n}\n\n\n\/\/ complex domain coloring\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1.\/6.) return p + (q - p) * 6. * t;\n    if (t < 1.\/2.) return q;\n    if (t < 2.\/3.) return p + (q - p) * (2.\/3. - t) * 6.;\n    return p;\n}\nvec3 hslToRgb(float h, float s, float l) {\n    if (s == 0.) return vec3(l);\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1.\/3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1.\/3.)\n    );\n}\nvec3 complexColor(vec2 z) {\n    float h = Arg(z) * 0.159;\n    float s = 1.0;\n    \/\/ s *= 0.5 + 0.5 * sqrt(abs(sin(3.141592653569793 * Mag(z))));  \/\/ linear contour\n    \/\/ s *= 0.5 + 0.5 * sqrt(abs(sin(1.364 * logMag(z))));   \/\/ logarithmic contour\n    float l = 1.0 - pow(1.0 - 0.5, log(log(Mag(z) + 1.0) + 1.05));\n    return hslToRgb(h, s, l);\n}\n\n\/\/ box intersection function from iq\nvec2 boxIntersection(vec3 ro, vec3 rd) {\n    vec3 inv_rd = 1.0\/rd;\n    vec3 n = inv_rd*(ro-CTR), k = abs(inv_rd)*RAD;\n    vec3 t1 = -n - k, t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if(tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n\n\/\/ main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n\n    \/\/ raymarching surface\n    vec2 tnf = boxIntersection(ro, rd);\n    float tmin = tnf.x, tmax = tnf.y;\n    if (tmax < 0.0) return vec3(0.0);\n    float t = raymarch(ro, rd, tmin, tmax);\n    if (t < tmin) return vec3(0.1);\n    \n    \/\/ shading\n    vec3 p = ro + rd*t;\n    vec3 light = normalize(vec3(10.,10.,20.) - p);\n    vec3 n = normalize(sdf_grad(p));\n    vec3 col = 1.5*sqrt(complexColor(fun(p.xy)));\n    vec3 bkg = 0.8 * col;\n    vec3 dif = max(dot(n, light), 0.0) * col;\n    vec3 spc = pow(max(dot(rd-2.0*dot(rd,n)*n, light),0.0), 10.0) * vec3(1.0);\n    return 0.5*bkg+0.5*dif+0.2*spc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0.?1.57*(iMouse.y\/iResolution.y):0.3;\n    float rz = iMouse.z>0.?-iMouse.x\/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = CTR + 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution));\n\n    vec3 col = render(ro, normalize(rd));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ elementary complex functions for GLSL\n\/\/ from https:\/\/harry7557558.github.io\/tools\/complex_webgl.html\n\nfloat Mag(vec2 a) { return length(a); }\nfloat Arg(vec2 a) { return atan(a.y, a.x); }\nfloat logMag(vec2 a) {\n    \/\/return 0.5*log(dot(a,a));\n    return log(length(a));\n}\nvec2 REL(vec2 e) { return vec2(e.x, 0); }\nvec2 IMA(vec2 e) { return vec2(e.y, 0); }\nvec2 CNJ(vec2 e) { return vec2(e.x, -e.y); }\nvec2 ADD(vec2 a, vec2 b) { return a + b; }\nvec2 SUB(vec2 a, vec2 b) { return a - b; }\nvec2 MUL(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 DIV(vec2 a, vec2 b) { return (1.0\/dot(b,b)) * vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y); }\nvec2 POW(vec2 e, vec2 t) {\n    float a = Arg(e), r = logMag(e), c = exp(t.x*r-t.y*a), s = t.x*a+t.y*r;\n    return c * vec2(cos(s), sin(s));\n}\nvec2 CBR(vec2 e) { return POW(e, vec2(1.0\/3.0,0)); }\nvec2 EXP(vec2 e) { return exp(e.x) * vec2(cos(e.y),sin(e.y)); }\nvec2 LOG(vec2 e) { return vec2(logMag(e), Arg(e)); }\nvec2 SQR(vec2 e) {\n    float m = Mag(e);\n    return e.y>0. ? vec2(sqrt(0.5*(m+e.x)), sqrt(0.5*(m-e.x))) :\n        vec2(sqrt(0.5*(m+e.x)), -sqrt(0.5*(m-e.x)));\n}\nvec2 INV(vec2 e) { return (1.\/dot(e,e)) * vec2(e.x, -e.y); }\n\nvec2 SIN(vec2 e) { return vec2(sin(e.x)*cosh(e.y), cos(e.x)*sinh(e.y)); }\nvec2 COS(vec2 e) { return vec2(cos(e.x)*cosh(e.y), -sin(e.x)*sinh(e.y)); }\nvec2 TAN(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)+cosh(b);\n    return (1.\/d) * vec2(sin(a), sinh(b));\n}\nvec2 COT(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)-cosh(b);\n    return (1.\/d) * vec2(-sin(a), sinh(b));\n}\nvec2 SEC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) + 0.5*cos(2.*a);\n    return (1.\/d) * vec2(cos(a)*cosh(b), sin(a)*sinh(b));\n}\nvec2 CSC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) - 0.5*cos(2.*a);\n    return (1.\/d) * vec2(sin(a)*cosh(b), -cos(a)*sinh(b));\n}\nvec2 SNH(vec2 e) { return vec2(sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y)); }\nvec2 CSH(vec2 e) { return vec2(cosh(e.x)*cos(e.y), sinh(e.x)*sin(e.y)); }\nvec2 TNH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)+cos(b);\n    return (1.\/d) * vec2(sinh(a), sin(b));\n}\nvec2 CTH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)-cos(b);\n    return (1.\/d) * vec2(sinh(a), -sin(b));\n}\nvec2 CCH(vec2 e) {\n    float d = cos(2.*e.y) - cosh(2.*e.x);\n    return (2.\/d) * vec2(-sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y));\n}\nvec2 SCH(vec2 e) {\n    float d = cos(2.*e.y) + cosh(2.*e.x);\n    return (2.\/d) * vec2(cosh(e.x)*cos(e.y), -sinh(e.x)*sin(e.y));\n}\n\nvec2 ASN(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(t2.y, -t2.x);\n}\nvec2 ACS(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(1.570796327-t2.y, t2.x);\n}\nvec2 ATN(vec2 e) {\n    float a = e.x, b = e.y, d = a*a + (1.-b)*(1.-b);\n    vec2 t1 = LOG(vec2((1.-b*b-a*a)\/d, -2.*a\/d));\n    return vec2(-0.5*t1.y, 0.5*t1.x);\n}\nvec2 ACT(vec2 e) { return ATN(INV(e)); }\nvec2 ASC(vec2 e) { return ACS(INV(e)); }\nvec2 ACC(vec2 e) { return ASN(INV(e)); }\nvec2 ASH(vec2 e) { vec2 r = ASN(vec2(e.y,-e.x)); return vec2(-r.y,r.x); }\nvec2 ACH(vec2 e) { vec2 r = ACS(e); return r.y<=0.?vec2(-r.y,r.x):vec2(r.y,-r.x); }\nvec2 ATH(vec2 e) {\n    float a = e.x, b = e.y;\n    float oneMinus = 1.-a, onePlus = 1.+a, d = oneMinus*oneMinus + b*b;\n    vec2 x = (1.\/d) * vec2(onePlus*oneMinus-b*b, b*oneMinus+b*onePlus);\n    return vec2(0.5*logMag(x), 0.5*Arg(x));\n}\nvec2 AKH(vec2 e) { return ATH(INV(e)); }\nvec2 AXH(vec2 e) { return ASH(INV(e)); }\nvec2 AGH(vec2 e) { return ACH(INV(e)); }\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"tlc3Dj","date":"1577581479","viewed":198,"name":"Heat Conduction","username":"harry7557558","description":"Solving heat equation numerically","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["heatequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 col, in vec2 p ){\n    float t=texelFetch(iChannel0,ivec2(p),0).w;\n    float r=(((-11.7227*t+18.8479)*t-7.26786)*t+0.710379)*t+0.174578;\n    float g=(-3.11386*t+3.09609)*t+0.184932;\n    float b=(((-11.9359*t+28.3134)*t-21.022)*t+4.06718)*t+0.753008;\n    col = vec4(r,g,b,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define bf iChannel0\n\nfloat D(ivec2 p){\n    float c=texelFetch(bf,p,0).w;\n    float l=texelFetch(bf,p-ivec2(1,0),0).w;\n    float r=texelFetch(bf,p+ivec2(1,0),0).w;\n    float u=texelFetch(bf,p+ivec2(0,1),0).w;\n    float d=texelFetch(bf,p-ivec2(0,1),0).w;\n    return l+r+u+d-4.*c;\n}\n\nvoid mainImage( out vec4 col, in vec2 p ){\n    float k;\n    if (iFrame==0){\n    \tvec2 q=10.*(p-0.5*iResolution.xy)\/length(iResolution.xy);\n        float x=q.x+0.5,y=q.y+0.7;\n        k = x*x*x*(x-2.)+y*y*y*(y-2.)+x<0.?1.:0.;\n    }\n    else{\n        k=texelFetch(bf,ivec2(p),0).w;\n    \tif (iMouse.z>0.&&length(p-iMouse.xy)<=10.) k+=.01;\n    \tk+=0.2*D(ivec2(p));\n    }\n    col = vec4(vec3(0.0),k);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tltSWr","date":"1580886017","viewed":360,"name":"I heart Fourier","username":"harry7557558","description":"As a beginner to Fourier series, inspired by a picture on my religion teacher's slide. ","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["heart","fourier","love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 path[18];\nvec2 a[10], b[10];  \/\/ 10 = int(18 \/ 2) + 1\nvoid init() {\n\t\/\/ manual point set\n\tpath[0] = vec2(1.0137, 0.3967);\n\tpath[1] = vec2(0.5626, 0.5417);\n\tpath[2] = vec2(0.3414, -0.0639);\n\tpath[3] = vec2(0.1158, 0.6121);\n\tpath[4] = vec2(-0.7459, 0.7070);\n\tpath[5] = vec2(-0.8443, 0.1465);\n\tpath[6] = vec2(-0.3618, 0.1444);\n\tpath[7] = vec2(-0.1585, 0.4285);\n\tpath[8] = vec2(-0.3173, 0.3743);\n\tpath[9] = vec2(-0.4706, -0.2456);\n\tpath[10] = vec2(-0.7936, -0.3968);\n\tpath[11] = vec2(-0.5655, -0.1589);\n\tpath[12] = vec2(0.2119, -0.6991);\n\tpath[13] = vec2(0.2968, -0.9548);\n\tpath[14] = vec2(0.3969, -0.4136);\n\tpath[15] = vec2(0.7119, 0.0779);\n\tpath[16] = vec2(0.6283, 0.2814);\n\tpath[17] = vec2(0.7057, -0.0209);\n\n\t\/\/ calculate Fourier coefficients, b[0] is always zero\n\tfloat t, dt;\n\tfor (int k = 0; k < 10; k++) {\n\t\ta[k] = vec2(0.), b[k] = vec2(0.);\n\t\tt = 0.0, dt = 6.283185 * float(k) \/ 18.;\n\t\tfor (int i = 0; i < 18; i++, t += dt)\n\t\t\ta[k] += path[i] * cos(t), b[k] += path[i] * sin(t);\n\t\ta[k] = a[k] * (2.0 \/ 18.), b[k] = b[k] * (2.0 \/ 18.);\n\t}\n\ta[0] = a[0] * 0.5;\n}\n\nvec2 eval(float t) {\n\tvec2 r = a[0];\n    float c0 = cos(t), s0 = sin(t), c = c0, s = s0, c1;\n    for (int k = 1; k < 10; k++) {\n        r += a[k] * c + b[k] * s;\n        c1 = c, c = c * c0 - s * s0, s = c1 * s0 + s * c0;\n    }\n\treturn r;\n}\n\n\n\/\/ an improvement of iq's https:\/\/www.shadertoy.com\/view\/Xlf3zl\nfloat sdSqSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba * clamp(dot(pa, ba) \/ dot(ba, ba), 0.0, 1.0);\n\treturn dot(q, q);\n}\nfloat sd(vec2 p) {\n\tfloat o = sin(0.5*iTime); o = .04 + .005*o*o;  \/\/ path offset\n\tfloat o2 = (o + .02)*(o + .02);\n\tfloat t_max = 6.3*min(1.5*fract(0.15*iTime), 1.0);\n\tvec2 a = eval(0.0), b, c;\n\tfloat dt = 0.05, t = dt;\n\tfloat d = 1e8, dd;\n\twhile (t < t_max) {\n\t\tb = eval(t);\n\t\tdd = sdSqSegment(p, a, b);\n\t\tif (dd < o2) {  \/\/ more accurate and doesn't reduce much speed\n\t\t\tc = eval(t - 0.5*dt);\n\t\t\tdd = min(sdSqSegment(p, a, c), sdSqSegment(p, c, b));\n\t\t}\n\t\td = min(d, dd);\n\t\tdt = clamp(0.026*length(a - p) \/ length(a - b), 0.02, 0.1);\n\t\tt += dt;\n\t\ta = b;\n\t}\n\td = min(d, sdSqSegment(p, a, eval(t_max))); \t\/\/ add this line to eliminate gaps\n\td = min(sqrt(d), abs(length(p) - 0.15));\n\treturn d - o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinit();\n\tvec2 p = 5.0 * (fragCoord - 0.5*iResolution.xy) \/ length(iResolution.xy);\n\tfloat d = sd(p - vec2(-.1, .08));\n\n    \/\/ modified from iq's sdf visualizing function\n\tvec3 col = d > 0. ? vec3(1.0, 0.3, 0.5) : vec3(0.3, 1.5, 2.7);\n\tcol *= 1.0 - 0.9*exp(-6.*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.*d - 3.0*iTime);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"slfXR7","date":"1625345952","viewed":116,"name":"IdentiEgg","username":"harry7557558","description":"Random dyed egg generator inspired by WordPress\/Gravatar identicon.\n","likes":14,"published":1,"flags":0,"usePreview":1,"tags":["color","random","egg","pysanky","pysanka"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Random dyed egg generator inspired by WordPress\/Gravatar identicon.\n\n\/\/ Common: random egg generation\n\/\/ Image: rendering\n\n\/\/ Interactive Javascript version:\n\/\/ https:\/\/harry7557558.github.io\/art\/dyed-egg\/index.html\n\n\/\/ =============================== end of description\n\n\n\/\/ MODELING\n\nvec3 uEggParameters = vec3(0.0499, 1.1173, -0.1602);\nmat3 uEggOrientation = mat3(1,0,0,0,0.0,1.0,0,-1.0,0.0);\nvec3 uEggTranslation = vec3(0,0,1);\n\nfloat eggEquationPolar(float t) {\n    float s = sin(t);\n    vec3 r = (s*s) * vec3(1.0, exp(-t), cos(t));\n    return 1.0 - dot(r, uEggParameters);\n}\n\nfloat eggSDF(vec3 p) {\n    p = uEggOrientation * (p - uEggTranslation);\n    float d = length(p.xy), z = p.z;\n    float a = atan(abs(d), z);\n    float r = length(vec2(d, z));\n    return r - eggEquationPolar(a);\n}\n\nvec3 getEggNormal(vec3 p) {\n    const float eps = 0.01;\n    return normalize(vec3(\n        eggSDF(p+vec3(eps,0,0))-eggSDF(p-vec3(eps,0,0)),\n        eggSDF(p+vec3(0,eps,0))-eggSDF(p-vec3(0,eps,0)),\n        eggSDF(p+vec3(0,0,eps))-eggSDF(p-vec3(0,0,eps))));\n}\n\n\nbool intersectSphere(vec3 ce, float r, in vec3 ro, in vec3 rd, out float t) {\n    vec3 p = ro-ce;\n    float b = dot(p,rd), c = dot(p,p)-r*r;\n    float delta = b*b-c; if (delta<=0.0) return false;\n    delta = sqrt(delta);\n    t = -b-delta;\n    return true;\n}\n\nbool raymarch(in vec3 ro, in vec3 rd, out float t) {\n    const float eps = 0.001;\n    if (!intersectSphere(uEggTranslation, 1.0+eps, ro, rd, t)) return false;\n    t = max(t, 0.0);\n    ro = ro + rd*t;\n    float t0 = t;\n    t = eps;\n    for (int i=0; i<64; i++) {\n        float dt = 0.9*eggSDF(ro+rd*t);\n        t += dt;\n        if (dt < eps) {\n            vec3 p = ro+rd*t;\n            t += t0;\n            return true;\n        }\n        if (dt>2.0) break;\n    }\n    return false;\n}\n\n\n#define ID_PLANE 0\n#define ID_EGG 1\n\nbool intersectScene(in vec3 ro, in vec3 rd, out float min_t, out vec3 min_n, out vec3 fcol, out int intersect_id) {\n    float t;\n    vec3 n;\n    min_t = 1e+6;\n    intersect_id = -1;\n\n    \/\/ intersect with the egg\n    if (raymarch(ro, rd, t)) {\n        min_t = t, min_n = getEggNormal(ro+rd*t);\n        vec3 p = uEggOrientation*(ro+rd*t-uEggTranslation);\n        fcol = eggTexture(p);\n        fcol *= vec3(0.99, 0.95, 0.81);\n        intersect_id = ID_EGG;\n    }\n\n    \/\/ intersect with the plane\n    t = -(ro.z+0.0)\/rd.z;\n    if (t > 0.0 && t < min_t) {\n        min_t = t, min_n = vec3(0, 0, 1);\n        fcol = vec3(1.0, 1.0, 0.9);\n        vec2 p = ro.xy+rd.xy*t;\n        if (mod(floor(p.x)+floor(p.y),2.0)==0.0) fcol*=0.9;\n        intersect_id = ID_PLANE;\n    }\n\n    if (dot(rd, min_n) > 0.0) min_n = -min_n;\n\n    return intersect_id != -1;\n}\n\n\n\/\/ RENDERING\n\nconst vec3 light = vec3(3, 3, 10);\n\n\nfloat calcSoftShadow(vec3 ro, float k) {\n    vec3 rd = light - ro;\n    float col = 1.0;\n    float t = 0.1;\n    float maxt = length(rd);\n    for (int i=0; i<8; i++){\n        float h = eggSDF(ro + rd*t);\n        col = min(col, smoothstep(0.0, 1.0, k*h\/t));\n        t += clamp(h, 0.01, 0.2);\n        if (h<0. || t>maxt) break;\n    }\n    return max(col, 0.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float t = 0.12;\n    vec3 q = p+n*t;\n    float sd = min(eggSDF(q), q.z);\n    float occ = (t - sd)*2.0;\n    return smoothstep(0.0, 1.0, 1.0-occ);\n}\n\n\nvec3 getShade(vec3 pos, vec3 rd, vec3 n, vec3 fcol, int intersect_id) {\n    vec3 lightdir = light - pos;\n    vec3 ambient = (0.5+0.2*dot(n,vec3(0.5,0.5,0.5)))*vec3(1.0,1.0,1.0)*fcol \/ (0.02*dot(pos,pos)+1.0);\n    vec3 direct = 3.0*max(dot(n,lightdir)\/dot(lightdir,lightdir), 0.0) * fcol;\n    vec3 specular = (intersect_id==ID_EGG?0.05:0.1) * vec3(1.0,0.95,0.9)*pow(max(dot(rd, normalize(lightdir)), 0.0), (intersect_id==ID_EGG?5.0:40.0));\n    float shadow = calcSoftShadow(pos, 0.2);\n    float ao = calcAO(pos, n);\n    return ao*(ambient+shadow*(direct+specular));\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n\n    float t;\n    vec3 n;\n    vec3 fcol;\n    int intersect_id;\n    if (!intersectScene(ro, rd, t, n, fcol, intersect_id)) {\n        return vec3(0.0);\n    }\n\n    ro = ro + rd*t;\n    vec3 refl = rd - 2.0*dot(rd, n)*n;\n    vec3 col_direct = getShade(ro, refl, n, fcol, intersect_id);\n    vec3 n0 = n;\n\n    if (intersect_id==ID_EGG) return col_direct;\n\n    vec3 col_refl = vec3(0.0);\n    if (intersectScene(ro+0.01*refl, refl, t, n, fcol, intersect_id)) {\n        col_refl = getShade(ro+refl*t, refl-2.0*dot(refl,n)*n, n, fcol, intersect_id);\n    }\n    else col_refl = vec3(pow(max(dot(refl, normalize(light-ro)), 0.0), 2.0)\/(0.02*dot(ro,ro)+1.0));\n\n    return mix(col_direct, col_refl, 0.3+0.2*pow(1.0-abs(dot(refl,n0)),5.0));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint seed = uint(iTime);\n    if (seed>1u) {\n        \/\/ random egg texture\n        calcTextureParameters(seed);\n    \n        \/\/ random egg shape\n        \/\/ the Javascript version has a physically-based (but probably buggy) shape orientation calculation\n        uEggParameters = randomEggShape(seed);\n    }\n    uEggTranslation = vec3(0,0,eggEquationPolar(.5*PI));\n\n    \/\/ between -1 and 1\n    vec2 uv = 2. * fragCoord\/iResolution.xy - 1.;\n\n    \/\/ barrel distortion from https:\/\/www.shadertoy.com\/view\/wslcDS by Shane\n    float r = dot(uv, uv);\n    uv *= 1. + vec2(.03,.02)*(r*r + r);\n\n    \/\/ calculate projection\n    float rx = iMouse.w>=0. ? 0.2 : 1.7*iMouse.y\/iResolution.y-0.1;\n    float rz = iMouse.w>=0. ? -0.5 : 6.3*iMouse.x\/iResolution.x-2.8;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    \/\/ camera position\n    vec3 cam = 6.*w + vec3(0, 0, 0.6);\n    if (cam.z < 0.) {\n        cam -= w * (cam.z\/w.z+1e-3);  \/\/ prevent below horizon\n    }\n\n    \/\/ generate ray\n    vec3 rd = normalize(mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.*length(iResolution)));\n    vec3 col = traceRay(cam, rd);\n\n    \/\/ adjustment\n    float gamma = 1.2;\n    col = vec3(pow(col.x,gamma), pow(col.y,gamma), pow(col.z,gamma));\n    col = 1.2*col-0.05;\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\n\/\/ egg texture parameters\nint uCapShape = 11;\nivec4 uCapShapeOrient = ivec4(0,1,1,0);\nvec3 uCapCol1 = vec3(0.9,0.5,0.5);\nvec3 uCapCol2 = vec3(0.5,0.9,0.9);\nint uRingShape = 21;\nivec4 uRingShapeOrient = ivec4(1,1,0,1);\nvec3 uRingCol1 = vec3(0.5,0.5,0.9);\nvec3 uRingCol2 = vec3(0.5,0.9,0.5);\nint uBodyShape = 43;\nivec4 uBodyShapeOrient = ivec4(1,1,1,0);\nvec3 uBodyCol1 = vec3(0.9,0.9,0.5);\nvec3 uBodyCol2 = vec3(0.5,0.9,0.9);\nint uMidShape = 28;\nivec4 uMidShapeOrient = ivec4(0,0,0,1);\nvec3 uMidCol1 = vec3(0.9,0.8,0.7);\nvec3 uMidCol2 = vec3(0.7,0.5,1.0);\n\n\/\/ random\nuint randint(inout uint seed) {\n    return seed = seed*1664525u+1013904223u;\n}\nfloat randfloat(inout uint seed) {\n    return float(randint(seed))\/4294967296.0;\n}\nivec4 randvec4(inout uint seed) {\n    uint k = randint(seed)>>4u;\n    return ivec4(k&1u,(k>>1u)&1u,(k>>2u)&1u,(k>>3u)&1u);\n}\nfloat hue2rgb(float t) {\n    if (t<0.0) t+=6.0;\n    if (t>6.0) t-=6.0;\n    if (t<1.0) return t;\n    if (t<3.0) return 1.0;\n    if (t<4.0) return 4.0-t;\n    return 0.0;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    h*=6.0;\n    float mx = l<=0.5 ? l*(s+1.0) : l+s-l*s;\n    float mn = 2.0*l-mx;\n    float r = mn+(mx-mn)*hue2rgb(h+2.0);\n    float g = mn+(mx-mn)*hue2rgb(h);\n    float b = mn+(mx-mn)*hue2rgb(h-2.0);\n    return vec3(r,g,b);\n}\nvec3 randcol(inout uint seed) {\n    float hue = randfloat(seed);\n    float sat = 0.7+0.3*randfloat(seed);\n    float bri = 0.7+0.25*randfloat(seed);\n    return hsl2rgb(hue, sat, bri);\n}\n\n\/\/ random texture parameters\nvoid calcTextureParameters(inout uint seed) {\n    randint(seed);\n    uCapShape = int(randint(seed)%44u);\n    uCapShapeOrient = randvec4(seed);\n    uCapCol1 = randcol(seed);\n    uCapCol2 = randcol(seed);\n    uRingShape = int(randint(seed)%44u);\n    uRingShapeOrient = randvec4(seed);\n    uRingCol1 = randcol(seed);\n    uRingCol2 = randcol(seed);\n    uBodyShape = int(randint(seed)%44u);\n    uBodyShapeOrient = randvec4(seed);\n    uBodyCol1 = randcol(seed);\n    uBodyCol2 = randcol(seed);\n    uMidShape = int(randint(seed)%44u);\n    uMidShapeOrient = randvec4(seed);\n    uMidCol1 = randcol(seed);\n    uMidCol2 = randcol(seed);\n}\n\n\n\/\/ Gravatar identicon components, total 44\n\/\/ Reference: https:\/\/barro.github.io\/2018\/02\/avatars-identicons-and-hash-visualization\/\n\n\/\/ return a signed number, -1 < u,v < 1\nfloat identiconComponent_raw(int id, float u, float v) {\n    if (id==0) return v;\n    if (id==1) return u-v-2.0;\n    if (id==2) return u+v;\n    if (id==3) return abs(v)-0.5*(u+1.0);\n    if (id==4) return abs(u)+abs(v)-1.0;\n    if (id==5) return abs(u+v)-(u-v+2.0)\/3.0;\n    if (id==6) return max(abs(v)-0.5*(u+1.0),-max(abs(v)-0.5*(-u+1.0),-u));\n    if (id==7) return max(abs(u+v)-(u-v+2.0)\/3.0,u-v-1.0);\n    if (id==8) return max(abs(u),abs(v))-0.5;\n    if (id==9) return max(min(-u,v),u-v);\n    if (id==10) return max(u,-v);\n    if (id==11) return max(u+abs(v)-1.0,-u);\n    if (id==12) return max(v-u,-v-u);\n    if (id==13) return max(v-u-1.0,max(u,-v));\n    if (id==14) return u-v+1.0;\n    if (id==15) return u*v;\n    if (id==16) return (v+u)*(v-u);\n    if (id==17) return u-2.0*v+1.0;\n    if (id==18) return min(u-2.0*v+1.0,max(u-2.0*v-1.0,v));\n    if (id==19) return min(u-2.0*v+1.0,max(u-v,v));\n    if (id==20) return max(-u-v,u+2.0*v-1.0);\n    if (id==21) return min(max(min(-u,v),u-v),max(max(-u,v),u-v-1.0));\n    if (id==22) return max(1.0-2.0*abs(v)-u,-1.0+2.0*abs(v)-u);\n    if (id==23) return abs(u)-2.0*abs(v)+1.0;\n    if (id==24) return min(abs(u)-2.0*abs(v)+1.0,abs(u)+2.0*abs(v)-1.0);\n    if (id==25) return abs(u)+abs(v)-0.5;\n    if (id==26) return min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0);\n    if (id==27) return min(max(abs(v)-u-1.0,u),abs(v)-u);\n    if (id==28) return min(max(2.0*v-u-1.0,u-v),max(2.0*v+u-1.0,-u-v));\n    if (id==29) return min(u-2.0*v+1.0,-u+2.0*v+1.0);\n    if (id==30) return min(min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0),abs(u)+abs(v)-0.5);\n    if (id==31) return max(abs(abs(u)+abs(v)-0.75)-0.25,min(u,-v));\n    if (id==32) return abs(u)+2.0*abs(v)-1.0;\n    if (id==33) return min(u-v+1.0,min(max(u-v-1.0,max(-u,v)),max(min(-u,v),u-v)));\n    if (id==34) return abs(abs(u)+abs(v)-0.75)-0.25;\n    if (id==35) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),min(max(v-2.0*u+1.0,v+2.0*u-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0)));\n    if (id==36) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(v-2.0*u+1.0,v+2.0*u-1.0));\n    if (id==37) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0));\n    if (id==38) return max(-u+2.0*abs(v)-1.0,u-abs(v));\n    if (id==39) return max(2.0*abs(v)-u-1.0,min(0.5-u,u-abs(v)));\n    if (id==40) return min(u-v+1.0,v-u+1.0);\n    if (id==41) return min(max(u-2.0*v+1.0,u),max(2.0*v-u+1.0,-u));\n    if (id==42) return max(abs(u)+abs(v)-1.0,abs(u)-abs(v));\n    if (id==43) return min(max(max(u-v,-u-v),v-u-1.0),max(max(v-u,u+v),u-v-1.0));\n    return 0.0;\n}\n\nfloat identiconComponent(vec2 uv, int id, ivec4 orient) {\n    float u = uv.x, v = uv.y;\n    if (orient.x==1) u = uv.y, v = uv.x;\n    if (orient.y==1) u = -u;\n    if (orient.z==1) v = -v;\n    return (orient.w==1?-1.0:1.0) * identiconComponent_raw(id, u, v);\n}\n\n\n\/\/ texture on different parts of the egg\n\/\/ 0<u,v<1 for all functions except textureCap\n\nvec3 textureCap(float u, float v) {\n    float x = v*cos(4.0*u), y = v*sin(4.0*u);\n    float sd = identiconComponent(vec2(x,y), uCapShape, uCapShapeOrient);\n    return sd<0.0 ? uCapCol1 : uCapCol2;\n    return sd<0.0 ? vec3(0.9, 0.5, 0.5) : vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureRing(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uRingShape, ivec4(0));\n    return sd<0.0 ? uRingCol1 : uRingCol2;\n    return sd<0.0 ? vec3(0.5, 0.5, 0.9) : vec3(0.5, 0.9, 0.5);\n}\n\nvec3 textureBody(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uBodyShape, ivec4(0));\n    return sd<0.0 ? uBodyCol1 : uBodyCol2;\n    return sd<0.0 ? vec3(0.9, 0.9, 0.5) :  vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureMiddle(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    vec3 k = abs(v)<0.4 ? vec3(1.0) : vec3(0.9);\n    float sd = identiconComponent(vec2(u,v), uMidShape, ivec4(0));\n    vec3 col = sd<0.0 ? vec3(0.9,0.8,0.7) : vec3(0.7,0.5,1.0);\n    col = sd<0.0 ? uMidCol1 : uMidCol2;\n    return k * col;\n}\n\n\/\/ final egg texture\n\nvec3 eggTexture(vec3 p) {\n    float u = atan(p.x, -p.y), v = (PI-atan(length(p.xy), p.z))\/PI;\n    float vn = min(v, 1.0-v);\n\n    vec3 col = vec3(1.0);\n\n    if (vn<0.1) {\n        col = textureCap(v<0.5?u:1.0-u, vn\/0.1);\n    }\n    else if (vn<0.2) {\n        float un8r = acos(cos(4.0*u))\/PI;\n        col = textureRing(v<0.5?un8r:1.0-un8r, (vn-0.1)\/(0.2-0.1));\n    }\n    else if (vn<0.38) {\n        float un8 = fract(u * 4.0 \/ PI);\n        col = textureBody(v<0.5?un8:1.0-un8, (vn-0.2)\/(0.38-0.2));\n    }\n    else {\n        float un8 = u * 4.0 + 0.5*PI;\n        float vn = sin(un8)<0.0 ? v : 1.0-v;\n        col = textureMiddle(fract(un8\/PI), (vn-0.38)\/(1.0-2.0*0.38));\n    }\n\n    return col;\n}\n\n\n\/\/ egg geometry\n\n\/\/ generated by tracing+fitting real-world egg pictures and find the distribution of the parameters\n\/\/ uniform random inside an ellipsoid, not quite perfect\n\n\/\/ return three numbers a,b,c\n\/\/ the equation of the section of the egg in polar coordinate is\n\/\/ r(t) = 1-sin(t)\u00b2(a+b*exp(-t)+c*cos(t)), c(t)=r(t)*vec2(sin(t),cos(t))\nvec3 randomEggShape(inout uint seed) {\n    float u = 2.0*PI * randfloat(seed);\n    float v = 2.0*randfloat(seed)-1.0;\n    float w = pow(randfloat(seed), 1.0\/3.0);\n    float x = w * sqrt(1.0-v*v) * cos(u);\n    float y = w * sqrt(1.0-v*v) * sin(u);\n    float z = w * v;\n    return vec3(0.050482,1.191725,-0.211361)\n       + x*vec3(-0.112119,0.866281,-0.16593)\n       + y*vec3(0.0514355,0.0009434,-0.0298296)\n       + z*vec3(0.0212091,0.0098094,0.0368813);\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"WtjSD3","date":"1567308037","viewed":201,"name":"Implicit Heart","username":"harry7557558","description":"defined by implicit equation (x\u00b2 + 9\/4 y\u00b2 + z\u00b2)\u00b3 - x\u00b2 z\u00b3 - 9\/80 y\u00b2 z\u00b3 = 0","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["heart","implicit","love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define AA 2\n\n#define EPSILON 1e-5\n\n#define MAX_STEP 1024\n#define MAX_DIST 20.0\n\nvec3 light = normalize(vec3(-0.3, 0.1, 1));\n\n\/\/ put any implicit equations you want to visualize there \\\n     (you may need to reduce the step length)\nfloat func(in vec3 p) {\n    float e = p.x*p.x + 2.25*p.y*p.y + p.z*p.z - 1.0;\n\treturn e*e*e - (p.x*p.x + 0.1125*p.y*p.y)*p.z*p.z*p.z;\n}\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = func(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = func(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = func(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = func(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n \/ (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = func(p + t * d);\n        dt \/= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            P = normalize(p + t * d);\n            vec3 col = sin(30.0*P.x)+sin(30.0*P.y)+sin(30.0*P.z)>0.0 ?\n                vec3(0.2,0.6,1.0) : vec3(0.6,0.4,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn (0.3+0.7*t)*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.7*dif + 0.2*pow(max(dot(d, light), 0.0), 4.0) + 0.3)*vec3(1.0, 0.1, 0.6);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.6*length(iResolution);\n    \n    float rz=atan(-pos.x,pos.y), rx=atan(length(pos.xy),-pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)\/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)\/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col\/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dXfDr","date":"1588004495","viewed":133,"name":"Implicit Star","username":"harry7557558","description":"A modification of my first shader https:\/\/www.shadertoy.com\/view\/WtjSD3. Make the code faster and look less naive.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["star","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ the equation of the star shape:\n\/\/ 4(x\u00b2+2y\u00b2+z\u00b2-1)\u00b2-(5x\u2074z-10x\u00b2z\u00b3+z\u2075)-1=0\n\/\/ or: 4(x\u00b2+2y\u00b2+z\u00b2-1)\u00b2-Im((x+zi)\u2075)-1=0\n\nfloat func(in vec3 p){\n    vec3 u = p*p;\n    float d = u.x+2.0*u.y+u.z-1.0;\n    if (d>3.0) return d;  \/\/ clipping needed because its degree is odd\n    return 4.0*d*d-p.z*(5.*u.x*u.x-10.*u.x*u.z+u.z*u.z)-1.0;\n}\n\nvec3 calcGrad(vec3 p){\n    const float e = .0001;\n\tfloat a = func(p+vec3(e,e,e));\n\tfloat b = func(p+vec3(e,-e,-e));\n\tfloat c = func(p+vec3(-e,e,-e));\n\tfloat d = func(p+vec3(-e,-e,e));\n\treturn vec3(a+b-c-d,a-b+c-d,a-b-c+d)*(.25\/e);\n}\n\n\nconst vec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 1e-3, dt;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 1024; i++) {\n\t\tdt = func(p + t * d);\n        dt \/= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n        if (dt < 1e-2) {\n\t\t\tp += t * d;\n    \t\tvec3 n = normalize(calcGrad(p));\n    \t\tif (dot(n, d) > 0.0) n = -n;\n    \t\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n    \t\treturn (0.7*dif+0.2*pow(max(dot(d, light),0.0),4.0)+0.4)*vec3(1.0,0.6,0.1);\n        }\n\t\tif (t > 20.0) break;\n\t}\n    vec3 col = sin(30.0*d.x)+sin(30.0*d.y)+sin(30.0*d.z)>0.0 ?\n        vec3(1.0,0.8,0.6) : vec3(0.9,0.6,0.8);\n\tt = max(dot(d,light), 0.0);\n\treturn (0.3+0.7*t)*col;\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = 1.5*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.5*length(iResolution);\n\n    vec3 w = normalize(pos);\n    vec3 u=normalize(vec3(-w.y,w.x,0));\n    vec3 v=cross(w,u);\n    mat3 M=-mat3(u,v,w);\n\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d=M*vec3(0.5*iResolution.xy-(fragCoord.xy+vec2(i,j)\/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col\/=float(AA*AA);\n\n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"7dBcDR","date":"1643317877","viewed":78,"name":"L^n-norm ellipsoid SDF+AABB","username":"harry7557558","description":"SDF approximation (inspired by iq) derived for a high school art project.\nExact AABB derived using Lagrange multiplier for fun.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["volume","sdf","visualizer","ellipsoid","aabb","norm","lagrangemultiplier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Visualize the SDF (approximate) and AABB (exact) of an oriented L^n-ellipsoid\n\/\/ Equation: (|x|\/rx)^n + (|y|\/ry)^n + (|z|\/rz)^n = 1\n\n\/\/ SDF inspired by iq's ellipsoid SDF approximation\n\/\/ Doesn't work well inside the shape and for n < 1.5\n\n\/\/ Exact AABB derived using Lagrange multiplier\n\/\/ I'm not sure when I will use this, I derived it as a math practice and for fun\n\n\/\/ Forked from a 3D SDF visualizer - https:\/\/www.shadertoy.com\/view\/ssKGWR (v1),\n\/\/ https:\/\/github.com\/harry7557558\/Shadertoy\/blob\/master\/sdf_visualizer_2.glsl (v2)\n\/\/  - Visualize the SDF using isolines (volume rendering);\n\/\/  - Red highlight high directional gradient, which causes issues in raymarching;\n\/\/  - Magenta highlight high surface gradient, green highlight low surface gradient;\n\n\/\/ There are people who reported that my previous shaders look very dim\n\/\/ while they look appropriate on my screen.\n\/\/ If the shader appears too dark\/bright, adjust the following value:\n#define GAMMA 0.8\n\n\n\/\/ START OF ELLIPSOID STUFF ================================\n\n\/\/ Approximation of the SDF of an L^n-norm ellipsoid\n\/\/ inspired by iq's ellipsoid SDF approximation\nfloat sdLnNormEllipsoid(vec3 p, vec3 r, float n) {\n    p = abs(p);\n    float k1 = pow(dot(pow(p\/r,vec3(n)),vec3(1)),1.0\/n);\n    float k2 = pow(dot(pow(p\/(r*r),vec3(n)),vec3(1)),1.0\/n);\n    return k1*(k1-1.0)\/k2;\n}\n\n\/\/ Axes-aligned bounding box of a rotated L^n-norm ellipsoid\n\/\/ Derived using Lagrange multiplier, return the radius of the box\nvec3 aabbLnNormEllipsoid(vec3 r, float n, mat3 rotation) {\n    float res[3];\n    for (int i=0; i<3; i++) {  \/\/ iterate through each dimension\n        vec3 d = abs(rotation[i]);\n        float n_lambda = pow(dot(pow(d*r,vec3(n\/(n-1.))),vec3(1)),(n-1.)\/n);\n        res[i] = dot(d, pow(d*pow(r,vec3(n))\/n_lambda,vec3(1.\/(n-1.))));\n    }\n    return vec3(res[0], res[1], res[2]);\n}\n\n\/\/ END OF ELLIPSOID STUFF ================================\n\n\n\/\/ Get the radius, power of norm, and inverse rotation matrix of the shape, for demonstration purpose\nvoid getParameters(out vec3 r, out float n, out mat3 rotation) {\n    \/\/ radius among axes\n    r = vec3(1.0+0.5*cos(1.6*iTime), 1.0+0.5*cos(1.5*iTime), 1.0+0.5*cos(1.4*iTime));\n    \/\/ power of norm\n    n = mix(1.5, 6.0, 0.5+0.5*cos(1.0*iTime));\n    \/\/ rotation matrix (axis-angle)\n    vec3 u = normalize(vec3(sin(1.3*iTime), sin(1.2*iTime), sin(1.1*iTime)));\n    float a = sin(0.9*iTime), s = sin(a), c = cos(a), oc = 1.0-c;\n    rotation =  mat3(\n        oc*u.x*u.x+c, oc*u.x*u.y-u.z*s, oc*u.z*u.x+u.y*s,\n        oc*u.x*u.y+u.z*s, oc*u.y*u.y+c, oc*u.y*u.z-u.x*s,\n        oc*u.z*u.x-u.y*s, oc*u.y*u.z+u.x*s, oc*u.z*u.z+c\n    );\n}\n\n\/\/ SDF and numerical gradient\nfloat sdf(vec3 p) {\n    vec3 r; float n; mat3 rotation;\n    getParameters(r, n, rotation);\n    return sdLnNormEllipsoid(rotation*p, r, n);\n}\nvec3 sdfGrad(vec3 p, float e) {\n\tfloat a = sdf(p+vec3(e,e,e));\n\tfloat b = sdf(p+vec3(e,-e,-e));\n\tfloat c = sdf(p+vec3(-e,e,-e));\n\tfloat d = sdf(p+vec3(-e,-e,e));\n\treturn (.25\/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\/\/ 3D SDF visualizer template\n\/\/ orange-blue: SDF isosurfaces\n\/\/ red-black: discontinuity (high numerical gradient)\n\/\/ green-pink: surface gradient lower\/higher than 1\n\n\/\/ constants\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\/\/ raymarching parameters\n#define STEP 0.1\n#define MIN_STEP 0.002\n\n\/\/ rendering parameters\n#define FIELD_EMISSION (insideAABB(ro+rd*t)?0.4:0.05)\n#define ISOSURFACE_FREQUENCY 6.0\n#define DISCONTINUITY_OPACITY 0.2\n#define SURFACE_GRADIENT 10.0\n\n\/\/ projection parameters\n#define PERSPECTIVE 10.0  \/* larger: less perspective effect *\/\n#define SCALE 6.0  \/* image appears smaller when this is set larger *\/\n\n\/\/ light direction as a global variable\nvec3 light;\n\n\/\/ colormaps - https:\/\/www.shadertoy.com\/view\/NsSSRK\nvec3 colorSdf(float t) {\n    float r = .385+.619*t+.238*cos(4.903*t-2.61);\n    float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n    float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 colorNormal(float t) {\n    float r = .529-.054*t+.55*cos(5.498*t+2.779);\n    float g = .21+.512*t+.622*cos(4.817*t-1.552);\n    float b = .602-.212*t+.569*cos(5.266*t+2.861);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\n\/\/ test if inside or outside AABB\nbool insideAABB(vec3 p) {\n    vec3 r; float n_; mat3 rotation;\n    getParameters(r, n_, rotation);\n    vec3 box_radius = aabbLnNormEllipsoid(r, n_, rotation);\n    return abs(p.x)<box_radius.x && abs(p.y)<box_radius.y && abs(p.z)<box_radius.z;\n}\n\n\/\/ raymarhing, return RGB\nvec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float t = t0;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old = sdf(ro+rd*t), v;\n    float dt = min(STEP, abs(v_old));\n    for (float i=ZERO; i<200.; i++) {\n        t += dt;\n        if (t > t1) return totcol;\n        v = sdf(ro+rd*t);\n        if (v*v_old<0.) break;\n        vec3 col = colorSdf(0.5+0.5*sin(ISOSURFACE_FREQUENCY*PI*0.5*(v_old+v)));\n        float grad = abs(v-v_old)\/dt;\n        float grad_abs = (1.0-grad)\/dt;\n        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));\n        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        dt = clamp(abs(v_old=v), MIN_STEP, STEP);\n    }\n    vec3 grad = sdfGrad(ro+rd*t, 1e-3);\n    float grad_col = SURFACE_GRADIENT*(0.5*length(grad)-0.5);\n    vec3 col = colorNormal(1.0-1.0\/(1.0+exp(2.0*grad_col)));  \/\/ 0.5+0.5*tanh(grad_col)\n    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);\n    return totcol + col * totabs;\n}\n\n\/\/ ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*vec3(2.5);\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set camera\n    float rx = iMouse.z!=0. ? 3.14*(iMouse.y\/iResolution.y)-1.57 : 0.3;\n    float rz = iMouse.z!=0. ? -iMouse.x\/iResolution.x*4.0*3.14 : -1.0;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = SCALE*PERSPECTIVE*w;\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, PERSPECTIVE*length(iResolution.xy));\n    rd = normalize(rd);\n    \/\/ calculate pixel color\n    light = normalize(w+0.5*u+0.1*v);\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = render(ro, rd, t0, t1);\n    col = pow(col, vec3(GAMMA));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"sllczM","date":"1648825490","viewed":55,"name":"Linear Regression AA","username":"harry7557558","description":"Showcase an anti-aliasing technique I developed for a raymarching demo.\nRead the comments for details. Mouse click to show image without AA.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["antialiasing","aa","leastsquare","linearregression"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Linear Regression Anti-Aliasing\n\/\/ Mouse click to show image without AA\n\n\/\/ Motivation:\n\/\/ I need to anti-alis renderings of user-input scalar field.\n\/\/ The usual AA technique for raymarching may not work well\n\/\/ because the SDF can be very ill-conditioned.\n\/\/ I tried to find a way to anti-alias arbitrary images\n\/\/ without supersampling or blurring the image.\n\n\/\/ Outline of the method:\n\/\/  - Calculate image gradient and store in a buffer\n\/\/  - For each pixel, find the line of best fit to pixels with high gradient\n\/\/  - Determine the color at both sides of the line\n\/\/  - Render the line separating the colors on the pixel using an AA technique\n\n\/\/ Works well for simple geometric shapes,\n\/\/ Not so good for thin lines and noisy pixels.\n\/\/ May be improved using quadratic regression (which is more expensive)\n\n\/\/ Set this number to 3 or 4 for images without thin lines\/angles\n\/\/ (or images with a higher resolution):\n#define AA_RADIUS 2\n\n\/\/ Used in this (still incomplete) raymarching demo:\n\/\/ https:\/\/harry7557558.github.io\/tools\/raymarching-implicit\/index.html\n\/\/ (AA_RADIUS is set to 3)\n\n\n\/\/ get image\n#define sv(p) texelFetch(iChannel0, p, 0).xyz\n\/\/ get magnitude of gradient\n#define sg(p) texelFetch(iChannel1, p, 0).xyz\n\n\n\/\/ for comparison\nvec3 boxBlur(ivec2 p0, int r) {\n    vec3 c = vec3(0.0);\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) {\n        c += sv(p0+ivec2(dx,dy));\n    }}\n    return c \/ float((2*r+1)*(2*r+1));\n}\n\n\n\/\/ linear regression AA\nvec3 aaLinreg(ivec2 p0, int r) {\n    \/\/if (dot(sg(p0),vec3(1)) < 0.03) return sv(p0);\n\n    \/\/ find the line of best fit to the gradient\n    \/\/ https:\/\/www.desmos.com\/calculator\/cs4faizltl\n    float s1=0., sx=0., sy=0., sx2=0., sxy=0., sy2=0.;\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) {\n        vec3 g = sg(p0+ivec2(dx,dy));\n        float w = dot(g, vec3(1));\n        s1 += w;\n        sx += w*float(dx);\n        sy += w*float(dy);\n        sx2 += w*float(dx*dx);\n        sy2 += w*float(dy*dy);\n        sxy += w*float(dx*dy);\n    }}\n    float ml = s1*sxy-sx*sy;\n    if (ml==0.) return sv(p0); \/\/ no variance\n    float kl = (s1*sx2-s1*sy2+sy*sy-sx*sx)\/ml;\n    vec2 ab = vec2(kl-sign(ml)*sqrt(kl*kl+4.), 2.);\n    float c = (ab.x*sx+ab.y*sy)\/s1;\n    float abl = length(ab);\n    c \/= abl, ab \/= abl;\n    \/\/return vec3(0,1,0);  \/\/ debug\n\n    \/\/ rasterize the line with AA\n    float ck = 0.5-1.0*c;\n    if (ck<0. || ck>1.) return sv(p0);\n    vec3 c0=vec3(0.), c1=vec3(0.); \/\/ color of two sides\n    float w0=0., w1=0.;\n    for (int dx=-r; dx<=r; dx++) {\n    for (int dy=-r; dy<=r; dy++) if (dx*dx+dy*dy<r*r) {\n        float d = dot(ab,vec2(dx,dy));\n        if (abs(d)>1.) continue; \/\/ prevent blurring\n        vec3 col = sv(p0+ivec2(dx,dy));\n        if (d<c) c0+=col, w0+=1.;\n        else c1+=col, w1+=1.;\n    }}\n    if (w0==0. || w1==0.) return sv(p0);\n    \/\/return vec3(0,1,0);  \/\/ debug\n    return mix(c0\/w0, c1\/w1, clamp(ck,0.,1.)); \/\/ AA\n}\n\n\n\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    vec3 col = aaLinreg(p, AA_RADIUS);\n\n    \/\/ uncomment lines to compare\n    if (iMouse.z > 0.) {\n        \/\/col = boxBlur(p, 1);\n        col = sv(p).xyz;\n        \/\/col = vec3(dot(sg(p),vec3(1)));\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ render an aliased image\n\nvec3 scene1(vec2 uv) {\n    float k = abs(abs(length(uv)-0.5)-0.25)-0.12;\n    vec3 col = k>0. ? sin(20.*(uv.x*uv.y))>0. ? vec3(.8,.8,.2) : vec3(.2,.2,.8)\n        : vec3(1,0.5,0)*(0.5*sqrt(-k)+0.8+uv.x*uv.y);\n    return mix(col, vec3(step(dot(col,vec3(1)),1.5)), 0.6);\n}\n\nvec3 scene2(vec2 uv) {\n    uv *= 4.;\n    float a=uv.y-uv.x+4., b=uv.y+uv.x+4.;\n    float k = sin(min(a*sin(b),b*sin(a)))-cos(max(a*cos(b),b*cos(a)))-0.1;\n    return vec3(step(k,0.));\n}\n\nvec3 scene3(vec2 uv) {\n    float t = -4.0 \/ (uv.y-0.8); if (t<0.) return vec3(0.);\n    vec2 xy = uv * t;\n    return (sin(xy.x)*sin(xy.y)>0. ? vec3(0.8): vec3(0.2))*exp(-0.05*t);\n}\n\nvec3 scene4(vec2 uv) {\n    uv = (uv-vec2(1.,-1.2))\/40.0;\n    return step(texture(iChannel0,uv).xyz, vec3(0.3));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 ci = 2.0 * coord \/ iResolution.xy;\n    vec2 pi = floor(ci);\n    vec2 uv = 2.0 * fract(ci) - 1.0;\n    if (pi==vec2(0,0)) col.xyz = scene3(uv);\n    if (pi==vec2(1,0)) col.xyz = scene2(uv);\n    if (pi==vec2(0,1)) col.xyz = scene1(uv);\n    if (pi==vec2(1,1)) col.xyz = scene4(uv);\n    col = vec4(clamp(col.xyz,0.,1.),1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ calculate the magnitude of image gradient\n\n#define s(p) texelFetch(iChannel0, p, 0).xyz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p0 = ivec2(gl_FragCoord.xy);\n    vec3 sx = s(p0+ivec2(1,0))-s(p0-ivec2(1,0));\n    vec3 sy = s(p0+ivec2(0,1))-s(p0-ivec2(0,1));\n    vec3 su = s(p0+ivec2(1,1))-s(p0-ivec2(1,1));\n    vec3 sv = s(p0+ivec2(1,-1))-s(p0-ivec2(1,-1));\n    vec3 g = 0.25*(sx*sx+sy*sy+su*su+sv*sv);\n    fragColor = vec4(g, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"wl2SWt","date":"1567531823","viewed":78,"name":"Mandelbrot++","username":"harry7557558","description":"zoom in to the Mandelbrot Set","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["mandelbrot","complex","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* Also check:\n * Mandelbrot Fractal: https:\/\/www.shadertoy.com\/view\/wl2SWt\n * Burning-Ship Fractal: https:\/\/www.shadertoy.com\/view\/wljSDt\n * Forest Fractal: https:\/\/www.shadertoy.com\/view\/tt2SDt\n * Crown Fractal: https:\/\/www.shadertoy.com\/view\/tl2SDt\n *\/\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(-0.743643904987575,0.1318259145542959);\n    \/\/vec2 p0 = vec2(0.3385847939577921,0.5733237332425829);\n    vec2 p1 = vec2(-0.65,0);\n    float m1 = 6.0\/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0\/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5\/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)\/float(AA)-0.5*iResolution.xy)*m+p;\n        if (length(c-vec2(-1,0))>0.25 && length(c-vec2(-0.25,0))>0.5)\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n\/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)\/20.0),6.0),\n                      pow(sin((m+1.0)\/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)\/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)\/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)\/20.0),6.0),\n                      pow(sin((n-2.0)\/20.0),4.0),\n                      0.8*pow(sin((n+2.0)\/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)\/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col\/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wscGz8","date":"1567813560","viewed":77,"name":"Mandelbrot\u2212Julia Relationship","username":"harry7557558","description":"Relationship between Mandelbrot and Julia set: the red dot in the Mandelbrot set represents c, where Julia set is defined by z\u21a6z\u00b2+c. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","iteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define MAX_ITER 1024\n\nvec3 colorf(float n) {\n    float m = 5.0*sin(0.1*(n-6.0))+n;\n    return vec3(\n        pow(sin(0.05*(m-8.0)),6.0),\n        pow(sin(0.05*(m+1.0)),4.0),\n        (0.8*pow(sin(0.05*(m+2.0)),2.0)+0.2)*(1.0-pow(abs(sin(0.05*(m-14.0))),12.0))\n    );\n}\n\nvec3 Iter(vec2 z, vec2 c)\n{\n    for (int i=0;i<MAX_ITER;i++){\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y)+c;\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(0.5*log2(h))+4.0;\n            return colorf(n);\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = length(iResolution);\n    float m = 7.0\/d, s = 0.06*d;\n    vec2 b = iResolution.xy-sqrt(iResolution.xy*vec2(s));\n    \n    vec2 c = abs(asin(sin(0.017*iTime)))*vec2(cos(iTime)-0.4,0.8*sin(iTime));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n            vec2 p = fragCoord+vec2(u,v)\/float(AA);\n            float sd = max(b.x-p.x,b.y-p.y);\n            if (abs(sd)<0.04*s)  \/\/ red border\n                col+=vec3(1.0,0.0,0.0);\n            else if (sd<0.0){  \/\/ Mandelbrot\n                p = 2.75*(p-b);\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                if (length(z-c)<0.06) col+=vec3(1.0,0.0,0.0);  \/\/ red dot\n                else col += Iter(vec2(0.0),z);\n            }\n            else{  \/\/ Julia\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                col += Iter(z, c);\n            }\n        }\n    }\n    col\/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fdVfW1","date":"1658111557","viewed":92,"name":"MarbleEgg_853d","username":"harry7557558","description":"A quick shader inspired by the [url=https:\/\/www.google.com\/search?q=perlin+noise+vase&tbm=isch]Perlin noise vase[\/url]. Combine two of my previous physically based path tracing shaders.","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["sss","scattering","marble","emission","cooktorrance","skull","egg","ggx","henyeygreenstein","glassball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Combine two of my previous path tracing shaders to render a marble egg.\n\n\/\/ I was inspired by the Perlin noise vase.\n\n\/\/ A cheap sine-based noise produces an unintentional skull-like pattern,\n\/\/ which I didn't notice after playing with it for a while.\n\n\n\/\/ Stuff in Buffer A\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}\n\n\n\/\/ (Without this comment, you may or may not notice that\n\/\/  the marble and the floor is emissive.\n\n\/\/ The marble's reflection has a blue-green tint.)\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Fork of \"isp-glassball-11-mix\" by harry7557558. https:\/\/shadertoy.com\/view\/NscXRj\n\/\/ 2022-07-18 00:12:26\n\n\n#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\n\/\/ random number generator\nuint rand_seed = 0u;\nuint randu() { return rand_seed = rand_seed * 1664525u + 1013904223u; }\nfloat randf() { return float(randu()) * (1.\/4294967296.); }\n\n\n\/\/ intersection function\nbool intersectEllipsoid(vec3 r, vec3 ro, vec3 rd, inout float t, inout vec3 n) {\n\tfloat a = dot(rd\/r,rd\/r);\n\tfloat b = -dot(rd\/r,ro\/r);\n\tfloat c = dot(ro\/r,ro\/r)-1.0;\n\tfloat delta = b*b-a*c;\n\tif (delta < 0.0) return false;\n\tdelta = sqrt(delta);\n\tfloat t1 = (b-delta)\/a, t2 = (b+delta)\/a;\n\tif (t1>t2) { float t=t1; t1=t2; t2=t;}\n\tif (t1>t || t2<0.) return false;\n\tt = t1>0. ? t1 : t2;\n\tn = normalize((ro+rd*t)\/(r*r));\n\treturn true;\n}\n\n\n\/\/ scattering \/ importance sampling functions\n\n\/\/ Lambert\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = randf();\n    float an = 2.0*PI*randf();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\n\/\/ refractive\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 \/ n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.0) ci = -ci, n = -n;\n    float ct = 1.0 - eta * eta * (1.0 - ci * ci);\n    if (ct < 0.0) return rd + 2.0*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) \/ (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) \/ (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return randf() > R ?\n        rd * eta + n * (eta * ci - ct)  \/\/ refraction\n        : rd + 2.0*ci*n;  \/\/ reflection\n}\n\n\/\/ phase functions\nvec3 sampleUniformSphere() {\n    float u = 2.0*PI*randf();\n    float v = 2.0*randf()-1.0;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.0-v*v), v);\n}\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.0) return sampleUniformSphere();\n    if (g >= 1.0) return wi;\n    if (g <= -1.0) return -wi;\n    float us = randf();\n    float vs = 2.0*PI*randf();\n    float z = (1.0+g*g-pow((1.0-g*g)\/(2.0*g*(us+(1.0-g)\/(2.0*g))),2.0))\/(2.0*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.0-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n\/\/ Cook-Torrance BRDF - https:\/\/www.shadertoy.com\/view\/sddXWj\n\nfloat sampleGgxImportance(in vec3 wi, in float alpha, out vec3 wo) {\n    float su = 2.0*PI*randf();\n    float sv = randf();\n    \/\/sv = acos(sqrt((1.0-sv)\/((alpha*alpha-1.)*sv+1.)));\n    sv = atan(alpha*sqrt(sv\/(1.0-sv)));\n    vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n    wo = -(wi-2.0*dot(wi,h)*h);\n    return wo.z<0. ? 0. : 4.0*dot(wi, h);\n}\n\nvec3 sampleCookTorrance(\n    vec3 wi, vec3 n,\n    float alpha,  \/\/ roughness\n    float f0,  \/\/ ratio of reflection along the normal\n    float lambertian,  \/\/ ratio of lambertian coefficient\n    vec3 albedo,\n    inout vec3 m_col\n    ) {\n\n    if (randf() < lambertian) {\n        vec3 wo = sampleCosWeighted(n);\n        m_col *= albedo;\n        return wo;\n    }\n\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wo, m;  \/\/ out and half vector\n\n    \/\/ GGX divided by PDF\n    float D = sampleGgxImportance(wi, alpha, wo);\n    m = normalize(wi+wo);\n\n    \/\/ Geometry\n    float tan2_theta_i = (1.0-wi.z*wi.z)\/(wi.z*wi.z);\n    float tan2_theta_o = (1.0-wo.z*wo.z)\/(wo.z*wo.z);\n    float lambda_i = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_i)-1.0);\n    float lambda_o = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_o)-1.0);\n    float G = 1.0\/(1.0+lambda_i+lambda_o);\n\n    \/\/ Fresnel\n    float F = f0 + (1.0-f0)*pow(1.0-dot(wi, m), 5.0);\n\n    \/\/ Put all together\n    float Fr = D*G*F \/ (4.0*wi.z*wo.z+1e-4);\n    float Fr_cos = Fr * wo.z;  \/\/ wo is the direction of light in path tracing\n    m_col *= Fr_cos * albedo;\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n\/\/ define materials\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_ground = 1;\nconst int mat_refractive = 2;\n\n\n\/\/ subsurface scattering - https:\/\/shadertoy.com\/view\/NscXRj\n\nvec4 mapMarbleTexture(vec3 p) {\n    p -= vec3(0, 0, 1);\n    for (float i=-2.; i<=6.; i++) {\n        if (i==1.||i==2.) continue;\n        float k = exp2(i);\n        p += 0.5*cos(k*p.zxy-i)\/k;\n    }\n    float k = 1.0-0.9*pow(0.5+0.5*sin(2.*dot(p,vec3(10,10,8))),40.0);\n    return vec4(k,k,k,1);\n}\nvoid calcAbsorb(in vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    \/\/ green-blue emission\n    emi = 0.15*mix(vec3(0.0,1.0,0.2), vec3(0.0,0.2,1.0), 1.0\/(1.0+exp(-p.y)));\n    \/\/ volume absorption, zero\n    tabs = vec3(0.0);\n    \/\/ scattering absorption, black\/white\n    sabs = mapMarbleTexture(p).xyz;\n    \/\/ scattering opacity\n    k = 40.0;\n    \/\/ backward scattering 0.5\n    g = -0.5;\n}\n\nvoid calcScatter(in vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1.0, hit_p = randf();\n    float dt = 0.01;\n    m_emi = vec3(0.0);\n    for (float t = 1e-4; t < mt-dt; t += dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+0.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p\/hit_p)\/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0.0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\n\/\/ path tracing\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1.0), t_col = vec3(0.0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0.0);\n        int material = mat_background;\n\n        \/\/ plane\n        t = -ro.z \/ rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = 0.5*vec3(0.9, 0.95, 0.98) \/ (0.1*dot(min_ro.xy,min_ro.xy)+1.0);\n            material = mat_ground;\n        }\n\n        \/\/ marble\n        t = min_t;\n        if (intersectEllipsoid(vec3(0.8,1.1,0.8), ro-vec3(0,0,0.8), rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1.0);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1.0);\n                material = mat_refractive;\n            }\n        }\n\n        \/\/ update ray\n        if (material == mat_background) {\n            if (iter==0) return vec3(0.0);\n            col = 2.0 * texture(iChannel1, rd.yzx).xyz;\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  \/\/ ray hits into the surface\n        if (material == mat_ground) {  \/\/ cook-torrance\n            rd = sampleCookTorrance(-rd, min_n, 0.05, 0.8, 0.1, 2.0*col, col);\n            t_col += m_col * vec3(0.2)*col*max(dot(rd,min_n),0.0);  \/\/ make it glow a little\n        }\n        else if (material == mat_refractive) {  \/\/ steel ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.0) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set random seed\n    vec3 p3 = fract(fragCoord.xyx*1.1031);\n    p3 += dot(p3, p3.zxy + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    rand_seed = uint(1048576.*h)+uint(iFrame);\n\n    \/\/ camera\n    float rx = iMouse.z==0.?0.25:1.8*(iMouse.y\/iResolution.y)-0.1;\n    float rz = iMouse.z==0.?0.5:-iMouse.x\/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(randf(),randf())-0.5)\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    \/\/ accumulate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)\/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"NsSSRK","date":"1620523568","viewed":227,"name":"Mathematica Color Schemes","username":"harry7557558","description":"Apply least-squares fitting to Wolfram language color schemes.\n[url]https:\/\/harry7557558.github.io\/Graphics\/UI\/color_functions\/[\/url]","likes":20,"published":3,"flags":0,"usePreview":0,"tags":["color","palette","cosine","polynomial","leastsquare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Wolfram Language Color Schemes (least square fitting)\n\n\/\/ Apply least square fitting to color images downloaded from\n\/\/ https:\/\/reference.wolfram.com\/language\/guide\/ColorSchemes.html\n\n\/\/ Curve fitting code (check the .py files):\n\/\/ https:\/\/github.com\/harry7557558\/Graphics\/tree\/master\/UI\/color_functions\n\n\/\/ Each color scheme is fitted to three functions:\n\n\/\/ `P`: Polynomial functions of varying degree;\n\/\/ `T`: Functions in the form color(x)=c\u2080+c\u2081\u22c5x+a\u2080\u22c5cos(\u03c0\u22c5x-u\u2080)+\u2211\u2096[a\u2096\u22c5cos(2k\u03c0\u22c5x-u\u2096)];\n\/\/ `C`: Functions in the form color(t)=a+b*t+c*cos(d*t+e), inspired by iq's cosine color palette article;\n\n\/\/ Coefficients for `cosine` are computed numerically and may not be optimal. \n\n\/\/ For a better visual comparison of the three color functions,\n\/\/ go to https:\/\/harry7557558.github.io\/Graphics\/UI\/color_functions\/\n\n\/\/ Disclaimer: I\u2019m not related to Wolfram in anyway. Wolfram reserves the rights of these color schemes.\n\n\n\/* ====================== polynomial color functions ====================== *\/\n\nvec3 AlpineColorsP(float t) {\n    return clamp((((vec3(0,0,-2.66)*t+vec3(0,0,4.45))*t+vec3(.61,.5,-.91))*t+vec3(.15,.09,-.5))*t+vec3(.27,.4,.51),0.,1.);\n}\nvec3 LakeColorsP(float t) {\n    return clamp(((vec3(0,0,1.02)*t+vec3(-.21,-.93,-2.57))*t+vec3(.85,1.81,1.9))*t+vec3(.29,.02,.49),0.,1.);\n}\nvec3 ArmyColorsP(float t) {\n    return clamp(((vec3(0,1.1,0)*t+vec3(.13,-1.17,.65))*t+vec3(.18,.29,-.5))*t+vec3(.45,.58,.51),0.,1.);\n}\nvec3 MintColorsP(float t) {\n    return clamp((vec3(-.58,-.37,-.55)*t+vec3(1.04,.01,.7))*t+vec3(.46,.97,.63),0.,1.);\n}\nvec3 AtlanticColorsP(float t) {\n    return clamp((((vec3(-.97,0,0)*t+vec3(1.5,-.85,-1.25))*t+vec3(-1.4,-.25,.41))*t+vec3(1.26,1.48,1.33))*t+vec3(.1,.12,.13),0.,1.);\n}\nvec3 NeonColorsP(float t) {\n    return clamp((((vec3(0,-3.39,-3.65)*t+vec3(0,5.26,7.87))*t+vec3(-.33,-1.04,-4.42))*t+vec3(.44,-1.62,.7))*t+vec3(.69,.95,.27),0.,1.);\n}\nvec3 AuroraColorsP(float t) {\n    return clamp((((vec3(6.62,2.78,-8.72)*t+vec3(-12.68,-9.91,17.42))*t+vec3(7.58,9,-10.1))*t+vec3(-.87,-1.95,2.11))*t+vec3(.25,.31,.24),0.,1.);\n}\nvec3 PearlColorsP(float t) {\n    return clamp((((vec3(-4.27,-4.24,-6.53)*t+vec3(10.54,10.44,14.12))*t+vec3(-7.15,-7.65,-9.04))*t+vec3(.94,1.44,1.66))*t+vec3(.89,.82,.76),0.,1.);\n}\nvec3 AvocadoColorsP(float t) {\n    return clamp(((vec3(-1.86,1.04,0)*t+vec3(3.64,-2.34,.03))*t+vec3(-.83,2.33,.17))*t+vec3(.03,-.03,.01),0.,1.);\n}\nvec3 PlumColorsP(float t) {\n    return clamp(((vec3(3.19,0,-2)*t+vec3(-4.92,.8,2.23))*t+vec3(2.7,.03,.17))*t+vec3(-.03,.04,0),0.,1.);\n}\nvec3 BeachColorsP(float t) {\n    return clamp((((vec3(4.55,3.94,-4.62)*t+vec3(-6.3,-5.4,7.53))*t+vec3(1.93,1.2,-2.6))*t+vec3(.01,.8,.42))*t+vec3(.86,.5,.25),0.,1.);\n}\nvec3 RoseColorsP(float t) {\n    return clamp((((vec3(4.77,4.06,0)*t+vec3(-9.87,-8.77,0))*t+vec3(5.17,4.81,-1.2))*t+vec3(.48,-.29,1.24))*t+vec3(.16,.32,.04),0.,1.);\n}\nvec3 CandyColorsP(float t) {\n    return clamp((((vec3(2.68,0,0)*t+vec3(-3.42,-1.41,-2.02))*t+vec3(-.7,2.18,2.86))*t+vec3(1.75,-.12,-.32))*t+vec3(.38,.2,.35),0.,1.);\n}\nvec3 SolarColorsP(float t) {\n    return clamp(((vec3(.88,-1.16,0)*t+vec3(-2.29,1.87,.16))*t+vec3(1.97,.08,-.03))*t+vec3(.44,.01,.01),0.,1.);\n}\nvec3 CMYKColorsP(float t) {\n    return clamp((((vec3(-2.95,-8.11,-11.92)*t+vec3(2.91,8.04,21.96))*t+vec3(-2.1,1.3,-12.03))*t+vec3(2,-2.05,1.26))*t+vec3(.27,.82,.88),0.,1.);\n}\nvec3 SouthwestColorsP(float t) {\n    return clamp((((vec3(-1.65,5.87,16.25)*t+vec3(1.99,-14.14,-30.02))*t+vec3(-1.92,9.87,17.36))*t+vec3(1.45,-1.34,-2.91))*t+vec3(.43,.33,.27),0.,1.);\n}\nvec3 DeepSeaColorsP(float t) {\n    return clamp(((vec3(3.26,-1.4,0)*t+vec3(-3.94,2.65,-.74))*t+vec3(1.38,-.35,1.47))*t+vec3(.13,.02,.28),0.,1.);\n}\nvec3 StarryNightColorsP(float t) {\n    return clamp(((vec3(-1.92,-1.39,-.77)*t+vec3(2.68,1.18,-.3))*t+vec3(.07,.84,1.22))*t+vec3(.11,.15,.18),0.,1.);\n}\nvec3 FallColorsP(float t) {\n    return clamp((((vec3(0,-5,0)*t+vec3(-1.21,9.93,0))*t+vec3(1.97,-5.2,.44))*t+vec3(-.06,.67,-.54))*t+vec3(.29,.38,.38),0.,1.);\n}\nvec3 SunsetColorsP(float t) {\n    return clamp((((vec3(4.93,0,-14.8)*t+vec3(-8.68,-1.09,36.43))*t+vec3(2.56,1.85,-27.3))*t+vec3(2.25,.22,6.77))*t+vec3(-.02,.03,-.1),0.,1.);\n}\nvec3 FruitPunchColorsP(float t) {\n    return clamp((((vec3(0,3.2,-5.66)*t+vec3(.99,-4.45,7.54))*t+vec3(-.63,.35,-1.47))*t+vec3(-.39,.78,.09))*t+vec3(1.03,.49,-0),0.,1.);\n}\nvec3 ThermometerColorsP(float t) {\n    return clamp((((vec3(3.75,5.74,0)*t+vec3(-9.01,-10.57,1.63))*t+vec3(4.86,2.57,-3.87))*t+vec3(.78,2.25,1.61))*t+vec3(.15,.1,.77),0.,1.);\n}\nvec3 IslandColorsP(float t) {\n    return clamp((((vec3(7.05,0,0)*t+vec3(-18.07,0,1.42))*t+vec3(14.48,-1.38,-4.68))*t+vec3(-3.6,1.73,3.34))*t+vec3(.8,.4,.22),0.,1.);\n}\nvec3 WatermelonColorsP(float t) {\n    return clamp((((vec3(0,0,-4.28)*t+vec3(-1.21,-1.96,4.77))*t+vec3(1.21,.6,-1.17))*t+vec3(.78,1.6,.9))*t+vec3(.13,.11,.09),0.,1.);\n}\nvec3 BrassTonesP(float t) {\n    return clamp((((vec3(3.34,3.34,1.86)*t+vec3(-6.77,-6.91,-3.96))*t+vec3(1.16,1.73,1.2))*t+vec3(2.35,1.89,.93))*t+vec3(.09,.11,.03),0.,1.);\n}\nvec3 GreenPinkTonesP(float t) {\n    return clamp((((vec3(11.14,6.54,9.33)*t+vec3(-29.11,-6.8,-25.28))*t+vec3(21.17,-4.06,18.64))*t+vec3(-3.07,4.27,-2.6))*t+vec3(.08,.19,.11),0.,1.);\n}\nvec3 BrownCyanTonesP(float t) {\n    return clamp(((vec3(.97,-1.01,-1.33)*t+vec3(-3.47,-.32,.26))*t+vec3(2.52,1.78,1.77))*t+vec3(.3,.19,.07),0.,1.);\n}\nvec3 PigeonTonesP(float t) {\n    return clamp((((vec3(-4.68,-3.16,-3.96)*t+vec3(8.84,6.49,8.27))*t+vec3(-4.7,-3.97,-5.14))*t+vec3(1.36,1.5,1.65))*t+vec3(.17,.15,.19),0.,1.);\n}\nvec3 CherryTonesP(float t) {\n    return clamp(((vec3(2,0,0)*t+vec3(-4.02,1.15,1.12))*t+vec3(2.83,-.3,-.27))*t+vec3(.21,.19,.19),0.,1.);\n}\nvec3 RedBlueTonesP(float t) {\n    return clamp((((vec3(5.28,5.07,0)*t+vec3(-9.7,-11.42,-2.29))*t+vec3(3.1,5.87,1.99))*t+vec3(.99,.66,.6))*t+vec3(.46,.15,.21),0.,1.);\n}\nvec3 CoffeeTonesP(float t) {\n    return clamp((((vec3(0,0,-3.64)*t+vec3(0,.75,9.28))*t+vec3(-.31,-.86,-6.4))*t+vec3(.85,.79,1.53))*t+vec3(.43,.34,.24),0.,1.);\n}\nvec3 RustTonesP(float t) {\n    return clamp((((vec3(3.72,0,0)*t+vec3(-7.43,0,0))*t+vec3(3.71,-.49,.16))*t+vec3(1.02,.97,-.32))*t+vec3(.01,-.02,.2),0.,1.);\n}\nvec3 FuchsiaTonesP(float t) {\n    return clamp(((vec3(0,-1.11,0)*t+vec3(-.64,1.97,-.46))*t+vec3(1.55,-.04,1.38))*t+vec3(.07,.13,.07),0.,1.);\n}\nvec3 SiennaTonesP(float t) {\n    return clamp(((vec3(.93,-.8,-1.35)*t+vec3(-2.32,.94,2.5))*t+vec3(1.86,.56,-.44))*t+vec3(.44,.18,.09),0.,1.);\n}\nvec3 GrayTonesP(float t) {\n    return clamp((vec3(.39,.26,.11)*t+vec3(.47,.59,.68))*t+vec3(.1,.1,.11),0.,1.);\n}\nvec3 ValentineTonesP(float t) {\n    return clamp((vec3(-.07,.45,.3)*t+vec3(.56,.34,.44))*t+vec3(.51,.09,.18),0.,1.);\n}\nvec3 GrayYellowTonesP(float t) {\n    return clamp(((vec3(-1.57,-2.08,-3.17)*t+vec3(1.79,2.16,2.8))*t+vec3(.52,.42,.3))*t+vec3(.18,.22,.31),0.,1.);\n}\nvec3 DarkTerrainP(float t) {\n    return clamp((((vec3(0,2.38,4.4)*t+vec3(4.05,1.4,-3.2))*t+vec3(-5.9,-5.75,-1.04))*t+vec3(2.92,3,.48))*t+vec3(-.04,.04,.45),0.,1.);\n}\nvec3 LightTerrainP(float t) {\n    return clamp(((vec3(-1.35,-1.85,-1.86)*t+vec3(1.98,3.21,4.13))*t+vec3(-.29,-1.25,-2.23))*t+vec3(.54,.78,.86),0.,1.);\n}\nvec3 GreenBrownTerrainP(float t) {\n    return clamp((((vec3(5.66,6.03,0)*t+vec3(-9.79,-7.78,5.38))*t+vec3(4.02,.54,-7.66))*t+vec3(1.13,2.27,3.32))*t+vec3(-0,-.02,-.05),0.,1.);\n}\nvec3 SandyTerrainP(float t) {\n    return clamp((((vec3(3.48,4.39,0)*t+vec3(-7.65,-8.69,0))*t+vec3(3.48,3.53,-.49))*t+vec3(.27,.83,.43))*t+vec3(.68,.3,.2),0.,1.);\n}\nvec3 BrightBandsP(float t) {\n    return clamp((((vec3(-16.63,6.8,-8.13)*t+vec3(28.73,-14.81,26.66))*t+vec3(-12.13,8.23,-27.59))*t+vec3(-.11,.17,9.55))*t+vec3(.98,.23,-.04),0.,1.);\n}\nvec3 DarkBandsP(float t) {\n    return clamp((((vec3(17.15,-2.97,-5.17)*t+vec3(-33.07,6.52,5.24))*t+vec3(20.27,-3.03,2.06))*t+vec3(-3.87,-.41,-2.81))*t+vec3(.68,.81,1),0.,1.);\n}\nvec3 AquamarineP(float t) {\n    return clamp(((vec3(2.66,1.62,1.39)*t+vec3(-3.77,-2.42,-1.78))*t+vec3(1.1,.82,.41))*t+vec3(.67,.73,.84),0.,1.);\n}\nvec3 PastelP(float t) {\n    return clamp((((vec3(0,0,-6.39)*t+vec3(-1.54,-1.64,11.82))*t+vec3(.75,1.3,-4.98))*t+vec3(.41,.52,-.49))*t+vec3(.77,.5,.98),0.,1.);\n}\nvec3 BlueGreenYellowP(float t) {\n    return clamp((vec3(1.4,-.82,-.63)*t+vec3(-.63,1.69,.52))*t+vec3(.15,.01,.42),0.,1.);\n}\nvec3 RainbowP(float t) {\n    return clamp((((vec3(0,1.63,-8.06)*t+vec3(-4.42,-4.94,20.35))*t+vec3(7.09,1.89,-17.07))*t+vec3(-2.3,1.49,4.45))*t+vec3(.46,.04,.45),0.,1.);\n}\nvec3 DarkRainbowP(float t) {\n    return clamp((((vec3(2.62,6.12,-2.34)*t+vec3(-9.73,-15.58,2.43))*t+vec3(9.43,10.93,1.04))*t+vec3(-2.02,-1.77,-1.62))*t+vec3(.33,.41,.65),0.,1.);\n}\nvec3 TemperatureMapP(float t) {\n    return clamp((((vec3(5.84,0,11.29)*t+vec3(-11.36,-2.4,-19.02))*t+vec3(4.9,.36,7.83))*t+vec3(1.31,1.84,-.76))*t+vec3(.16,.28,.95),0.,1.);\n}\nvec3 LightTemperatureMapP(float t) {\n    return clamp((((vec3(4.11,0,5.78)*t+vec3(-8.72,0,-10.5))*t+vec3(4.23,-2.77,4.36))*t+vec3(1.04,2.85,-.37))*t+vec3(.18,.27,.95),0.,1.);\n}\n\n\n\/* ====================== trigonometric series color functions ====================== *\/\n\nvec3 AlpineColorsT(float x) {\n    return clamp(vec3(.39,.2,.73)+vec3(.51,.98,-.01)*x+vec3(.18,.2,.35)*cos(3.14*x+vec3(2.18,.66,2.16)),0.,1.);\n}\nvec3 LakeColorsT(float x) {\n    return clamp(vec3(.25,.14,.27)+vec3(.74,.68,.8)*x+vec3(.06,.24,.34)*cos(3.14*x+vec3(-.92,-1.93,-.83)),0.,1.);\n}\nvec3 ArmyColorsT(float x) {\n    return clamp(vec3(.37,.33,.41)+vec3(.46,.71,.32)*x+vec3(.07,.27,.17)*cos(3.14*x+vec3(.44,.44,1.14)),0.,1.);\n}\nvec3 MintColorsT(float x) {\n    return clamp(vec3(.47,.99,.64)+vec3(.44,-.38,.14)*x+vec3(.14,.09,.13)*cos(3.14*x+vec3(-1.64,-1.67,-1.61)),0.,1.);\n}\nvec3 AtlanticColorsT(float x) {\n    return clamp(vec3(1.61,.32,.41)+vec3(-2.72,.01,-.05)*x+vec3(1.55,.42,.45)*cos(3.14*x+vec3(-2.94,-2.03,-2.23))+vec3(.28,0,0)*cos(6.28*x+vec3(-1.39,0,0)),0.,1.);\n}\nvec3 NeonColorsT(float x) {\n    return clamp(vec3(.83,-.12,.53)+vec3(-.15,1.19,-.19)*x+vec3(.14,.95,.34)*cos(3.14*x+vec3(-2.51,.08,2.89))+vec3(0,.26,.12)*cos(6.28*x+vec3(0,1.26,-.8)),0.,1.);\n}\nvec3 AuroraColorsT(float x) {\n    return clamp(vec3(1.18,1.25,.02)+vec3(-.83,-2.02,.71)*x+vec3(.83,1.01,.26)*cos(3.14*x+vec3(2.62,-2.87,-1.55))+vec3(.26,0,.24)*cos(6.28*x+vec3(-2.45,0,.01)),0.,1.);\n}\nvec3 PearlColorsT(float x) {\n    return clamp(vec3(.5,.16,.07)+vec3(.94,1.11,1.27)*x+vec3(.55,.56,.54)*cos(3.14*x+vec3(.64,-.11,-.29))+vec3(0,.11,.18)*cos(6.28*x+vec3(0,.22,.31)),0.,1.);\n}\nvec3 AvocadoColorsT(float x) {\n    return clamp(vec3(.43,-.25,-.11)+vec3(.14,1.48,.44)*x+vec3(.46,.3,.1)*cos(3.14*x+vec3(2.68,-.69,.06)),0.,1.);\n}\nvec3 PlumColorsT(float x) {\n    return clamp(vec3(-.73,-.19,.45)+vec3(2.37,1.27,-.47)*x+vec3(.71,.26,.48)*cos(3.14*x+vec3(-.05,.83,-2.75)),0.,1.);\n}\nvec3 BeachColorsT(float x) {\n    return clamp(vec3(.33,.03,.54)+vec3(1.52,1.69,-.06)*x+vec3(.78,.62,.41)*cos(3.14*x+vec3(.53,.36,-2.94))+vec3(.15,.12,.12)*cos(6.28*x+vec3(3.08,3.09,-.02)),0.,1.);\n}\nvec3 RoseColorsT(float x) {\n    return clamp(vec3(.3,.43,.11)+vec3(.49,-.48,-.07)*x+vec3(.12,.37,.3)*cos(3.14*x+vec3(-1.85,-1.98,-1.72))+vec3(.11,0,0)*cos(6.28*x+vec3(3.07,0,0)),0.,1.);\n}\nvec3 CandyColorsT(float x) {\n    return clamp(vec3(-.07,.51,.8)+vec3(1.17,.04,-.38)*x+vec3(.53,.31,.45)*cos(3.14*x+vec3(-.61,3.09,-3.05)),0.,1.);\n}\nvec3 SolarColorsT(float x) {\n    return clamp(vec3(.26,.27,.06)+vec3(.95,.29,.02)*x+vec3(.31,.26,.06)*cos(3.14*x+vec3(-.87,3.01,2.45)),0.,1.);\n}\nvec3 CMYKColorsT(float x) {\n    return clamp(vec3(1.55,-1.73,1.39)+vec3(-3.03,3.26,-2.95)*x+vec3(1.77,2.22,1.53)*cos(3.14*x+vec3(-2.51,-.53,-2.35))+vec3(.22,.85,.55)*cos(6.28*x+vec3(-.72,1.03,-.21))+vec3(0,.05,.06)*cos(12.57*x+vec3(0,.11,.46)),0.,1.);\n}\nvec3 SouthwestColorsT(float x) {\n    return clamp(vec3(-1.09,.99,-.13)+vec3(2.73,-.78,2.44)*x+vec3(1.51,.53,1.46)*cos(3.14*x+vec3(-.43,3.12,.93))+vec3(.34,.14,.51)*cos(6.28*x+vec3(1.29,3.14,3.02)),0.,1.);\n}\nvec3 DeepSeaColorsT(float x) {\n    return clamp(vec3(-.6,.32,.35)+vec3(2.14,.28,.6)*x+vec3(.76,.34,.19)*cos(3.14*x+vec3(.31,2.74,-1.85)),0.,1.);\n}\nvec3 StarryNightColorsT(float x) {\n    return clamp(vec3(.54,.47,.37)+vec3(-.01,.02,-.19)*x+vec3(.43,.38,.39)*cos(3.14*x+vec3(-3.04,-2.53,-2.02)),0.,1.);\n}\nvec3 FallColorsT(float x) {\n    return clamp(vec3(.56,.27,.48)+vec3(.16,.39,-.31)*x+vec3(.27,.01,.14)*cos(3.14*x+vec3(3,2.95,2.25))+vec3(0,.12,0)*cos(6.28*x+vec3(0,.01,0)),0.,1.);\n}\nvec3 SunsetColorsT(float x) {\n    return clamp(vec3(1,.27,.14)+vec3(-.81,.5,-.07)*x+vec3(.94,.25,.67)*cos(3.14*x+vec3(-2.85,2.92,-2.58))+vec3(.25,0,.58)*cos(6.28*x+vec3(-1.98,0,-.86))+vec3(0,0,.06)*cos(12.57*x+vec3(0,0,-1.68)),0.,1.);\n}\nvec3 FruitPunchColorsT(float x) {\n    return clamp(vec3(.81,.03,.74)+vec3(.4,.75,-1.31)*x+vec3(.3,.48,.97)*cos(3.14*x+vec3(.76,-.44,-2.78))+vec3(0,0,.17)*cos(6.28*x+vec3(0,0,-.08)),0.,1.);\n}\nvec3 ThermometerColorsT(float x) {\n    return clamp(vec3(.45,-.14,.43)+vec3(-.28,.38,.1)*x+vec3(.63,.86,.5)*cos(3.14*x+vec3(-2.12,-1.34,-.76)),0.,1.);\n}\nvec3 IslandColorsT(float x) {\n    return clamp(vec3(2.03,.25,-1.17)+vec3(-2.23,.69,2.65)*x+vec3(1.09,.36,1.51)*cos(3.14*x+vec3(2.86,-1.17,-.58))+vec3(.2,0,.21)*cos(6.28*x+vec3(-2.98,0,1.09)),0.,1.);\n}\nvec3 WatermelonColorsT(float x) {\n    return clamp(vec3(.25,.42,.81)+vec3(.26,-.66,-1.54)*x+vec3(.47,.96,1.13)*cos(3.14*x+vec3(-2.17,-2.07,-2.47))+vec3(.11,.12,.17)*cos(6.28*x+vec3(.01,-.03,-.05)),0.,1.);\n}\nvec3 BrassTonesT(float x) {\n    return clamp(vec3(-1.03,-.89,.07)+vec3(2.84,2.55,-.07)*x+vec3(1.45,1.3,.38)*cos(3.14*x+vec3(-.26,-.24,-1.7))+vec3(.36,.34,0)*cos(6.28*x+vec3(2.08,2.1,0))+vec3(.08,.07,0)*cos(12.57*x+vec3(2.19,2.17,0)),0.,1.);\n}\nvec3 GreenPinkTonesT(float x) {\n    return clamp(vec3(-3.25,3.08,-3.34)+vec3(6.9,-6.12,6.89)*x+vec3(3.37,3.09,3.41)*cos(3.14*x+vec3(-.17,-2.85,-.22))+vec3(1.01,.89,.99)*cos(6.28*x+vec3(1.7,-1.51,1.61))+vec3(.11,.08,.1)*cos(12.57*x+vec3(1.25,-.96,1.12)),0.,1.);\n}\nvec3 BrownCyanTonesT(float x) {\n    return clamp(vec3(.11,.44,.38)+vec3(.45,.01,.11)*x+vec3(.53,.5,.51)*cos(3.14*x+vec3(-1.15,-2.04,-2.18)),0.,1.);\n}\nvec3 PigeonTonesT(float x) {\n    return clamp(vec3(.72,.15,.66)+vec3(-.52,.94,-.32)*x+vec3(.67,.1,.56)*cos(3.14*x+vec3(-2.92,1.13,-2.92))+vec3(.17,0,.16)*cos(6.28*x+vec3(-.69,0,-.85)),0.,1.);\n}\nvec3 CherryTonesT(float x) {\n    return clamp(vec3(-.22,.34,.36)+vec3(1.7,.51,.47)*x+vec3(.51,.31,.31)*cos(3.14*x+vec3(-.5,2.03,2.1)),0.,1.);\n}\nvec3 RedBlueTonesT(float x) {\n    return clamp(vec3(-.19,1.25,.74)+vec3(1.15,-1.86,-.7)*x+vec3(.81,1.09,.62)*cos(3.14*x+vec3(-.46,-2.73,-2.54))+vec3(.14,.16,0)*cos(6.28*x+vec3(2.33,-2.13,0)),0.,1.);\n}\nvec3 CoffeeTonesT(float x) {\n    return clamp(vec3(.31,.17,-.16)+vec3(.8,1.03,1.66)*x+vec3(.13,.18,.55)*cos(3.14*x+vec3(-.61,.39,.61)),0.,1.);\n}\nvec3 RustTonesT(float x) {\n    return clamp(vec3(.12,-.01,.19)+vec3(.96,.47,-.15)*x+vec3(.06,.12,.04)*cos(3.14*x+vec3(-1.97,-1.59,1.54))+vec3(.09,0,0)*cos(6.28*x+vec3(-3.09,0,0)),0.,1.);\n}\nvec3 FuchsiaTonesT(float x) {\n    return clamp(vec3(.21,.38,.23)+vec3(.66,.33,.63)*x+vec3(.19,.26,.16)*cos(3.14*x+vec3(-2.17,2.84,-2.4)),0.,1.);\n}\nvec3 SiennaTonesT(float x) {\n    return clamp(vec3(.24,.36,.38)+vec3(.89,.34,.12)*x+vec3(.3,.19,.32)*cos(3.14*x+vec3(-.82,-2.8,2.77)),0.,1.);\n}\nvec3 GrayTonesT(float x) {\n    return clamp(vec3(.2,.16,.11)+vec3(.65,.74,.79)*x+vec3(.13,.08,.03)*cos(3.14*x+vec3(2.31,2.16,1.59)),0.,1.);\n}\nvec3 ValentineTonesT(float x) {\n    return clamp(vec3(.63,.28,.38)+vec3(.23,.41,.34)*x+vec3(.11,.19,.18)*cos(3.14*x+vec3(-2.98,2.54,2.73)),0.,1.);\n}\nvec3 GrayYellowTonesT(float x) {\n    return clamp(vec3(.53,.69,1.04)+vec3(.05,-.41,-1.48)*x+vec3(.38,.52,.85)*cos(3.14*x+vec3(-2.77,-2.68,-2.55)),0.,1.);\n}\nvec3 DarkTerrainT(float x) {\n    return clamp(vec3(-.93,-.95,-.09)+vec3(2.85,3.2,2.08)*x+vec3(.9,1.14,1.11)*cos(3.14*x+vec3(.04,.27,.83))+vec3(0,.1,.21)*cos(6.28*x+vec3(0,-2.62,-2.66)),0.,1.);\n}\nvec3 LightTerrainT(float x) {\n    return clamp(vec3(.84,1.18,1.26)+vec3(-.25,-.71,-.79)*x+vec3(.3,.42,.52)*cos(3.14*x+vec3(-3.1,2.89,2.48)),0.,1.);\n}\nvec3 GreenBrownTerrainT(float x) {\n    return clamp(vec3(-.46,-.72,-1.24)+vec3(2.2,2.76,3.41)*x+vec3(.59,.88,1.2)*cos(3.14*x+vec3(.15,.19,.08))+vec3(.15,.16,0)*cos(6.28*x+vec3(2.83,-3.03,0)),0.,1.);\n}\nvec3 SandyTerrainT(float x) {\n    return clamp(vec3(-.27,.24,.14)+vec3(1.57,.1,.09)*x+vec3(1.03,.48,.13)*cos(3.14*x+vec3(-.38,-1.53,-1.11))+vec3(.22,0,0)*cos(6.28*x+vec3(1.79,0,0)),0.,1.);\n}\nvec3 BrightBandsT(float x) {\n    return clamp(vec3(-10.69,-13.44,-14.93)+vec3(23.11,28.36,31.5)*x+vec3(11.44,13.75,15.46)*cos(3.14*x+vec3(.02,0,.02))+vec3(2.54,2.84,2.76)*cos(6.28*x+vec3(1.49,1.66,1.68))+vec3(.2,.19,.36)*cos(12.57*x+vec3(1.91,1.75,2.05)),0.,1.);\n}\nvec3 DarkBandsT(float x) {\n    return clamp(vec3(19.05,22.62,-12.71)+vec3(-36.56,-43.6,26.79)*x+vec3(18.26,21.63,13.6)*cos(3.14*x+vec3(3.13,3.13,.01))+vec3(3.78,4.47,3.04)*cos(6.28*x+vec3(-1.6,-1.56,1.56))+vec3(.32,.41,.31)*cos(12.57*x+vec3(-1.2,-1.57,1.66)),0.,1.);\n}\nvec3 AquamarineT(float x) {\n    return clamp(vec3(.08,.37,.54)+vec3(1.16,.74,.63)*x+vec3(.59,.36,.32)*cos(3.14*x+vec3(.09,.01,.23)),0.,1.);\n}\nvec3 PastelT(float x) {\n    return clamp(vec3(1.13,.89,-1.28)+vec3(-1.06,-.57,3.61)*x+vec3(.51,.47,1.84)*cos(3.14*x+vec3(-2.31,-2.49,-.2))+vec3(0,0,.54)*cos(6.28*x+vec3(0,0,.87))+vec3(0,0,.07)*cos(12.57*x+vec3(0,0,.6)),0.,1.);\n}\nvec3 BlueGreenYellowT(float x) {\n    return clamp(vec3(.01,-.09,.22)+vec3(1,1.09,.31)*x+vec3(.35,.22,.23)*cos(3.14*x+vec3(1.29,-1.14,-.72)),0.,1.);\n}\nvec3 RainbowT(float x) {\n    return clamp(vec3(1.42,1.64,-.15)+vec3(-1.57,-3.2,.38)*x+vec3(.99,1.76,.77)*cos(3.14*x+vec3(3.03,-2.71,-1.05))+vec3(0,.24,.28)*cos(6.28*x+vec3(0,-1.44,-.39)),0.,1.);\n}\nvec3 DarkRainbowT(float x) {\n    return clamp(vec3(-2.48,-1.09,-1.47)+vec3(6.03,3.61,3.66)*x+vec3(2.74,1.88,2)*cos(3.14*x+vec3(-.01,.18,.02))+vec3(.73,.6,.49)*cos(6.28*x+vec3(1.65,2.19,1.47))+vec3(0,.06,0)*cos(12.57*x+vec3(0,-2.77,0)),0.,1.);\n}\nvec3 TemperatureMapT(float x) {\n    return clamp(vec3(1.23,.85,2.05)+vec3(-1.23,-1.25,-3.22)*x+vec3(.96,.95,1.27)*cos(3.14*x+vec3(-2.87,-2.17,-2.84))+vec3(.23,0,.39)*cos(6.28*x+vec3(-2.13,0,-1.56))+vec3(0,0,.09)*cos(12.57*x+vec3(0,0,-.03)),0.,1.);\n}\nvec3 LightTemperatureMapT(float x) {\n    return clamp(vec3(-.33,.27,1.48)+vec3(1.85,.15,-1.54)*x+vec3(.62,.67,.39)*cos(3.14*x+vec3(-.42,-1.52,-3.01))+vec3(.15,0,.18)*cos(6.28*x+vec3(2.12,0,-2.43)),0.,1.);\n}\n\n\n\/* ====================== cosine color plaettes ====================== *\/\n\nvec3 AlpineColorsC(float t) {\n    return clamp(vec3(.34,.26,.43)+vec3(.56,.75,.3)*t+vec3(.15,.09,.17)*cos(vec3(3.47,4.56,4.86)*t+vec3(1.97,.16,1.11)),0.,1.);\n}\nvec3 LakeColorsC(float t) {\n    return clamp(vec3(.25,.13,.34)+vec3(.73,.67,.73)*t+vec3(.06,.25,.3)*cos(vec3(3.28,3.07,3.36)*t+vec3(-1,-1.9,-.98)),0.,1.);\n}\nvec3 ArmyColorsC(float t) {\n    return clamp(vec3(.43,.43,.89)+vec3(.3,.43,2.69)*t+vec3(.02,.14,3.54)*cos(vec3(12.93,4.13,.85)*t+vec3(.41,.06,1.68)),0.,1.);\n}\nvec3 MintColorsC(float t) {\n    return clamp(vec3(-.97,.7,.07)+vec3(.09,-.49,.08)*t+vec3(1.81,.45,.74)*cos(vec3(.82,1.32,1.24)*t+vec3(-.67,-.9,-.7)),0.,1.);\n}\nvec3 AtlanticColorsC(float t) {\n    return clamp(vec3(-.36,.31,.46)+vec3(-4.38,-.07,-.51)*t+vec3(7.37,.48,.75)*cos(vec3(.73,2.92,2.48)*t+vec3(-1.51,-1.96,-2.03)),0.,1.);\n}\nvec3 NeonColorsC(float t) {\n    return clamp(vec3(.77,.83,.14)+vec3(.07,-.79,.51)*t+vec3(.04,.14,.13)*cos(vec3(5.93,5.94,5.69)*t+vec3(2.73,.76,.06)),0.,1.);\n}\nvec3 AuroraColorsC(float t) {\n    return clamp(vec3(.21,.51,.17)+vec3(.59,-.23,.7)*t+vec3(.05,.28,.12)*cos(vec3(10.52,5.46,7.58)*t+vec3(1.43,2.47,-.64)),0.,1.);\n}\nvec3 PearlColorsC(float t) {\n    return clamp(vec3(.72,.78,.71)+vec3(.13,-.07,.15)*t+vec3(.2,.11,.11)*cos(vec3(5.4,6.57,7.19)*t+vec3(-.18,-.89,-.77)),0.,1.);\n}\nvec3 AvocadoColorsC(float t) {\n    return clamp(vec3(.65,-.68,-.01)+vec3(-.2,2.05,.25)*t+vec3(.65,.66,.02)*cos(vec3(2.76,2.28,5.9)*t+vec3(2.92,-.1,-1.25)),0.,1.);\n}\nvec3 PlumColorsC(float t) {\n    return clamp(vec3(-1.02,-2.84,2.04)+vec3(2.94,17.04,-4.71)*t+vec3(1.01,30.48,3.86)*cos(vec3(2.77,.544,1.48)*t+vec3(.15,1.478,-2.12)),0.,1.);\n}\nvec3 BeachColorsC(float t) {\n    return clamp(vec3(-40.16,.56,.15)+vec3(87.82,.36,.8)*t+vec3(202.13,.08,.1)*cos(vec3(.4371,7.61,6.82)*t+vec3(1.3668,-2.56,.38)),0.,1.);\n}\nvec3 RoseColorsC(float t) {\n    return clamp(vec3(.32,.48,.22)+vec3(.54,-.21,0)*t+vec3(.17,.17,.16)*cos(vec3(5.63,5.38,4.87)*t+vec3(-2.92,-2.92,-2.52)),0.,1.);\n}\nvec3 CandyColorsC(float t) {\n    return clamp(vec3(.43,19.47,.48)+vec3(.47,-36.59,.3)*t+vec3(.21,79.3,.17)*cos(vec3(4.93,.474,4.66)*t+vec3(-1.75,-1.816,2.53)),0.,1.);\n}\nvec3 SolarColorsC(float t) {\n    return clamp(vec3(-.33,.03,.17)+vec3(1.62,.73,-.13)*t+vec3(.78,.08,.16)*cos(vec3(2.09,5.13,2.13)*t+vec3(-.13,1.92,3.14)),0.,1.);\n}\nvec3 CMYKColorsC(float t) {\n    return clamp(vec3(21.34,.96,.86)+vec3(-109.66,-.7,-.54)*t+vec3(274.8,.36,.1)*cos(vec3(.4044,6.26,9.08)*t+vec3(-1.6474,1.69,-1.02)),0.,1.);\n}\nvec3 SouthwestColorsC(float t) {\n    return clamp(vec3(2.15,.44,.17)+vec3(-26.75,.3,.38)*t+vec3(51.14,.17,.12)*cos(vec3(.542,6.24,11.28)*t+vec3(-1.604,2.53,1.02)),0.,1.);\n}\nvec3 DeepSeaColorsC(float t) {\n    return clamp(vec3(-.45,.39,.22)+vec3(1.77,.17,.37)*t+vec3(.59,.4,.47)*cos(vec3(3.48,2.95,1.93)*t+vec3(.17,2.86,-1.41)),0.,1.);\n}\nvec3 StarryNightColorsC(float t) {\n    return clamp(vec3(.19,.49,.39)+vec3(.74,-.07,-.02)*t+vec3(.12,.43,.27)*cos(vec3(5.25,2.99,3.94)*t+vec3(2.27,-2.48,-2.33)),0.,1.);\n}\nvec3 FallColorsC(float t) {\n    return clamp(vec3(.21,.26,6.5)+vec3(.81,.4,-7.17)*t+vec3(.04,.12,12.76)*cos(vec3(8.62,6.28,.571)*t+vec3(-.26,.02,-2.069)),0.,1.);\n}\nvec3 SunsetColorsC(float t) {\n    return clamp(vec3(.14,-.05,-.07)+vec3(1.15,1.07,.73)*t+vec3(.27,.04,.32)*cos(vec3(5.06,7.88,7.07)*t+vec3(-2.21,.1,-1.2)),0.,1.);\n}\nvec3 FruitPunchColorsC(float t) {\n    return clamp(vec3(.89,.57,-.04)+vec3(-.02,-.09,.68)*t+vec3(.11,.14,.14)*cos(vec3(5.77,5.77,6.99)*t+vec3(-.21,-2.09,1.02)),0.,1.);\n}\nvec3 ThermometerColorsC(float t) {\n    return clamp(vec3(.45,.28,.46)+vec3(.12,.14,.05)*t+vec3(.39,.55,.48)*cos(vec3(4.18,4.18,3.22)*t+vec3(-2.51,-1.92,-.81)),0.,1.);\n}\nvec3 IslandColorsC(float t) {\n    return clamp(vec3(.67,-8.59,-35.37)+vec3(.12,8,32.87)*t+vec3(.14,12.2,68.16)*cos(vec3(7.54,.712,.508)*t+vec3(1.45,.746,1.022)),0.,1.);\n}\nvec3 WatermelonColorsC(float t) {\n    return clamp(vec3(8.38,6.22,80.01)+vec3(-23.7,-56.24,-209.12)*t+vec3(45.9,127.22,639.31)*cos(vec3(.542,.4551,.3292)*t+vec3(-1.752,-1.6188,-1.696)),0.,1.);\n}\nvec3 BrassTonesC(float t) {\n    return clamp(vec3(.16,.24,.12)+vec3(.07,0,-.04)*t+vec3(.73,.6,.31)*cos(vec3(3.31,3.49,3.55)*t+vec3(-1.67,-1.8,-1.89)),0.,1.);\n}\nvec3 GreenPinkTonesC(float t) {\n    return clamp(vec3(.53,.21,.6)+vec3(-.05,.51,-.21)*t+vec3(.55,.62,.57)*cos(vec3(5.5,4.82,5.27)*t+vec3(2.78,-1.55,2.86)),0.,1.);\n}\nvec3 BrownCyanTonesC(float t) {\n    return clamp(vec3(.2,-1.14,.59)+vec3(.37,-14.82,-3.1)*t+vec3(.47,26.53,3.44)*cos(vec3(3.37,.626,1.41)*t+vec3(-1.29,-1.521,-1.72)),0.,1.);\n}\nvec3 PigeonTonesC(float t) {\n    return clamp(vec3(.12,.13,.17)+vec3(.86,.84,.79)*t+vec3(.06,.04,.06)*cos(vec3(7.66,7.9,7.72)*t+vec3(-.48,-.99,-.96)),0.,1.);\n}\nvec3 CherryTonesC(float t) {\n    return clamp(vec3(-33.95,11.9,13.78)+vec3(52.15,-9.82,-12.63)*t+vec3(107.83,19.47,25.21)*cos(vec3(.4822,.588,.562)*t+vec3(1.2484,-2.214,-2.139)),0.,1.);\n}\nvec3 RedBlueTonesC(float t) {\n    return clamp(vec3(.65,.46,.91)+vec3(-.25,.01,-1.3)*t+vec3(.33,.39,.96)*cos(vec3(4.74,4.49,2.62)*t+vec3(-2.17,-2.54,-2.37)),0.,1.);\n}\nvec3 CoffeeTonesC(float t) {\n    return clamp(vec3(-2.68,.32,.06)+vec3(4.95,.64,.86)*t+vec3(5.69,.04,.2)*cos(vec3(.8,7.86,5.28)*t+vec3(1,-1.39,-.16)),0.,1.);\n}\nvec3 RustTonesC(float t) {\n    return clamp(vec3(.12,.06,.17)+vec3(1.02,.47,-.16)*t+vec3(.12,.06,.02)*cos(vec3(5.86,5.84,5.85)*t+vec3(-2.93,-2.93,.2)),0.,1.);\n}\nvec3 FuchsiaTonesC(float t) {\n    return clamp(vec3(.39,.03,1.44)+vec3(-3.14,.91,-4.92)*t+vec3(5.33,.05,8.11)*cos(vec3(.83,7.86,.75)*t+vec3(-1.63,-.06,-1.74)),0.,1.);\n}\nvec3 SiennaTonesC(float t) {\n    return clamp(vec3(-.41,.33,.4)+vec3(1.68,.42,.09)*t+vec3(.86,.15,.34)*cos(vec3(2.03,3.42,3.09)*t+vec3(-.04,-2.91,2.8)),0.,1.);\n}\nvec3 GrayTonesC(float t) {\n    return clamp(vec3(.04,.06,.09)+vec3(.84,.84,.79)*t+vec3(.04,.03,.02)*cos(vec3(7.06,7.43,9)*t+vec3(-.08,-.36,-1.35)),0.,1.);\n}\nvec3 ValentineTonesC(float t) {\n    return clamp(vec3(2.39,.14,.17)+vec3(-3.68,.6,.66)*t+vec3(5.19,.1,.05)*cos(vec3(.82,4.26,5.68)*t+vec3(-1.94,1.82,1.15)),0.,1.);\n}\nvec3 GrayYellowTonesC(float t) {\n    return clamp(vec3(.6,22,40.32)+vec3(-.13,-61.93,-135.25)*t+vec3(.47,141.55,364.05)*cos(vec3(2.89,.4457,.3746)*t+vec3(-2.67,-1.7253,-1.6809)),0.,1.);\n}\nvec3 DarkTerrainC(float t) {\n    return clamp(vec3(-119.59,-5.32,-180.09)+vec3(246.86,12.06,452.81)*t+vec3(786.34,7.19,1665.28)*cos(vec3(.3139,1.75,.27247)*t+vec3(1.4182,.74,1.4622)),0.,1.);\n}\nvec3 LightTerrainC(float t) {\n    return clamp(vec3(.59,27.29,39.02)+vec3(.26,-45.82,-51.94)*t+vec3(.09,94.81,114.12)*cos(vec3(5.12,.49,.4623)*t+vec3(2.23,-1.854,-1.9117)),0.,1.);\n}\nvec3 GreenBrownTerrainC(float t) {\n    return clamp(vec3(.12,.12,-205.56)+vec3(.95,.88,434.26)*t+vec3(.12,.18,1593.1)*cos(vec3(6.76,6.8,.27279)*t+vec3(-2.89,-2.34,1.44143)),0.,1.);\n}\nvec3 SandyTerrainC(float t) {\n    return clamp(vec3(.9,.48,.26)+vec3(-.54,.07,-.03)*t+vec3(.32,.27,.06)*cos(vec3(4.28,4.7,5.68)*t+vec3(-2.37,-2.32,-2.62)),0.,1.);\n}\nvec3 BrightBandsC(float t) {\n    return clamp(vec3(.63,.52,-577.52)+vec3(.13,.31,1052.6)*t+vec3(.31,.29,4334.34)*cos(vec3(7.39,5.46,.24336)*t+vec3(-.03,-3.02,1.43714)),0.,1.);\n}\nvec3 DarkBandsC(float t) {\n    return clamp(vec3(.52,.62,1.08)+vec3(.31,.21,-.98)*t+vec3(.15,.26,.35)*cos(vec3(11.59,4.3,5.11)*t+vec3(.78,.76,1.76)),0.,1.);\n}\nvec3 AquamarineC(float t) {\n    return clamp(vec3(-.3,.26,-.2)+vec3(1.96,.95,2.36)*t+vec3(1.04,.47,1.51)*cos(vec3(2.57,2.85,1.8)*t+vec3(.36,.15,.8)),0.,1.);\n}\nvec3 PastelC(float t) {\n    return clamp(vec3(5.99,1.69,.81)+vec3(-30.91,-3.63,-.07)*t+vec3(57.32,2.89,.22)*cos(vec3(.549,1.56,5.58)*t+vec3(-1.662,-1.99,.59)),0.,1.);\n}\nvec3 BlueGreenYellowC(float t) {\n    return clamp(vec3(2.08,-.47,-1.06)+vec3(4.68,1.41,1.97)*t+vec3(6.45,.5,1.61)*cos(vec3(.82,2.07,1.48)*t+vec3(1.88,-.42,.45)),0.,1.);\n}\nvec3 RainbowC(float t) {\n    return clamp(vec3(132.23,.39,-142.83)+vec3(-245.97,-1.4,270.69)*t+vec3(755.63,1.32,891.31)*cos(vec3(.3275,2.39,.3053)*t+vec3(-1.7461,-1.84,1.4092)),0.,1.);\n}\nvec3 DarkRainbowC(float t) {\n    return clamp(vec3(.25,.65,.52)+vec3(.64,-.34,-.4)*t+vec3(.16,.28,.11)*cos(vec3(7.89,5.83,6.93)*t+vec3(1.19,2.69,.6)),0.,1.);\n}\nvec3 TemperatureMapC(float t) {\n    return clamp(vec3(.37,.89,1.18)+vec3(.71,-2.12,-.94)*t+vec3(.26,1.56,.2)*cos(vec3(5.2,2.48,8.03)*t+vec3(-2.51,-1.96,2.87)),0.,1.);\n}\nvec3 LightTemperatureMapC(float t) {\n    return clamp(vec3(.38,-5.49,1.11)+vec3(.62,.96,-.73)*t+vec3(.24,6.09,.17)*cos(vec3(4.9,.97,6.07)*t+vec3(-2.61,-.33,-2.74)),0.,1.);\n}\n\n\n\/* ====================== main ====================== *\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (vec2(0,1)-(fragCoord\/iResolution.xy))*vec2(-4, 13);\n    int i = int(uv.x)*13+int(uv.y);\n    float t = fract(uv.x);\n    vec3 col = vec3(0);\n    \/\/ align them so one can Alt+select to change the suffix\n    if (i== 0) col=        AlpineColorsP(t);\n    if (i== 1) col=          LakeColorsP(t);\n    if (i== 2) col=          ArmyColorsP(t);\n    if (i== 3) col=          MintColorsP(t);\n    if (i== 4) col=      AtlanticColorsP(t);\n    if (i== 5) col=          NeonColorsP(t);\n    if (i== 6) col=        AuroraColorsP(t);\n    if (i== 7) col=         PearlColorsP(t);\n    if (i== 8) col=       AvocadoColorsP(t);\n    if (i== 9) col=          PlumColorsP(t);\n    if (i==10) col=         BeachColorsP(t);\n    if (i==11) col=          RoseColorsP(t);\n    if (i==12) col=         CandyColorsP(t);\n    if (i==13) col=         SolarColorsP(t);\n    if (i==14) col=          CMYKColorsP(t);\n    if (i==15) col=     SouthwestColorsP(t);\n    if (i==16) col=       DeepSeaColorsP(t);\n    if (i==17) col=   StarryNightColorsP(t);\n    if (i==18) col=          FallColorsP(t);\n    if (i==19) col=        SunsetColorsP(t);\n    if (i==20) col=    FruitPunchColorsP(t);\n    if (i==21) col=   ThermometerColorsP(t);\n    if (i==22) col=        IslandColorsP(t);\n    if (i==23) col=    WatermelonColorsP(t);\n    if (i==24) col=          BrassTonesP(t);\n    if (i==25) col=      GreenPinkTonesP(t);\n    if (i==26) col=      BrownCyanTonesP(t);\n    if (i==27) col=         PigeonTonesP(t);\n    if (i==28) col=         CherryTonesP(t);\n    if (i==29) col=        RedBlueTonesP(t);\n    if (i==30) col=         CoffeeTonesP(t);\n    if (i==31) col=           RustTonesP(t);\n    if (i==32) col=        FuchsiaTonesP(t);\n    if (i==33) col=         SiennaTonesP(t);\n    if (i==34) col=           GrayTonesP(t);\n    if (i==35) col=      ValentineTonesP(t);\n    if (i==36) col=     GrayYellowTonesP(t);\n    if (i==37) col=         DarkTerrainP(t);\n    if (i==38) col=        LightTerrainP(t);\n    if (i==39) col=   GreenBrownTerrainP(t);\n    if (i==40) col=        SandyTerrainP(t);\n    if (i==41) col=         BrightBandsP(t);\n    if (i==42) col=           DarkBandsP(t);\n    if (i==43) col=          AquamarineP(t);\n    if (i==44) col=              PastelP(t);\n    if (i==45) col=     BlueGreenYellowP(t);\n    if (i==46) col=             RainbowP(t);\n    if (i==47) col=         DarkRainbowP(t);\n    if (i==48) col=      TemperatureMapP(t);\n    if (i==49) col= LightTemperatureMapP(t);\n    fragColor = vec4(col, 0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Nd33zB","date":"1630026712","viewed":223,"name":"Natural RYB Color Wheel","username":"harry7557558","description":"The idea comes from a picture on my art teacher's color theory intro slide.\nIgnore my terrible tracing skill.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["color","space","rgb","wheel","ryb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Desmos version:\n\/\/ https:\/\/www.desmos.com\/calculator\/w4thzt4ofr\n\n#define PI 3.1415926\n\n\/\/ RYB\/RGB\n#define RYB 1\n\n\/\/ smoothed color gradient or not\n#define SMOOTH 0\n\n\n\/\/ Color space conversion\n\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1.\/6.) return mix(p, q, 6. * t);\n    if (t < 1.\/2.) return q;\n    if (t < 2.\/3.) return mix(p, q, (2.\/3. - t) * 6.);\n    return p;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1.\/3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1.\/3.)\n    );\n}\n\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n\n\/\/ Mask layer - please ignore my terrible tracing skill\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0., 1.);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat mask(float x, float y) {\n    float head = smax(x+0.25*y-0.65, -0.27*x+y-0.94-0.01*cos(3.0*x), 0.6); \/\/ head back\n    float face = -x-0.08*y-0.6 + 0.03*cos(6.0*y-1.0);  \/\/ face\n    face -= -0.2+0.2*tanh(18.0*(y+0.4)) + 0.1*exp(-3.0*y-2.2); \/\/ chin\/neck\n    face -= 0.04*exp(-100.0*(y-0.1)*y)*(0.8-x+10.0*y);  \/\/ nose\n    face -= 0.03*sin(40.0*(y-0.03))*exp(-100.0*y*y);  \/\/ mouth\n    float d = smax(head, face, 0.2);\n    d = smax(d, 0.3*x-y-0.87 - 0.1*x*x, 0.05);  \/\/ bottom\n    float back = x+0.7*y+0.05 - 0.1*exp(-3.0*y-2.2);  \/\/ bottom-right block\n    back = smax(-back, -0.6*x+y+0.72-0.05*sin(8.0*x), 0.02);\n    d = smax(d, -back, 0.02);\n    return d;\n}\n\n\n\/\/ Noise\n\nvec2 hash22(vec2 p) {\n    \/\/ from David Hoskins's https:\/\/www.shadertoy.com\/view\/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SimplexNoise(vec2 xy) {\n    const float K1 = 0.3660254038;  \/\/ (sqrt(3)-1)\/2\n    const float K2 = 0.2113248654;  \/\/ (-sqrt(3)+3)\/6\n    vec2 p = xy + (xy.x + xy.y)*K1;\n    vec2 i = floor(p);\n    vec2 f1 = xy - (i - (i.x + i.y)*K2);\n    vec2 s = f1.x < f1.y ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 f2 = f1 - s + K2;\n    vec2 f3 = f1 - 1.0 + 2.0*K2;\n    vec2 n1 = 2.0 * hash22(i) - 1.0;\n    vec2 n2 = 2.0 * hash22(i + s) - 1.0;\n    vec2 n3 = 2.0 * hash22(i + 1.0) - 1.0;\n    vec3 v = vec3(dot(f1, n1), dot(f2, n2), dot(f3, n3));\n    vec3 w = max(-vec3(dot(f1, f1), dot(f2, f2), dot(f3, f3)) + 0.5, vec3(0.0));\n    return dot((w*w*w*w) * v, vec3(32.0));\n}\n\n\n\/\/ Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ Cartesian coordinate\n    vec2 pos = 2.0 * fragCoord\/iResolution.xy - 1.0;\n    pos *= iResolution.xy \/ min(iResolution.x, iResolution.y);\n\n    \/\/ polar coordinate\n    vec2 p = pos - vec2(-0.0, 0.15);\n    float r = length(p);\n    float a = atan(p.x, p.y) \/ (2.0*PI);\n    if (a < 0.0) a += 1.0;\n\n    \/\/ color\n    float noise = SimplexNoise(vec2(40.0*a, 8.0*sqrt(r)));\n#if !SMOOTH\n    a = round(12.0*a)\/12.0;\n    r = round(3.0*r)\/3.0;\n#endif\n    vec3 col = hsl2rgb(a, 1.0, (1.0-0.1*noise)*(1.0-0.8*exp(-0.8*r)));\n#if RYB\n    col = ryb2rgb(col);\n#endif\n\n    \/\/ apply mask\n    float m = mask(pos.x, pos.y);\n    if (m > 0.0) col = vec3(1.0);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"sdVGWh","date":"1631492623","viewed":442,"name":"Nautilus Shell","username":"harry7557558","description":"My first attempt to model a sea snail with a spiral. Should note that a nautilus is classified as a cephalopod so it's technically not a snail.\n\nThanks this visualizer for helping me debug the SDF: https:\/\/www.shadertoy.com\/view\/ssKGWR","likes":50,"published":3,"flags":0,"usePreview":0,"tags":["spiral","logarithmic","interior","beach","nautilus","seashell","conch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ I have always been facinated with seashells.\n\n\/\/ Nautilus is probably the most mathematical one \n\/\/ to get my seashell shader journey started.\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\nvec2 cut;  \/\/ when modeling the nautilus, cut z<cut.x and z>cut.y to show its interior\n\n\n\/\/ calculate the signed distance and color of the nautilus shell\n\/\/ this function calculates color only when @req_color is true\nfloat mapShell(in vec3 p, out vec3 col, bool req_color) {\n    p -= vec3(0.7, 0, 0);\n\n    \/\/ r=exp(b*\u03b8)\n    const float b = 0.17;\n\n    \/\/ Catesian to cylindrical\n    float r = length(p.xy);  \/\/ r\n    float a = mix(0.0, 0.45, smoothstep(0.0, 1.0, 0.5*(r-0.6)));  \/\/ rotate by this angle\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;  \/\/ rotation\n    float t = atan(p.y, p.x);  \/\/ \u03b8\n\n    \/\/ shell opening, kill discontinuities of the spiral\n    float ro = exp(b*PI);  \/\/ center of the \"ring\"\n    float d = length(vec2(length(p.xz-vec2(-ro,0))-ro,p.y));  \/\/ distance to the \"ring\"\n    float u = t, dx = r-ro, dy = p.z;  \/\/ longitude and two numbers to determine latitude\n\n    \/\/ spiral\n    \/\/ r(n) = exp(b*(2.*PI*n+t)), (x-r)^2+y^2=r^2, solve for n\n    float n = (log((r*r+p.z*p.z)\/(2.*r))\/b-t)\/(2.0*PI);  \/\/ decimal n\n    n = min(n, 0.0);  \/\/ clamp to opening\n    float n0 = floor(n), n1 = ceil(n);  \/\/ test two boundaries\n    float r0 = exp(b*(2.*PI*n0+t)), r1 = exp(b*(2.*PI*n1+t));  \/\/ two r\n    float d0 = abs(length(vec2(r-r0,p.z))-r0);  \/\/ distance to inner\n    float d1 = abs(length(vec2(r-r1,p.z))-r1);  \/\/ distance to outer\n    if (d0 < d) d = d0, u = 2.*PI*n0+t, dx = r-r0, dy = p.z;  \/\/ update distance\n    if (d1 < d) d = d1, u = 2.*PI*n1+t, dx = r-r1, dy = p.z;  \/\/ update distance\n\n    \/\/ septa\/chambers\n    const float f = 2.4;  \/\/ \"frequency\" of chambers\n    float s0 = t + 2.0*PI*(n0+0.5);  \/\/ longitude parameter\n    float v = fract(n);  \/\/ 0-1, distance from inner circle\n    float s = f*s0 + 1.0*pow(0.25-(v-0.5)*(v-0.5), 0.5)+0.5*v;  \/\/ curve of septa\n    s += pow(min(1.0\/(40.0*length(vec2(v-0.5,p.z))+1.0), 0.5), 2.0);  \/\/ hole on septa\n    float sf = fract(s);  \/\/ periodic\n    sf = s0>-1.8 ? abs(s+3.25) :  \/\/ outer-most septa, possibly cause discontinuities\n         min(sf, 1.0-sf);  \/\/ inner septa\n    float w = sf\/f*exp(b*(s0+PI));  \/\/ adjust distance field\n    if (length(p*vec3(1,1,1.5))<3.0)  \/\/ prevent outer discontinuity\n        d = min(d, 0.5*w+0.012);  \/\/ union chambers\n\n    d += 0.00012*r*sin(200.*u);  \/\/ geometric texture\n    d = abs(d)-0.8*max(0.02*pow(r,0.4),0.02);  \/\/ thickness of shell\n    d = max(d, max(cut.x-p.z,p.z-cut.y));  \/\/ cut it open\n    if (!req_color) return d;  \/\/ distance calculation finished\n\n    \/\/ color\n    v = atan(dy, dx);  \/\/ latitude parameter\n    w = length(vec2(dx,dy)) \/ exp(b*u);  \/\/ section radius parameter\n    for (float i=0.;i<6.;i+=1.) {  \/\/ distort the parameters\n        float f = pow(2., i);\n        float du = 0.15\/f*sin(f*u)*cos(f*v);\n        float dv = 0.15\/f*cos(f*u)*sin(f*v);\n        u+=du, v+=dv;\n    }\n    float f1 = cos(50.*u);  \/\/ middle stripes\n    float f2 = cos(21.3*u)+0.1;  \/\/ side stripes\n    float tex = mix(f1, f2, 0.5-0.5*tanh(1.0-3.0*sin(v)*sin(v)))  \/\/ blend stripes\n         + 0.5-0.6*cos(v);  \/\/ fading at sides\n    tex += 0.5+0.5*tanh(4.0*(u-2.0));  \/\/ fading near opening\n    col = n==0.0 ? vec3(0.9,0.85,0.8) : vec3(0.95,0.85,0.7);  \/\/ base color, outer and inner\n    if (w>1.0 && w<1.1)  \/\/ on the surface of the shell\n        col = (u-0.3*cos(v)<-2.6 ? 1.0-0.6*min(exp(2.+0.5*u),1.0) : 1.0)  \/\/ black inside the opening\n            * mix(vec3(0.6,0.3,0.2), col, clamp(8.0*tex+0.5,0.,1.));  \/\/ apply stripes\n\n    return d;\n}\n\n\/\/ calculate the signed distance and color of the scene\nfloat map(in vec3 p, out vec3 col, bool req_color) {\n    vec3 shell_col;\n    float shell_d = mapShell(p.yzx, shell_col, req_color);  \/\/ call mapShell\n    float beach_d = p.z+1.5;  \/\/ beach surface: z=-1.5\n    beach_d += 0.001*sin(20.0*p.x)*sin(20.0*p.y) + 0.0005*(sin(51.0*p.x)+sin(50.0*p.y));  \/\/ deform the surface of the beach\n    vec3 beach_col = vec3(0.95,0.8,0.5);  \/\/ color of the beach\n    float d = min(shell_d, beach_d);  \/\/ final signed distance\n    if (d==shell_d) col = shell_col;  \/\/ closer to nautilus shell\n    else col = beach_col;  \/\/ closer to beach\n    return d;\n}\n\n\/\/ calculate signed distance only\nfloat mapDist(vec3 p) {\n    vec3 col;\n    return map(p, col, false);\n}\n\n\/\/ numerical gradient of the SDF\nvec3 mapGrad(vec3 p) {\n    const float e = 0.001;\n\tfloat a = mapDist(p+vec3(e,e,e));\n\tfloat b = mapDist(p+vec3(e,-e,-e));\n\tfloat c = mapDist(p+vec3(-e,e,-e));\n\tfloat d = mapDist(p+vec3(-e,-e,e));\n\treturn (.25\/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\/\/ \"standard\" raymarching\nbool raymarch(vec3 ro, vec3 rd, inout float t, float t1, float step_size, float eps) {\n    for (int i=int(ZERO); i<100; i++) {\n        float dt = step_size*mapDist(ro+rd*t);\n        t += dt;\n        if (abs(dt) < eps) break;\n        if (t > t1) return false;\n    }\n    return true;\n}\n\n\/\/ soft shadow - https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcShadow(vec3 ro, vec3 rd) {\n    float sh = 1.;\n    float t = 0.1;\n    for (int i = int(ZERO); i<20; i++){\n        float h = mapDist(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 4.0*h\/t));\n        t += clamp(h, 0.1, 0.3);\n        if (h<0. || t>8.0) break; \n    }\n    return max(sh, 0.);\n}\n\n\/\/ AO - from Shane's https:\/\/www.shadertoy.com\/view\/wslcDS\nfloat calcAO(vec3 p, vec3 n){\n\tfloat sca = 1.5;\n    float occ = 0.;\n    for(float i=ZERO+1.; i<=5.; i+=1.){\n        float t = 0.07*i;\n        float d = mapDist(p+n*t);\n        occ += (t-d)*sca;\n        sca *= .5;\n    }\n    return 1.0 - clamp(occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set cut to view interior\n    float at = mod(iTime, 8.0);  \/\/ animation time\n    cut = vec2(-1.8, 1.8);  \/\/ show all\n    cut = mix(cut, vec2(-1.8, 0.0), clamp(at-1.0, 0., 1.));  \/\/ half\n    cut = mix(cut, vec2(-0.1, 0.1), clamp(at-3.0, 0., 1.));  \/\/ slice in the middle\n    cut = mix(cut, vec2(-1.0, -0.8), clamp(at-5.0, 0., 1.));  \/\/ slice at the side\n    cut = mix(cut, vec2(-1.8, 1.8), clamp(at-7.0, 0., 1.));  \/\/ show all\n\n    \/\/ set camera\n    float rx = iMouse.z!=0.0 ? 1.8*(iMouse.y\/iResolution.y)-0.2 : 0.3;\n    float rz = iMouse.z!=0.0 ? -iMouse.x\/iResolution.x*4.0*3.14 : -0.3;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  \/\/ far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  \/\/ left to right\n    vec3 v = cross(w,u);  \/\/ down to up\n\n    vec3 ro = 12.0*w;  \/\/ ray origin\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  \/\/ ray direction\n\n    \/\/ ray intersection\n    float t0 = 0.01;  \/\/ start at t=t0\n    float t1 = 3.0*length(ro);  \/\/ end distance\n    float t = t0;\n    if (!raymarch(ro, rd, t, t1, 0.8, 1e-3)) {  \/\/ raymarch\n        t = 100.;  \/\/ miss, set t to a large number so it fades\n    }\n    vec3 p = ro+rd*t;  \/\/ current position\n\n    const vec3 sundir = normalize(vec3(0.5, -0.5, 0.5));  \/\/ direction of the sun\n    vec3 n = normalize(mapGrad(p));  \/\/ get normal\n    vec3 col; map(p, col, true);  \/\/ get color\n    float shadow = calcShadow(p, sundir);  \/\/ soft shadow\n    float ao = calcAO(p, n);  \/\/ ao\n    vec3 sunlight = shadow * max(dot(n, sundir), 0.0) * vec3(0.9, 0.8, 0.6);  \/\/ sunlight, yellowish\n    vec3 skylight = ao * max(n.z, 0.0) * vec3(0.6, 0.7, 0.8);  \/\/ skylight, blueish\n    vec3 backlit = ao * (vec3(0.2)  \/\/ background lighting\n        + vec3(0.3)*max(-dot(n,sundir),0.0)  \/\/ opposite of sunlight\n        + vec3(0.4,0.3,0.2)*max(-n.z,0.0));  \/\/ opposite of skylight, warm\n    col *= sunlight + skylight + backlit;  \/\/ sum three lights\n    float fresnel = 0.2+1.4*pow(1.0+dot(rd,n),2.0);  \/\/ faked Fresnel reflectance\n    vec3 refl = 0.8*col+vec3(0.4,0.3,0.2)*pow(max(dot(rd-2.0*dot(rd,n)*n,sundir),0.0),100.);  \/\/ reflection, blend with col\n    if (!raymarch(p+0.2*reflect(rd, n), reflect(rd, n), t0, 8.0, 1.0, 0.02))  \/\/ not occluded\n        col = mix(col, refl, fresnel);  \/\/ add reflection\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.15*max(t-0.4*t1,0.)));  \/\/ sky\/fog\n    col += 0.6*vec3(0.3,0.2,0.25) * max(dot(rd, sundir), 0.);  \/\/ sun haze\n    col = 0.9*pow(col, vec3(0.75));  \/\/ brightness\/gamma\n    fragColor = vec4(vec3(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ssccz7","date":"1653179064","viewed":209,"name":"Neural Tooth 2","username":"harry7557558","description":"Similar to my [url=https:\/\/www.shadertoy.com\/view\/sdc3R2]previous tooth shader[\/url] that uses a neural network to represent a volume.\nUses a different model that has a fewer number weights and a higher accuracy.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["volume","tooth","neural","network","siren"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Neural Tooth 2\n\/\/ Volume source: https:\/\/klacansky.com\/open-scivis-datasets\/, clipped to 100x94x160\n\/\/ Ground truth rendering: https:\/\/harry7557558.github.io\/Graphics\/raytracing\/webgl_volume\/index.html#volume=tooth&visual=skinbone\n\/\/ Training script: https:\/\/github.com\/harry7557558\/Graphics\/blob\/master\/fitting\/boolean\/tanh\/tooth_neural_3.cpp\n\n\/\/ Recently, I'm playing with neural networks in native C++\n\/\/ to get an understanding of how deep learning works in low level.\n\n\/\/ I try to remake my previous neural volume shader\n\/\/ (https:\/\/www.shadertoy.com\/view\/sdc3R2) using a model that has\n\/\/ a lower number of weights and achieve a higher accuracy.\n\n\/\/ Architecture:\n\/\/  - Input: (x, y, z, 1)\n\/\/  - Hidden layer 1, L1N+1 scalars, sine activation\n\/\/  - Hidden layer 2, L2N+1 scalars, sine activation\n\/\/  - Hidden layer 3, L3N+1 scalars, tanh activation\n\/\/  - Output, scalar, sigmoid activation\n\/\/ A smaller size (L1N,L2N,L3N) produces a smaller, faster,\n\/\/     but less accurate result.\n\/\/ Comment\/uncomment the lines in the \/*WEIGHTS*\/ section\n\/\/     to see models with different number of weights.\n\n\/\/ Training with gradient:\n\/\/  - Run Adam for 100-200 epoches with a batch size of 500 (quasi-random)\n\/\/  - Run BFGS for 20 iterations (21-24 epoches)\n\/\/ Mean squared loss.\n\/\/ Each epoch takes 3-5 seconds to run on the CPU (single thread).\n\/\/ In total, a model takes 8-15 minutes to train (more weights are slower).\n\n\/\/ Direct volume rendering with a 2D transfer function.\n\/\/ Constant step raymarching inside a box.\n\/\/ Shift the ray origin by a random step to turn \"stripes\" into noise.\n\/\/ A smaller step size is slower but produces fewer noise.\n\n\n\/* WEIGHTS *\/\n\n\/\/ 185 weights, 0.0020\n\/\/ #define LN ivec3(8,8,8)\n\/\/ #define WEIGHTS -0.295,-4.750,-0.464,2.482,1.051,2.211,1.638,0.584,2.435,-0.297,1.526,0.173,0.456,2.289,-0.878,0.147,1.818,1.079,-0.731,0.146,2.093,0.526,0.131,-1.768,-1.289,0.747,1.033,-0.507,0.304,-1.793,0.680,-1.304,1.660,2.556,-0.061,0.019,0.641,0.156,0.899,0.825,1.377,-0.048,0.403,-0.098,-0.086,0.127,0.164,0.069,-1.584,0.154,2.460,0.088,0.736,0.278,-0.582,-1.557,1.082,-1.058,1.725,1.421,0.307,2.129,0.850,0.684,-0.360,-0.453,2.298,-0.740,-0.319,-0.644,0.522,0.873,1.224,0.138,-0.471,-0.127,-0.081,-0.668,0.392,0.426,1.312,1.768,-1.240,-2.530,-0.645,1.061,-1.417,-1.013,-0.401,-0.426,-1.279,3.870,1.166,-0.917,0.857,-2.333,-0.707,-2.685,0.730,1.400,-2.244,1.637,-1.667,-2.537,-0.720,1.486,0.184,-0.953,-1.185,-0.436,4.281,-0.026,3.703,-0.787,-4.097,0.670,0.960,4.811,-3.614,0.616,1.775,0.527,-2.419,1.259,1.291,2.644,-0.585,-1.179,2.582,-2.249,-2.533,-0.576,0.149,1.887,1.220,-0.803,5.934,1.274,-2.359,4.359,0.123,-0.301,-3.652,0.102,-0.947,1.885,1.858,-1.232,-0.389,-1.900,2.206,3.851,-1.092,4.011,-1.160,6.281,5.346,1.605,-12.770,-5.895,3.171,2.335,-4.066,1.307,2.069,4.410,9.417,-4.410,-8.823,5.652,6.484,-2.806,-1.504,-9.177,-1.087,0.246,1.810,-1.648,1.838,-1.104,3.780,1.752,0.162,-2.618,-1.972\n\n\/\/ 275 weights, 0.0015\n#define LN ivec3(12,10,8)\n#define WEIGHTS 2.970,0.176,2.012,-2.973,-1.994,1.037,-3.610,1.499,0.071,1.881,-0.028,-0.175,0.287,2.253,-1.102,0.119,0.857,-2.838,-1.268,1.692,0.134,2.298,-0.045,-1.991,-1.575,-0.302,0.483,-0.099,-2.384,-2.355,-2.677,-1.438,-1.440,1.430,-0.024,-1.814,-0.498,-0.971,1.924,-0.572,-1.654,-2.303,-1.013,1.151,-0.907,-1.196,0.032,-0.368,-0.274,-0.093,0.661,-0.052,0.470,-0.127,-2.564,0.818,0.931,-0.330,-0.020,1.465,-2.056,-0.180,0.293,0.480,0.244,-2.291,-1.281,0.556,0.121,0.120,3.448,0.353,-0.486,-0.756,0.647,-0.051,-0.310,-1.301,-0.038,0.731,1.467,0.547,0.697,-1.800,-1.598,-0.355,-0.136,0.552,-0.445,-1.267,1.150,-0.651,0.748,-0.593,0.190,0.212,-0.670,-0.392,-0.575,-0.286,-1.290,-0.481,0.810,0.486,0.605,-0.245,0.280,1.009,-0.114,-0.515,0.141,-0.742,-0.151,0.467,0.342,0.198,0.588,-0.317,0.456,0.720,-0.850,2.188,-0.667,-2.664,-0.615,0.314,0.556,-0.364,-3.252,1.157,1.028,-1.340,1.522,-3.128,-0.216,-0.341,0.604,-0.934,-0.003,-0.697,-2.221,0.691,0.462,-0.303,-1.003,-0.048,-0.361,1.033,0.006,0.001,0.143,0.084,0.033,0.063,0.020,-0.062,-0.076,-0.016,-0.315,-2.125,-0.289,-2.455,0.120,0.656,1.567,-2.043,1.335,0.201,-1.945,-2.405,-2.395,0.128,-2.050,0.899,0.079,4.080,1.215,-2.316,-2.811,-1.961,-0.420,1.320,6.897,1.186,1.866,-3.621,-0.974,-0.022,0.946,3.439,-1.200,-0.625,-0.126,-2.989,0.524,-0.659,-0.614,0.248,-2.762,-0.588,-0.085,2.494,-1.895,0.600,1.269,-1.477,1.359,1.102,1.278,-1.652,-2.025,2.916,1.970,-2.428,-4.313,3.585,1.551,3.418,-2.797,-0.270,1.861,0.621,-1.059,-0.430,0.170,3.444,-3.944,0.731,2.507,-0.423,2.931,-1.083,1.043,1.811,1.790,-0.337,0.092,2.147,-0.253,1.681,0.903,-0.706,-0.805,0.924,1.182,-2.126,1.838,0.258,0.419,6.540,-1.011,3.721,1.586,-4.298,1.926,-1.057,2.591,5.600,-2.186,0.361,0.498,-1.664,-12.588,4.022,-0.092,9.800,1.982,3.148,2.479,-1.962,-2.933,-1.003,-1.077,-0.599,-6.096\n\n\/\/ 373 weights, 0.0012\n\/\/ #define LN ivec3(12,12,12)\n\/\/ #define WEIGHTS -3.415,-0.047,0.170,0.002,0.003,-0.052,-1.739,3.228,-0.003,-1.021,2.820,0.062,0.475,3.206,-0.881,1.409,-0.019,-3.676,0.004,0.517,0.017,0.503,-0.253,-2.006,-1.015,0.946,3.438,1.357,0.012,-3.647,1.685,-0.864,-0.005,-2.294,-0.149,0.506,0.031,-1.057,3.010,0.368,-0.006,-2.020,1.582,0.063,0.005,-1.831,-1.657,-0.052,0.065,-0.180,-0.171,-1.414,0.063,-0.001,-0.197,-0.137,0.168,-0.264,-1.694,0.980,-1.011,0.775,-0.813,0.562,-1.337,-0.333,1.089,1.642,-1.121,-0.239,0.604,2.021,0.269,0.567,0.056,-0.491,-0.098,0.879,0.274,-0.317,1.125,1.153,0.216,-0.252,0.346,-1.445,-2.670,1.991,-0.319,1.513,-0.574,0.372,2.418,-1.534,0.129,0.155,-0.023,0.003,0.009,-0.018,0.012,-0.010,-0.001,0.004,0.003,-0.019,0.016,-0.046,-0.103,0.175,-0.658,-0.448,-0.457,-0.638,-0.268,0.212,0.184,-0.392,0.507,-0.645,0.369,-0.936,0.728,0.561,0.833,0.470,1.438,0.614,0.040,0.091,0.025,0.301,0.570,0.121,-0.284,-0.927,0.750,-0.094,-0.462,-0.455,0.645,-0.475,1.243,-0.246,0.026,-0.003,0.008,0.013,-0.014,-0.002,0.011,-0.000,-0.009,0.018,-0.011,0.053,-0.290,1.673,-1.188,-0.525,-1.156,-0.288,-1.649,-0.059,-0.494,-0.850,-1.542,-0.176,-1.823,2.339,-0.133,-0.222,-0.376,-0.057,0.076,-0.990,0.964,-1.025,-0.158,-1.680,-0.289,1.490,0.969,2.404,0.002,1.350,-0.344,0.466,0.492,-1.414,0.195,-0.139,3.317,-0.021,1.449,0.503,1.738,-0.235,-2.736,-1.151,1.662,2.140,-1.313,0.028,-0.638,-1.756,-3.198,-2.484,-5.810,0.275,-0.376,2.058,1.413,-2.665,2.631,0.924,-1.888,-0.503,-2.202,-0.587,0.485,0.943,1.507,0.855,0.560,0.258,-1.746,0.395,6.418,0.582,-0.122,0.190,-0.771,-0.189,-3.709,-0.805,-2.284,3.682,-0.352,-2.143,-0.824,-0.959,-0.390,-0.836,2.581,0.661,1.591,1.743,3.210,2.028,0.109,2.641,2.383,-2.677,0.910,-3.220,8.590,0.385,-1.586,1.875,-0.308,-1.028,0.810,-1.245,3.428,0.570,-0.045,3.572,-2.151,-2.177,-4.491,-0.535,0.887,-1.316,2.928,2.665,-8.329,0.220,-2.630,0.921,-3.462,1.895,3.859,1.626,4.593,1.526,-0.780,4.510,1.974,-0.736,-2.045,-1.624,5.189,0.885,-0.344,1.438,2.626,2.034,-2.673,1.949,2.031,2.513,-2.914,0.786,0.974,-1.424,-1.465,-0.247,1.280,0.475,-1.026,1.479,-3.588,-0.894,-0.115,3.726,-3.044,2.599,1.306,0.876,1.427,0.946,2.461,1.517,-0.375,0.195,1.842,0.084,1.481,-2.488,0.002,-0.044,0.435,2.747,3.532,0.706,-0.641,-0.070,-0.907,-0.339,-0.836,1.912,-0.190,-0.384,-2.473,-0.079,-1.189,-2.530,1.420,0.883,7.201,0.467,-7.626,-0.605,-3.400,0.708,2.624,-8.736,8.852,0.089,1.643,2.776,-1.699,-0.970,0.246,-2.318,1.934,-3.267,0.395,1.715,-2.244,-0.413,-1.400\n\n\/\/ 553 weights, 0.0008\n\/\/ #define LN ivec3(16,16,12)\n\/\/ #define WEIGHTS 0.846,0.025,0.460,0.029,-2.808,-0.032,-2.835,0.839,-0.170,0.021,2.067,1.965,2.032,1.479,0.631,-1.051,0.623,0.015,-0.515,-0.013,-0.089,0.001,-0.177,-2.949,-1.962,-0.007,2.925,-1.200,0.299,-2.242,-2.200,-3.754,1.864,-0.011,2.650,0.002,-0.328,-0.012,0.475,-0.101,-0.427,-0.004,0.450,1.437,-1.448,-2.042,-2.725,0.723,0.910,-0.018,-0.479,-0.011,1.018,0.023,-0.224,1.699,-0.268,-0.003,-1.164,1.101,-1.428,0.275,-2.190,0.299,-0.764,-1.647,1.466,-0.728,-2.212,-1.186,-0.281,-0.339,-2.671,-1.375,-1.149,-0.128,-0.146,0.587,0.342,-0.000,-0.032,0.026,0.063,0.016,-0.024,-0.014,-0.133,-0.003,-0.086,-0.084,0.042,-0.261,-0.019,-0.055,-0.012,0.023,0.530,0.391,0.137,1.083,0.840,-1.376,-1.075,-0.410,2.313,-1.434,1.857,0.932,-1.399,1.683,0.878,0.567,0.001,0.053,0.012,-0.017,0.030,-0.029,0.033,-0.032,-0.020,-0.018,-0.009,-0.080,0.019,-0.116,-0.020,0.009,0.105,0.981,1.349,0.179,-0.822,1.111,1.267,-1.513,-0.460,-1.380,1.608,-0.660,-0.087,0.472,0.671,-0.323,-0.022,-0.047,0.051,0.052,-0.071,-0.013,-0.048,0.047,0.024,0.004,0.048,0.028,-0.045,0.057,0.012,-0.040,-0.320,-0.290,1.475,-2.597,0.128,-1.097,-0.299,0.692,-1.142,0.299,-0.630,-2.398,0.179,1.128,0.753,0.902,0.492,0.096,-1.361,0.576,0.439,0.313,0.875,-0.948,1.593,0.618,0.449,1.641,0.753,0.797,-0.511,-0.878,1.739,-0.572,2.333,-0.873,0.674,-0.530,-1.571,0.123,-0.196,1.370,-0.396,1.932,-0.004,-0.567,0.780,-0.412,-0.012,0.028,0.015,0.019,0.008,-0.037,-0.023,-0.020,-0.025,-0.025,0.011,-0.073,-0.010,-0.105,-0.017,-0.009,-0.375,0.068,0.066,-0.355,-0.075,-1.088,-0.411,0.166,2.245,-0.407,0.508,-0.162,0.810,0.147,1.516,0.874,-1.994,-1.009,-0.708,0.721,0.478,-0.610,0.281,0.497,-0.933,-0.225,-0.560,1.104,0.211,-2.613,0.616,-0.286,2.003,1.701,0.059,-0.977,-0.935,0.519,1.799,0.045,0.342,0.788,1.214,-2.941,-0.842,-1.839,0.166,0.099,-0.014,0.406,-1.480,1.677,0.203,1.064,-1.856,-0.197,-2.308,1.765,0.673,0.090,-0.601,-0.519,-0.643,-0.343,-0.243,0.629,-0.006,0.933,1.005,0.100,-0.684,0.150,0.070,1.980,0.151,-0.168,-0.866,1.560,1.071,0.782,-0.631,0.247,1.230,-0.540,-0.772,-0.624,-0.895,-0.407,-0.187,0.734,0.828,-1.765,-0.122,-0.026,-0.580,-0.017,-0.176,-2.126,-0.771,1.106,2.487,2.105,-1.660,-2.729,3.494,-0.188,1.752,1.679,-0.580,1.694,-1.961,-2.436,-0.602,-0.968,-1.361,3.404,-3.634,0.849,2.607,-1.853,1.012,-0.989,0.752,-0.056,-0.999,0.485,2.446,-8.052,-0.440,-4.302,-2.695,-0.513,-1.221,-3.519,0.731,5.547,0.437,-0.156,-0.033,-3.299,-1.907,0.205,0.201,-1.356,1.060,-0.102,0.751,-0.963,-1.483,-0.533,-1.070,1.838,0.370,-0.847,-1.415,1.503,-2.282,0.008,0.179,0.089,0.128,1.072,1.219,-1.538,-0.741,-0.333,-2.443,3.509,-0.289,-0.407,-2.429,-0.926,-1.734,-1.819,0.865,2.145,0.275,1.464,-0.964,1.915,-0.296,0.269,2.772,-1.243,-0.111,-0.886,-0.739,6.021,-0.302,0.582,-1.666,1.850,-0.103,-0.475,-1.176,-0.636,2.439,0.869,3.625,-2.252,0.716,2.213,3.601,-4.206,0.293,-1.107,8.725,7.707,0.652,0.445,-0.063,-0.424,1.512,-0.230,1.930,-2.160,-0.457,-0.100,-0.340,-0.315,0.142,-0.471,-0.792,-1.916,0.369,0.635,-2.897,3.354,-1.471,-0.540,-1.487,-1.526,-0.874,1.161,0.159,-1.286,1.527,-1.340,-1.099,0.406,-2.172,-1.868,1.457,1.122,0.786,-0.368,-0.722,-0.214,2.054,0.540,0.433,-1.633,0.307,-0.096,-1.639,1.125,1.252,1.941,1.240,-2.894,2.329,-1.173,-1.423,2.364,-1.091,1.148,-3.026,1.977,0.974,-0.350,0.368,-0.028,0.244,0.090,0.658,-1.272,1.552,-0.310,0.300,1.040,0.884,0.847,0.938,-4.951,-0.247,-0.005,0.511,-3.645,-1.145,-0.171,0.567,0.976,3.018,2.315,1.032,0.606,4.793,0.884,-1.944,-0.398,-2.056,3.207,-3.861,-2.041,0.748,-0.471,-1.828,-2.552,2.239,-4.629,-7.999,9.829,-2.874,-6.682,-12.877,-16.578,2.243,2.429,-0.997,0.209,1.228,1.035,1.164,1.003,-1.862,4.024,1.672,-3.677,-3.557\n\n\n\/* MODEL *\/\n\n#define L1N LN.x\n#define L2N LN.y\n#define L3N LN.z\n#define L1WN (L1N*4)\n#define L2WN (L2N*(L1N+1))\n#define L3WN (L3N*(L2N+1))\n#define L4WN (L3N+1)\n#define WN (L1WN+L2WN+L3WN+L4WN)\n\nfloat w[WN] = float[WN](WEIGHTS);\nvec4 f1[L1N+1], f2[L2N+1], f3[L3N+1];\n\n\/\/ Defined within the unit cube -1 < p < 1\n\/\/ Returns value and analytical gradient\nvec4 model(vec3 p) {\n    \/\/ layer 1\n    for (int i = 0; i < L1N; i++) {\n        float s = w[i]*p.x + w[i+L1N]*p.y + w[i+2*L1N]*p.z + w[i+3*L1N];\n        f1[i] = vec4(sin(s), cos(s)*vec3(w[i],w[i+L1N],w[i+2*L1N]));\n    }\n    f1[L1N] = vec4(1,0,0,0);\n    \/\/ layer 2\n    for (int i = 0; i < L2N; i++) {\n        vec4 s = vec4(0);\n        for (int j = 0; j <= L1N; j++)\n            s += w[L1WN+i+j*L2N] * f1[j];\n        f2[i] = vec4(sin(s.x), cos(s.x)*s.yzw);\n    }\n    f2[L2N] = vec4(1,0,0,0);\n    \/\/ layer 3\n    for (int i = 0; i < L3N; i++) {\n        vec4 s = vec4(0);\n        for (int j = 0; j <= L2N; j++)\n            s += w[L1WN+L2WN+i+j*L3N] * f2[j];\n        float v = tanh(s.x);\n        f3[i] = vec4(v, (1.0-v*v)*s.yzw);\n    }\n    f3[L3N] = vec4(1,0,0,0);\n    \/\/ output\n    vec4 s = vec4(0);\n    for (int j = 0; j <= L3N; j++)\n        s += w[L1WN+L2WN+L3WN+j] * f3[j];\n    float v = 1.0\/(1.0+exp(-s.x));\n    return vec4(v, v*(1.-v)*s.yzw);\n}\n\n\/\/ viewbox size\nconst vec3 BOX = vec3(0.424, 0.398, 0.678);\n\n\n\/* RENDERING *\/\n\n#define ZERO min(iFrame,0)\n\n\/\/ larger => faster, smaller => less noise\n#define STEP_SIZE 0.01\n\nvec3 ldir;  \/\/ light direction\n\n\/\/ Transfer function\nvec4 transfer(vec3 p) {\n    vec4 sp = model(-p\/BOX) \/ vec4(1,BOX);\n    float v = sp.x; vec3 n = sp.yzw;\n    vec3 col = v>0.5 ? vec3(0.9,0.8,0.6) : vec3(0.2,0.4,0.8);  \/\/ white\/blue\n    if (abs(length(n)-10.0)<1.0) col = vec3(0,1,0.5);  \/\/ green\n    col *= 0.2+0.8*max(dot(normalize(sp.yzw),ldir),0.);  \/\/ lighting\n    float alpha = v>0.5 ? 40.0 : abs(v-0.25)<0.1 ? 10.0 : 0.0;\n    return vec4(col, 1.) * alpha;\n}\n\n\/\/ Constant step raymarching, returns RGB\nvec3 raymarch(in vec3 ro, in vec3 rd, float t0, float t1) {\n    const float dt = STEP_SIZE;\n    float t = t0 + dt * fract(sin(dot(ro+rd,vec3(12,27,41))+89.)*1249.8);  \/\/ turn \"stripes\" into \"noise\"\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    for (; t < t1; t += dt) {\n        vec4 tr = transfer(ro+rd*t);\n        totabs *= exp(-tr.w*dt);\n        totcol += totabs*tr.xyz*dt;\n    }\n    return totcol;\n}\n\n\/\/ Ray intersection with the view box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*(0.99*BOX);\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set camera\n    float rx = iMouse.z>0.?3.14*(iMouse.y\/iResolution.y)-1.57:0.0;\n    float rz = iMouse.z>0.?-iMouse.x\/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n    rx += 1e-4, rz += 1e-4;  \/\/ prevent dividing by zero\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec2 uv = (2.0*fragCoord-iResolution.xy)\/min(iResolution.x,iResolution.y);\n    vec3 ro = 4.0*w + 0.8*(uv.x*u+uv.y*v);\n    vec3 rd = -w;\n\n    \/\/ calculate pixel color\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    ldir = normalize(w+0.8*u+0.5*v);\n    vec3 col = raymarch(ro, rd, t0, t1);\n    col = 1.2*pow(col, vec3(0.8));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lfyDl","date":"1593380579","viewed":307,"name":"Numerical Gradient Comparison","username":"harry7557558","description":"Comparing 3d numerical differentiation methods.\n\nSeems like the tetrahedron method doesn't work much better than the naive method ~.~","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["gradient","compare","differen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Comparing numerical gradient methods\n\n\/\/ I just discovered that sampling gradient on a 2d simplex \n\/\/ has an error of 1\/h O(h\u00b2), so I want to know if that applies to 3d.\n\n\/\/ Left to right: reference, naive method, central difference, tetrahedron method\n\n\/\/ In the three graphs on the right:\n\/\/ Red indicates the difference in the direction of gradient;\n\/\/ Blue indicates the difference in the magnitude of gradient;\n\/\/ A brighter color represents a higher error.\n\n\/\/ In the reference graph: rgb -> xyz\n\n\/\/ Mouse control:\n\/\/ Left\/Right: view rotation\n\/\/ Up\/Down: numerical differentiation step\n\n\/\/ The 4-sample tetrahedron method doesn't seem to be much better\n\/\/ than the 3-sample naive method.\n\n\/\/ Using Taylor expansion, one gets: [+ 1\/h O(h\u00b3)]\n\n\/\/ Naive method:        (\u2202F\/\u2202x,\u2202F\/\u2202y,\u2202F\/\u2202z) + h\/2 (\u2202\u00b2F\/\u2202x\u00b2,\u2202\u00b2F\/\u2202y\u00b2,\u2202\u00b2F\/\u2202z\u00b2)\n\/\/ Central difference:  (\u2202F\/\u2202x,\u2202F\/\u2202y,\u2202F\/\u2202z)\n\/\/ Tetrahedron method:  (\u2202F\/\u2202x,\u2202F\/\u2202y,\u2202F\/\u2202z) + h (\u2202\u00b2F\/\u2202y\u2202z,\u2202\u00b2F\/\u2202x\u2202z,\u2202\u00b2F\/\u2202x\u2202y)\n\n\/\/ You can uncomment the commented lines in fun() and map()\n\/\/ to see how these methods applied to a sphere and a hyperboloid.\n\n\/\/ However, you may need to change these:\n#define saturation 1.0\n#define raymch_step_sc 0.8\n\n\/\/ ======================================================================= end of story\n\n\n\n\/\/ the funny shape: F(x,y,z)=(x\u00b2+2y\u00b2+z\u00b2)\u00b3-(9x\u00b2+y\u00b2)z\u00b3-0.5\nfloat fun(in vec3 p) {\n    \/\/return dot(p,p)-1.; \/\/ sphere\n    \/\/return p.x*p.y+p.x*p.z+p.y*p.z+1.; \/\/ hyperboloid\n    float e = p.x*p.x+2.*p.y*p.y+p.z*p.z;\n\treturn e*e*e-(9.*p.x*p.x+p.y*p.y)*p.z*p.z*p.z-.5;\n}\n\n\/\/ return value and analytical gradient at once\nvec4 map(in vec3 p) {\n    \/\/return vec4(2.*p,dot(p,p)-1.); \/\/ sphere\n    \/\/return vec4(p.y+p.z,p.x+p.z,p.x+p.y,p.x*p.y+p.x*p.z+p.y*p.z+1.); \/\/ hyperboloid\n    vec3 p2 = p*p;\n    float e = p2.x+2.*p2.y+p2.z, f = 9.*p2.x+p2.y;\n    return vec4(\n        e*e*vec3(6,12,6)*p - p2.z*vec3(18.*p.x*p.z,2.*p.y*p.z,3.*f),\n        e*e*e - p2.z*p.z*f - .5);\n}\n\n\n\n\/\/ numerical differentiation step\nfloat h = 0.1;\n\n\/\/ numerical gradient method id\nint method = 0;\n\n\/\/ naive method\nvec3 grad_naive(in vec3 p){\n    float v = fun(p);\n    return (1.\/h)*vec3(\n        fun(p+vec3(h,0,0))-v,\n        fun(p+vec3(0,h,0))-v,\n        fun(p+vec3(0,0,h))-v);\n}\n\/\/ central difference\nvec3 grad_central(in vec3 p){\n    return (.5\/h)*vec3(\n        fun(p+vec3(h,0,0))-fun(p-vec3(h,0,0)),\n        fun(p+vec3(0,h,0))-fun(p-vec3(0,h,0)),\n        fun(p+vec3(0,0,h))-fun(p-vec3(0,0,h)));\n}\n\/\/ tetrahedron method\nvec3 grad_tetrahedron(in vec3 p){\n\tfloat a = fun(p+vec3(h,h,h));\n\tfloat b = fun(p+vec3(h,-h,-h));\n\tfloat c = fun(p+vec3(-h,h,-h));\n\tfloat d = fun(p+vec3(-h,-h,h));\n\treturn (.25\/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n\/\/ raymarching\n\nvec3 light = vec3(.3,.1,1);\nvec3 render(vec3 p, vec3 d) {\n\tfloat t = 3., dt;\n\tfor (int i = 0; i < 1024; i++) {\n        vec4 mp = map(p+t*d);\n\t\tdt = abs(mp.w) \/ length(mp.xyz);\n\t\tt += raymch_step_sc*dt;\n        if (dt<.001) {\n\t\t\tp += t*d;\n            vec3 grad = mp.xyz;\n            float m0 = length(grad);\n    \t\tvec3 n0 = normalize(grad);\n            vec3 col = vec3(.2*clamp(dot(n0,light),0.,1.)+.2);\n            if (method==0) return col+(n0+vec3(.5))*vec3(.4,.2,.4);\n            \n            if (method==1) grad=grad_naive(p);\n            if (method==2) grad=grad_central(p);\n            if (method==3) grad=grad_tetrahedron(p);\n            float m = length(grad);\n            vec3 n = normalize(grad);\n            \n            float ed = 10.*(1.-dot(n0,n));\n            float el = (m-m0)*(m-m0)\/sqrt(m0*m0+1.);\n    \t\treturn col+vec3(ed,0,el)*saturation;\n        }\n\t\tif (t>20.) break;\n\t}\n    return vec3(.5*clamp(dot(d,light),0.,1.));\n}\n\n#define AA 2\n#define res iResolution.xy\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = vec3(0.0);\n    vec2 gd = coord.xy;\n    method = int(4.*gd.x\/res.x);\n    gd.x = mod(gd.x,.25*res.x);\n    \n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv=(12.\/res.x)*((gd+vec2(i,j)\/float(AA))-vec2(.125,.5)*res.xy);\n        vec3 pos = vec3(0,-10,0.);\n        vec3 dir = vec3(uv.x,0,uv.y)-pos;\n        float a = .3*sin(iTime);\n        mat3 R = mat3(1,0,0,0,cos(a),-sin(a),0,sin(a),cos(a));\n        if (iMouse.z>0.){\n            uv = iMouse.xy\/res.xy;\n            a = 6.283*(uv.x-.5);\n            R = mat3(cos(a),-sin(a),0,sin(a),cos(a),0,0,0,1) * R;\n            a = 2.*(uv.y-.5);\n            h = 0.1+0.1*a;\n        }\n        light = R*vec3(.3,.1,1);\n        pos = R*pos, dir = R*dir;\n        col += render(pos,normalize(dir));\n    }\n    \n    color = vec4(col\/float(AA*AA),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fsGGzh","date":"1631027887","viewed":118,"name":"Piecewise Linear Simplex Terrain","username":"harry7557558","description":"Demonstrate a noise generated by interpolating hash values on a simplex grid.\nSee Common tab for 2D and 3D noise functions and their analytical gradient.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ I attempted to find a combination of simplex noise and value noise\n\/\/ but failed to produced one with continuous gradient.\n\n\/\/ The idea is to interpolate hash values on a simplex grid.\n\/\/ The noise (2D+3D) and their analytical gradient can be found in the Common tab.\n\n\/\/ The 3D noise seems to be cheaper than 3D Perlin noise\n\/\/ and about the same cost as 3D value noise.\n\/\/ The 2D noise is more expensive than most common 2D noise functions\n\/\/ but cheaper than standard 2D simplex noise.\n\n\/\/ I created this shader to demonstrate this piecewise linear simplex noise.\n\n\n\/\/ scene\nfloat map(in vec3 p) {\n    float base = p.z - 0.1*SimplexValueNoise2D(p.xy);\n    float top = p.z - (0.05 * 2.0*SimplexValueNoise2D(0.5*p.xy) + 3.0);\n    float blob = 0.6*5.0*SimplexValueNoise3D(0.2*p) + 0.2*SimplexValueNoise3D(p);\n    return min(max(blob, top), base);\n}\n\n\/\/ to show that analytical gradient works\nvec3 mapNormal(vec3 p) {\n    vec3 t = SimplexValueNoise2Dg(p.xy);\n    vec4 base = vec4(0, 0, 1, p.z) - 0.1*vec4(t.xy, 0.0, t.z);\n    t = 2.0 * vec3(0.5,0.5,1)*SimplexValueNoise2Dg(0.5*p.xy);\n    vec4 top = vec4(0, 0, 1, p.z) - (0.05 * vec4(t.xy, 0.0, t.z) + vec4(vec3(0), 3.0));\n    vec4 blob = 0.6*5.0*vec4(vec3(0.2),1)*SimplexValueNoise3Dg(0.2*p) + 0.2*SimplexValueNoise3Dg(p);\n    vec4 r = blob.w > top.w ? blob : top;\n    r = r.w < base.w ? r : base;\n    return normalize(r.xyz);\n}\n\n\n\n#define ZERO min(int(iTime),0)\n\nconst vec3 sundir = normalize(vec3(0.5, 0.5, 1.0));\n\nbool raymarch(vec3 ro, inout vec3 rd, inout float t) {\n    float t0 = 0.01, t1 = 120.0;\n    for (int i=ZERO; i<120; i++) {\n        float dt = map(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) break;\n        if (t > t1) {\n            return false;\n        }\n        rd = normalize(rd + vec3(0, 0, .001*dt));\n    }\n    return true;\n}\n\nfloat calcShadow(vec3 ro) {\n    float t = 0.1;\n    for (int i=ZERO; i<20; i++) {\n        float dt = map(ro+sundir*t);\n        if (dt < 0.) return 0.1;\n        t += max(dt, 0.1);\n    }\n    return 1.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0. ? 1.8*(iMouse.y\/iResolution.y)-0.2 : 0.28;\n    float rz = iMouse.z>0. ? -iMouse.x\/iResolution.x*4.0*3.14 : 0.5+0.1*iTime;\n    float ry = iMouse.z>0. ? 0.0 : 0.1;\n\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = vec3(-sin(rx)*vec2(cos(rz),sin(rz)), cos(rx));\n    vec3 w = cross(u, v);\n    u = cos(ry)*u + sin(ry)*v;\n    v = cross(w, u);\n\n    vec3 ro = vec3(2.0*iTime, 0, 2.5) + 14.0*w;\n    vec2 uv = 2.0*fragCoord.xy\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    float t = 0.0;\n    vec3 col;\n    if (raymarch(ro, rd, t)) {\n        ro += rd * t;\n        vec3 n = mapNormal(ro);\n        vec3 basecol = 0.5+0.4*(1.0-abs(n.z))*hash33(n);\n        float shadow = calcShadow(ro);\n        vec3 sunlight = basecol * shadow * max(dot(n, sundir), 0.0) * vec3(1.2,1.1,0.8);\n        vec3 skylight = basecol * max(n.z, 0.0) * vec3(0.6,0.6,0.8);\n        vec3 indirect = basecol * max(-dot(n, sundir), 0.0) * vec3(0.6) + 0.2*max(-n.z, 0.0);\n        col = sunlight + skylight + indirect;\n    }\n    else {\n        t = 1e12;\n    }\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.015*t));\n    col += vec3(0.8, 0.6, 0.4) * pow(max(dot(rd, sundir), 0.0), 1.5);\n    col = 1.1*pow(col, vec3(1.2));\n    fragColor = vec4(vec3(col), 1.0);\n    return;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ hash functions from https:\/\/www.shadertoy.com\/view\/4djSRW by David Hoskins\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\/\/ for solving interpolation\nfloat det(vec2 a, vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\nfloat det(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\n\/\/ noise functions and their analytical gradient\n\nfloat SimplexValueNoise2D(vec2 xy) {\n\t\/\/ simplex grid\n\tconst float K1 = 0.3660254038;  \/\/ (sqrt(3)-1)\/2\n\tconst float K2 = 0.2113248654;  \/\/ (-sqrt(3)+3)\/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t\/\/ interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 \/ det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\treturn v1 + u * (v2 - v1) + uv * (v3 - v2);  \/\/ mix(v1, mix(v2, v3, v), u)\n}\n\nvec3 SimplexValueNoise2Dg(vec2 xy) {\n\t\/\/ simplex grid\n\tconst float K1 = 0.3660254038;  \/\/ (sqrt(3)-1)\/2\n\tconst float K2 = 0.2113248654;  \/\/ (-sqrt(3)+3)\/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t\/\/ interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 \/ det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\tvec2 grad_u = m * vec2(c.y, -c.x);\n\tvec2 grad_uv = m * vec2(-s.y, s.x);\n\tfloat val = v1 + u * (v2 - v1) + uv * (v3 - v2);\n\tvec2 grad = grad_u * (v2 - v1) + grad_uv * (v3 - v2);\n\treturn vec3(grad + (grad.x + grad.y)*K1, val);\n}\n\nfloat SimplexValueNoise3D(vec3 xyz) {\n\t\/\/ simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\t\/\/vec3 e = step(f0.yzx, f0);  \/\/ possibly result in degenerated simplex\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t\/\/ interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 \/ det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\treturn v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;  \/\/ mix(v0, mix(mix(v1, v2, u), mix(v1, v3, u), v), w)\n}\n\nvec4 SimplexValueNoise3Dg(vec3 xyz) {\n\t\/\/ simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t\/\/ interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 \/ det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\tvec3 grad_w = m * cross(p12, p23);\n\tvec3 grad_uw = m * cross(p23, p01);\n\tvec3 grad_uvw = m * cross(p01, p12);\n\tfloat val = v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;\n\tvec3 grad = (v1 - v0) * grad_w + (v2 - v1) * grad_uw + (v3 - v2) * grad_uvw;\n\treturn vec4(grad + (grad.x + grad.y + grad.z)*K1, val);\n}\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7st3Rr","date":"1629064414","viewed":5,"name":"Scratch Pipes","username":"harry7557558","description":"Replicate an old effect made in visual programming tool Scratch when I just started to learn to code. I have lost the original file but I still feel the old one looks nicer.","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["discard","pipe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sc (iResolution.xy\/length(vec2(800,450)))\n\nfloat hash(float x, float y) {\n    return fract(43758.5453*sin(12.9898*x+78.233*y));\n}\nfloat noise(float x, float s) {\n    int i0 = int(floor(x)+0.5), i1 = i0+1;\n    return mix(hash(float(i0),s), hash(float(i1),s), smoothstep(0.,1.,fract(x)));\n}\n\nvec2 circle_pos(float i) {\n    float t = 0.001*i;\n    vec2 p = vec2(cos(1.5*t),sin(1.7*t));\n    p += vec2(noise(t,0.0),noise(t+0.5,0.05));\n    p = acos(cos(3.1415926*15.0*p\/sc))\/3.1415926;\n    return iResolution.xy*p;\n}\nvec3 circle_color(float i) {\n    float t = 0.1*i;\n    \/\/vec3 c = vec3(noise(t,0.1),noise(t+0.5,0.1),noise(t+1.0,0.1));\n    vec3 c = vec3(noise(t,0.1),noise(t+0.5,0.2),noise(t+1.0,0.3));\n    return pow(c,vec3(1.5));\n}\nfloat circle_size(float i) {\n    return length(sc)*(20.0+40.0*noise(0.01*i, 0.4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame==0) { fragColor=vec4(1.0); return; }\n\n    float t = float(iFrame);\n    vec2 pos = circle_pos(t);\n    vec3 color = circle_color(t);\n    float size = circle_size(t);\n    \n    float sd = length(fragCoord-pos);\n    if (sd>size) discard;\n\n    vec3 col = color;\n    \/\/col = mix(vec3(0),col,clamp(sd-5.0,0.0,1.0));\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ttSSDc","date":"1580178987","viewed":25,"name":"Self-Adaptive Super Sampling","username":"harry7557558","description":"Much faster than brute force super sampling. \nNote that the sawteeth at the side of the cup are not recognized. \nI think this can be improved by using a depth buffer. ","likes":0,"published":2,"flags":32,"usePreview":0,"tags":["raymarching","supersampling","cup"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if 0\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c0 = texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    float d = 0.0;\n    for (int i=-1;i<=1;i++) {\n        for (int j=-1;j<=1;j++) {\n            if (i!=0&&j!=0) {\n        \t\tvec3 c = texelFetch(iChannel0,ivec2(fragCoord)+ivec2(i,j),0).xyz;\n                c -= c0;\n                d = max(d,length(c));\n            }\n        }\n    }\n    float dif = d;\n    \n    int AA = 1; float a;\n    \/\/fragColor = vec4(dif,dif,dif,0.); return;\n    if (dif<0.2){\n        fragColor=vec4(c0,1.0);\n        return;\n    }\n    else if (dif<0.8) AA=2, a=0.3;\n    else AA=3, a=0.8;\n    \n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))\/float(AA),\n                       iResolution.xy, iMouse, iTime, iChannel1);\n    col\/=float(AA*AA);\n    if (fract(iTime)>0.5) col=mix(col,vec3(1,0,0),a);\n    fragColor = vec4(col,1.0);\n}\n\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#define C(i,j) cols[3*(i)+(j)]\n    vec3 cols[9];\n    for (int i=-1;i<=1;i++) for (int j=-1;j<=1;j++){\n        C(i+1,j+1) = texelFetch(iChannel0,ivec2(fragCoord)+ivec2(i,j),0).xyz;\n    }\n    vec3 dx,dy;\n    for (int i=0;i<3;i++){\n        float m=i==1?2.0:1.0;\n        dx+=m*max(abs(C(2,i)-C(1,i)),abs(C(1,i)-C(0,i)));\n        dy+=m*max(abs(C(i,2)-C(i,1)),abs(C(i,1)-C(i,0)));\n    }\n    vec3 g = sqrt(dx*dx+dy*dy);\n    float dif = dot(g,vec3(0.3,0.59,0.11));\n    \n    int AA = 1; float a;\n    if (dif<0.5){\n        fragColor=vec4(C(1,1),1.0);\n        return;\n    }\n    else if (dif<2.0) AA=2, a=0.3;\n    else AA=3, a=0.8;\n    \n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))\/float(AA),\n                       iResolution.xy, iMouse, iTime, iChannel1);\n    col\/=float(AA*AA);\n    if (fract(iTime)>0.5) col=mix(col,vec3(1,0,0),a);\n    fragColor = vec4(col,1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\nfloat opExtrusion(float sd, float h, vec3 P) {\n    if (P.z >= 0. && P.z <= h) return sd > 0. ? sd : max(sd, max(-P.z, P.z - h));\n\tif (P.z > h) return sd > 0. ? sqrt(sd*sd + (P.z - h)*(P.z - h)) : P.z - h;\n\tif (P.z < 0.) return sd > 0. ? sqrt(sd*sd + P.z*P.z) : -P.z;\n}\n\nfloat sdCylinder(float r, float min_z, float max_z, vec3 p) {\n    p.z-=min_z, max_z-=min_z, min_z=0.0;\n    float d=length(p.xy)-r;\n    if (p.z>0.0 && p.z<max_z) return max(d, max(-p.z, p.z-max_z));\n    if (p.z>max_z) p.z-=max_z;\n    else p.z=-p.z;\n    return d<0.0?p.z:sqrt(d*d+p.z*p.z);\n}\n\nfloat sdPolygon(vec2 v[4], vec2 p) {\n\tfloat sd = dot(p - v[0], p - v[0]);\n\tfloat sgn = 1.0;\n\tvec2 e, w, b; float c;\n\tfor (int i = 0; i < 4; i++) {\n\t\te = v[(i+1)%4] - v[i];\n\t\tw = p - v[i];\n\t\tb = w - e*clamp( dot(w,e)\/dot(e,e), 0.0, 1.0 );\n\t\tsd = min(sd, dot(b,b));\n\t\tif (e.y < 0.0) e.y = -e.y, w.y = -w.y;\n\t\tif (w.y > 0.0 && w.y < e.y && (w.y*e.x \/ e.y > w.x)) sgn =-sgn;\n\t}\n\treturn sgn*sqrt(sd);\n}\n\nfloat s_sub(float a, float b, float k) {\n\tfloat h = 0.5 - 0.5*(b + a) \/ k;\n\tif (h < 0.0) return a; if (h > 1.0) return -b;\n\treturn mix(a,-b,h) + k*h*(1.0 - h);\n}\n\nfloat s_min(float a, float b, float k) {\n\tfloat h = 0.5 + 0.5*(b - a) \/ k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn mix(b,a,h) - k*h*(1.0 - h);\n}\n\nfloat sdCup(vec3 p) {\n    p.z-=0.23;\n    float cyl = sdCylinder(0.75, 0.0, 2.0, p);\n    float sd = abs(cyl - 0.15) - 0.08;\n    sd = s_sub(sd, 1.8 - p.z, 0.08);\n    vec3 q=p.xzy-vec3(1.03,0.38,-0.15);\n    float handle = sdPolygon(vec2[4](vec2(0,0.9),vec2(0.4,0.9),vec2(0.3,0.35),vec2(0,0.1)),q.xy);\n    handle=opExtrusion(abs(handle-0.2)-0.05, 0.3, q)-0.1;\n    handle=max(handle,0.12-cyl);\n    sd = s_min(sd, handle, 0.05);\n    return sd;\n}\n\nfloat map(vec3 p) {\n    p.z+=1.0;\n    return min(p.z, sdCup(p));\n}\n\n#define ZERO min(int(time),0)\n#define eps 1e-3\n#define MAX_STEP 256\n#define MAX_DIST 20.0\n\n\nvec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nvec3 calcCol(in vec2 coord, in vec2 res, in vec4 iMouse, in float time, sampler2D g) {\n    vec3 Pos;\n    if (iMouse.z>0.){\n        float u = 2.0*PI*iMouse.x\/res.x;\n        float v = 0.5*PI*iMouse.y\/res.y;\n        Pos = 5.0*vec3(sin(u)*cos(v),cos(u)*cos(v),sin(v));\n    }\n    else{\n    \tfloat H = cos(0.4*time); H=3.5*H*H+0.5;\n    \tfloat R = sqrt(20.0-H*H)+0.2*(cos(time)+1.0);\n    \tPos=vec3(R*cos(time), R*sin(time), H);\n    }\n    \n    float rz=atan(-Pos.x,Pos.y), rx=atan(length(Pos.xy),-Pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 d = M*normalize(vec3(0.5*res.x-coord.x,-0.5*res.y+coord.y,0.7*length(res)));\n    \n    \n\t\/\/ cast ray\n\tfloat t = 100.0 * eps, dt;\n\tvec3 p = Pos + t * d;\n\tif (map(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = ZERO; i < MAX_STEP; i++) {\n\t\tdt = map(Pos + t * d);\n\t\tt += dt;\n\t\tif (dt < -eps) return vec3(1.0, 0.0, 0.0);\n\t\tif (dt < eps) break;\n\t\tif (dt > MAX_DIST || i+1 == MAX_STEP) {\n            return vec3(0.0);\n\t\t\t\/\/t = max(dot(d, light), 0.0);\n\t\t\t\/\/return vec3(t, t, t);\n\t\t}\n\t}\n\tp = Pos + t * d;\n    vec3 col = vec3(0.87,0.8,0.7);\n    if (p.z+1.0<eps) col = texture(g,0.1*p.xy).rgb;\n    col *= exp(-0.01*dot(p.xy,p.xy));\n\n\t\/\/ calculate normal\n\tfloat k_111 = map(vec3(p.x + eps, p.y + eps, p.z + eps));\n\tfloat k_100 = map(vec3(p.x + eps, p.y - eps, p.z - eps));\n\tfloat k_010 = map(vec3(p.x - eps, p.y + eps, p.z - eps));\n\tfloat k_001 = map(vec3(p.x - eps, p.y - eps, p.z + eps));\n\tvec3 n = normalize(vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001));\n\tif (dot(n, d) > 0.0) n = -n;\n\n\t\/\/ calculate shadow\n\td -= 2.0 * dot(d, n)*n;\n\tfloat r = 1.0;\n\tt = 0.01;\n\tfor (int i = ZERO; i < MAX_STEP; i++) {\n\t\tdt = map(p + t * light);\n\t\tr = min(r, 15.0 * dt \/ t);\n\t\tif (r < 0.01 || t > 2.0) break;\n\t\tt += 0.1*clamp(dt, 0.5, 2.0);\n\t}\n\tr = clamp(r, 0.0, 1.0);\n\n\t\/\/ final result\n\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n\treturn (dif*r + 0.2*pow(max(dot(d, light), 0.0), 4.0))*col + (0.5 - 0.5*dif)*vec3(0.1, 0.15, 0.25);\n    \n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col=calcCol(fragCoord+vec2(0.5),iResolution.xy,iMouse,iTime,iChannel0);\n    fragColor = vec4(clamp(col,0.0,1.0),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"fdBcRd","date":"1643931807","viewed":128,"name":"ShallowWaterEqu_3b1d","username":"harry7557558","description":"My second attempt in buffer simulation. Try to simulate water ripples by solving the shallow water equation, which produces more details than the wave equation. However, it requires a much smaller time step to be stably integrated by the forward Euler.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["ripples","wave","simulation","water","equation","shallow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Fork of \"WaveEquation_9ec8\" by harry7557558. https:\/\/shadertoy.com\/view\/sdBczG\n\/\/ 2022-02-03 15:29:13\n\n\/\/ Common: parameters and differential equation\n\/\/ Buffer A\/B\/C\/D: forware Euler integration\n\/\/ Image: rendering\n\n\n\/\/ get vec4(u, dudx, dudy, 1)\nvec4 getVal(sampler2D sampler, vec2 xy) {\n    float h = getH(xy);\n    float hx1 = getH(xy+nds.xz);\n    float hx0 = getH(xy-nds.xz);\n    float hy1 = getH(xy+nds.zy);\n    float hy0 = getH(xy-nds.zy);\n    float hx = (hx1-hx0) \/ (2.*nds.x);\n    float hy = (hy1-hy0) \/ (2.*nds.y);\n    return vec4(h, hx, hy, 1);\n}\n\n\/\/ ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1. \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*view_box;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ raymarhing, return RGB\nvec3 render(vec3 ro, vec3 rd, float t0, float t1) {\n    float t = t0;\n    for (int i=0; i<64; i++) {\n        vec3 p = ro+rd*t;\n        vec4 vn = getVal(iChannel0, p.xy);\n        float dt = 0.6*(p.z-vn.x) \/ length(vn.yzw);\n        t += dt;\n        if (t<=t0 || t>=t1) return vec3(0.1);\n        if (abs(dt)<.001) break;\n    }\n    vec3 n = normalize(getVal(iChannel0, (ro+rd*t).xy).yzw);\n    rd = reflect(rd, n);\n    return vec3(0.5,0.5,1.0)*(.1+.5*n.z+.5*max(rd.z,0.));\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0,0,0,1);\n#if 0\n    \/\/ 2D\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n    vec3 col = vec3(normalize(getVal(iChannel0,xy).yzw).z);\n    fragColor = vec4(col,1);\n#else\n    \/\/ 3D\n    float perspective = 4.0;\n    float scale = 0.6*height;\n    float rx = 0.15*PI;\n    float rz = -0.3*PI;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = scale*perspective*w + view_box-vec3(0,0,0.1);\n    vec2 uv = 2.*fragCoord.xy\/iResolution.xy - 1.;\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, perspective*iResolution.y);\n    rd = normalize(rd);\n    float t0, t1;\n    if (boxIntersection(ro-view_box, rd, t0, t1)) {\n        fragColor.xyz = render(ro, rd, t0, t1);\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n\n\/\/ pass uniform variables to common\n#define uniforms_params vec3 iResolution, vec4 iMouse, int iFrame\n#define uniforms_call iResolution, iMouse, iFrame\n\n\/\/ simulation dimension in meters\n#define height (2.)\n#define width (height*(iResolution.x\/iResolution.y))\n#define view_box (.5*vec3(width,height,1))\n\n\/\/ time in seconds (60 fps)\n#define delta_t (0.01\/60.)\n#define time (float(iFrame)*(delta_t))\n\n\/\/ sampling buffer\n#define getH(xy) (texture(sampler,(xy)\/vec2(width,height)).x)\n#define getU(xy) (texture(sampler,(xy)\/vec2(width,height)).y*((xy).x<=0.||(xy).x>=width?-1.:1.))\n#define getV(xy) (texture(sampler,(xy)\/vec2(width,height)).z*((xy).y<=0.||(xy).y>=height?-1.:1.))\n\n\/\/ numerical differentiation step in meters\n#define nds vec3(vec2(width,height)\/iResolution.xy,0)\n\n\/\/ used in initial condition and mouse interaction, integrates to 0\n#define bump(r) (cos(1.8483*(r))*exp(-(r)*(r)))\n\n\n\/\/ outputs (h,u,v), (\u2202h\/\u2202t,\u2202u\/\u2202t,\u2202v\/\u2202t)\n\/\/ sampler wrap needs to be \"clamp\"\nvoid diffequ(sampler2D sampler, float t, vec2 xy,\n             out vec3 huv, out vec3 huvt,\n             uniforms_params) {\n\n    \/\/ parameters\n    const float h0 = 0.5;  \/\/ mean height (m)\n    const float g = 9.8;  \/\/ acceleration due to gravity (m\/s\u00b2)\n    const float f = .0001;  \/\/ Coriolis coefficient (rad\/s)\n    const float k = 0.1;  \/\/ viscous drag for velocity\n    const float nu = .001;  \/\/ kinematic viscosity (m\u00b2\/s), 1e-6 in reality\n\n    \/\/ height of water surface\n    float h = getH(xy);\n    float hx1 = getH(xy+nds.xz);\n    float hx0 = getH(xy-nds.xz);\n    float hy1 = getH(xy+nds.zy);\n    float hy0 = getH(xy-nds.zy);\n    float hx = (hx1-hx0) \/ (2.*nds.x);\n    float hy = (hy1-hy0) \/ (2.*nds.y);\n\n    \/\/ horizontal velocity\n    float u = getU(xy);\n    float ux1 = getU(xy+nds.xz);\n    float ux0 = getU(xy-nds.xz);\n    float uy1 = getU(xy+nds.zy);\n    float uy0 = getU(xy-nds.zy);\n    float ux = (ux1-ux0) \/ (2.*nds.x);\n    float uy = (uy1-uy0) \/ (2.*nds.y);\n    float ulap = (ux1+ux0-2.*u)\/(nds.x*nds.x) + (uy1+uy0-2.*u)\/(nds.y*nds.y);\n\n    \/\/ vertical velocity\n    float v = getV(xy);\n    float vx1 = getV(xy+nds.xz);\n    float vx0 = getV(xy-nds.xz);\n    float vy1 = getV(xy+nds.zy);\n    float vy0 = getV(xy-nds.zy);\n    float vx = (vx1-vx0) \/ (2.*nds.x);\n    float vy = (vy1-vy0) \/ (2.*nds.y);\n    float vlap = (vx1+vx0-2.*v)\/(nds.x*nds.x) + (vy1+vy0-2.*v)\/(nds.y*nds.y);\n\n    \/\/ https:\/\/en.wikipedia.org\/wiki\/Shallow_water_equations#Non-conservative_form\n    float ht = -h*(ux+vy) -u*hx-v*hy;\n    float ut = -g*hx -u*ux-v*uy +nu*ulap -k*u+f*v;\n    float vt = -g*hy -u*vx-v*vy +nu*vlap -k*v-f*u;\n\n    \/\/ mouse interaction\n    if (iMouse.z > 0.) {\n        float r = 20.*length(xy-vec2(width,height)*iMouse.xy\/iResolution.xy);\n        h += 8.*bump(r)*delta_t;\n    }\n\n    \/\/ initial state\n    if (iFrame < 1) {\n        float r = 20.*length(xy-vec2(.4,.3)*vec2(width,height));\n        h = h0 + .2*bump(r);\n        u = v = 0.;\n        ht = ut = vt = 0.;\n    }\n\n    \/\/ output\n    huv = vec3(h, u, v);\n    huvt = vec3(ht, ut, vt);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec3 huv, huvt;\n    diffequ(iChannel0, time, xy, huv, huvt, uniforms_call);\n\n    huv += huvt * delta_t;\n\n    fragColor = vec4(huv, 0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"sdlSDH","date":"1656020183","viewed":7,"name":"Snowflake-7557558","username":"harry7557558","description":"A Shadertoy version of the snowflake on my website homepage, which is also my bot's PFP.\n[url]https:\/\/harry7557558.github.io\/[\/url]","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["snowflake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define glow int(0.25*mod(iTime,10.))\n#define glowEffect (glow==0?bvec4(0,0,0,0):glow==1?bvec4(1,0,0,0):bvec4(1,1,0,0))\n\n#define PI 3.14159265368979\n#define ZERO min(iFrame,0)\n\nfloat sqr(vec2 x) {return dot(x,x);}\nfloat det(vec2 a, vec2 b) {return a.x*b.y-a.y*b.x;}\n\nfloat sd_wedge(vec2 p, vec2 a, vec2 c, vec2 b) {\n\tp -= c, a -= c, b -= c;\n\tfloat da = sqr(p - a * max(dot(p, a) \/ dot(a, a), 0.0));\n\tfloat db = sqr(p - b * max(dot(p, b) \/ dot(b, b), 0.0));\n\tfloat sign = det(a, b) > 0.0 ? max(det(b, p), det(p, a)) : max(det(a, p), det(p, b));\n\treturn sqrt(min(da, db)) * (sign > 0.0 ? 1.0 : -1.0);\n}\n\nfloat hexagon(vec2 p, float r) {\n\treturn dot(vec2(0.866025404, 0.5), p) - 0.866025404*r;\n}\n\nfloat map(vec2 p0) {\n\tfloat a = abs(asin(sin(3.0*atan(p0.y,p0.x)))) \/ 3.0;\n\tvec2 p = length(p0.xy)*vec2(cos(a), sin(a));\n\ta = abs(asin(sin(3.0*atan(p0.x,p0.y)))) \/ 3.0;\n\tvec2 q = length(p0.xy)*vec2(sin(a), cos(a));\n\n\tfloat d = 1e+12;\n\td = min(d, 0.1*hexagon(p, 0.15));\n\td = min(d, 0.5*hexagon(p, 0.1));\n\td = min(d, 1.0*max(sd_wedge(p, vec2(0.0, 0.0), vec2(0.0, 0.01), vec2(2.0, 0.0)), p.x - 1.25));\n\td = min(d, 0.3*sd_wedge(p, vec2(0.2, 0.0), vec2(0.3, 0.1), vec2(0.25, 0.0)));\n\td = min(d, 0.3*sd_wedge(p, vec2(0.3, 0.0), vec2(0.4, 0.1), vec2(0.35, 0.0)));\n\td = min(d, 0.5*(length(p - vec2(0.45, 0.0)) - 0.04));\n\td = min(d, 0.3*sd_wedge(p, vec2(0.48, 0.0), vec2(0.56, 0.13), vec2(0.55, 0.0)));\n\td = min(d, 0.2*sd_wedge(p, vec2(0.5, 0.0), vec2(0.8, 0.12), vec2(1.0, 0.0)));\n\td = min(d, 0.3*sd_wedge(p, vec2(0.9, 0.0), vec2(1.1, 0.1), vec2(1.0, 0.0)));\n\td = min(d, 0.3*sd_wedge(p, vec2(1.1, 0.0), vec2(1.2, 0.05), vec2(1.15, 0.0)));\n\td = min(d, 1.0*sd_wedge(q, vec2(0.0, 0.0), vec2(0.01, 0.0), vec2(0.0, 0.5)));\n\td = min(d, length(q - vec2(0.0, 0.18)) - 0.02);\n\td = min(d, length(q - vec2(0.0, 0.24)) - 0.02);\n\td = min(d, 0.3*sd_wedge(q, vec2(0.0, 0.2), vec2(0.05, 0.7), vec2(0.0, 0.65)));\n\td = min(d, 0.3*sd_wedge(q, vec2(0.0, 0.65), vec2(0.03, 0.65), vec2(0.0, 0.75)));\n\treturn d - 0.001;\n}\n\n\nvec3 get_background(vec3 rd) {\n    \/\/ generic background, for the website\n    vec3 col = (0.4+0.1*sin(iTime)+0.1*sin(0.5*iTime))\n        * vec3(0.5 + 1.0*dot(rd,vec3(0.5,0.5,-0.5))\n        + 0.6*sin(5.*rd.x)*sin(5.*rd.y)*sin(5.*rd.z)\n        + 0.3*cos(10.*rd.x)*cos(10.*rd.y)*cos(10.*rd.z)\n        + 0.2*cos(20.*rd.x)*cos(20.*rd.y)*cos(20.*rd.z)\n        + 0.05*sin(45.*rd.x)*cos(44.*rd.y)*sin(46.*rd.z));\n    \/\/ cubemap background, used in my bot's PFP\n    col = vec3(texture(iChannel0, rd));\n\n    col = vec3(1.0)-exp(-col);\n    return clamp(col * vec3(0.2,0.2,1.0), 0.0, 1.0);\n}\nvec3 hsv2rgb(vec3 hsv) {\n    \/\/ https:\/\/github.com\/hughsk\/glsl-hsv2rgb\n    vec4 k = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ setup camera\n    float iDist = 6.0;\n\n    float rx = iMouse.z>0.?1.57+1.0*(2.0*iMouse.y\/iResolution.y-1.0):1.4+0.5*sin(0.1*iTime);\n    float rz = iMouse.z>0.?-iMouse.x\/iResolution.x*2.0*3.14:0.2*iTime-2.0;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec2 uv = 2.0 * gl_FragCoord.xy \/ iResolution.xy - vec2(1.0) - vec2(0.0, 0.05);\n    vec3 rd = normalize(mat3(u,v,-w)*vec3(uv*iResolution.xy,4.0*min(iResolution.x,iResolution.y)));\n    vec3 ro = iDist*w + (iDist-2.0)*rd;\n\n    \/\/ sample snowflake\n    float t = -ro.z \/ rd.z;\n    ro += rd*t;\n    float sd = map(ro.xy);\n\n    \/\/ shade snowflake\n    vec3 col = glowEffect.y ?\n        0.4 * pow(hsv2rgb(vec3(iTime,1.0,1.0)), vec3(0.5)) :\n        0.8 * vec3(0.8,0.4,0.6);\n\n    float spark = pow(0.3656*abs(sin(0.5*iTime)+2.0*sin(iTime)),20.0);\n    col += spark * 0.2*vec3(0.8,0.6,0.2);\n\n    float mask = clamp(-1.4*min(iResolution.x,iResolution.y)*sd, 0.0, 1.0);\n    if (glowEffect.x) mask += (glowEffect.y?1.2:0.5)*exp(-6.0*max(sd,0.));\n    mask *= exp(30.0 * sd \/ rd.z);\n\n    \/\/ color output\n    vec3 background = get_background(rd);\n    vec3 snowflake = col * mask;\n    vec3 color = background + snowflake;\n    color += vec3(1.5\/255.)*fract(0.13*gl_FragCoord.x*gl_FragCoord.y);  \/\/ reduce \"stripes\"\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wttGDB","date":"1577836293","viewed":26,"name":"Sound Test 0x00000001","username":"harry7557558","description":"temp","likes":0,"published":2,"flags":8,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec2 a = calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 mainSound( in int samp,float time){\n    return calcSound(time);\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\/\/https:\/\/i.stack.imgur.com\/1NN4r.png\n\n#if 0\n\nconst int NS = 128;\nconst float dirS = 12.0;\nconst float vS = 240.0\/60.0;\nconst int S[NS] = int[NS](\n    42,51,49,47,42,00,00,42,\n    42,51,49,47,44,00,00,00,\n    44,52,51,49,46,00,00,00,\n    54,54,52,49,51,00,00,00,\n    42,51,49,47,42,00,00,00,\n    42,51,49,47,44,00,00,44,\n    44,52,51,49,54,54,54,54,\n    56,54,52,49,47,00,00,00,\n    51,51,51,00,51,51,51,00,\n    51,54,47,49,51,00,00,00,\n    52,52,52,52,52,51,51,51,\n    51,49,49,51,49,00,54,00,\n    51,51,51,00,51,51,51,00,\n    51,54,47,49,51,00,00,00,\n    52,52,52,52,52,51,51,51,\n    54,54,52,49,47,00,00,00\n);\n\n#define BASS\nconst int NE = 128;\nconst float dirE = 12.0;\nconst float vE = 240.0\/60.0;\nconst int E[NE] = int[NE](\n    35,00,42,00,35,00,42,00,\n    35,00,42,00,28,00,35,00,\n    28,00,35,00,30,00,37,00,\n    30,00,42,00,35,00,42,00,\n    35,00,42,00,35,00,42,00,\n    35,00,42,00,28,00,35,00,\n    28,00,35,00,30,00,37,00,\n    34,00,42,00,35,00,42,00,\n    35,47,42,47,35,47,42,47,\n    35,47,42,49,35,47,42,47,\n    40,52,47,52,35,47,42,47,\n    37,49,44,49,42,40,39,37,\n    35,47,42,47,35,47,42,47,\n    35,47,42,49,35,47,42,47,\n    40,52,47,52,35,47,42,47,\n    37,49,44,49,42,40,39,37\n);\n\n#else\n\nconst int NS = 128;\nconst float dirS = 14.0;\nconst float vS = 284.0\/60.0;\nconst int S[NS] = int[NS](\n    47,48,40,47,00,48,00,00,\n    47,48,40,48,00,47,00,38,\n    45,47,38,45,00,47,00,38,\n    43,00,00,00,41,00,00,00,\n    47,48,40,47,00,48,00,00,\n    48,47,40,48,00,47,00,38,\n    45,47,38,45,00,47,00,38,\n    43,00,00,00,42,00,00,38,\n    40,00,40,00,40,00,40,40,\n    40,38,36,36,00,00,36,36,\n    38,38,00,00,00,36,35,33,\n    00,00,00,00,00,00,00,33,\n    40,40,40,40,00,00,43,43,\n    40,00,00,00,00,00,36,36,\n    38,40,00,00,00,38,36,38,\n    00,00,00,00,00,00,00,00\n);\n\n#define BASS\nconst int NE = 16;\nconst float dirE = 2.0;\nconst float vE = 35.5\/60.0;\nconst int E[NE] = int[NE](\n    45,41,43,38,45,41,43,38,\n    40,36,38,38,40,36,38,38\n);\n\n#endif\n\n\n\n\n\/\/=====================================================================\n\n\n\n#define freq(n) 440.0*exp2(((n)-49.0)\/12.0)\n\n#define sinWave(f,t) sin(6.283185307*(f)*(t))\n#define triWave(f,t) (2.0*abs(2.0*fract(f*t-0.25)-1.0)-1.0)\n#define sqrWave(f,t) (fract((f)*(t))>0.5?-0.5:0.5)\n#define sthWave(f,t) (2.0*fract((f)*(t)-0.5)-1.0)\n#define wave(f,t) sinWave(f,t)\n\nfloat calcS(float t){\n    t*=vS;\n    int n = S[int(t)%NS];\n    if (n==0) return 0.0;\n    t=fract(t);\n    float m = t<0.9?1.0:mix(1.0,0.0,10.0*(t-0.9));\n    float f = freq(float(n)+dirS);\n    return m*wave(f,t\/vS);\n}\n\n#ifdef BASS\nfloat calcE(float t){\n    t*=vE;\n    int n = E[int(t)%NE];\n    if (n==0) return 0.0;\n    t=fract(t);\n    float m = t<0.9?1.0:mix(1.0,0.0,10.0*(t-0.9));\n    float f = freq(float(n)+dirE);\n    return m*wave(f,t\/vE);\n}\n#endif\n\n\n\nfloat beep(float t){\n    \/\/ pretty obivious in the image but sounds really horrible\n    return mod(t,2.0)<1.0?0.0:0.005*tan(2764.6*t);\n}\n\nvec2 calcSound(float time){\n    float a = calcS(time);\n#ifdef BASS\n    float b = calcE(time);\n#else\n    float b = a;\n#endif\n    \/\/return 0.1*vec2(a,b)+beep(time);\n    return 0.1*vec2(a,b);\n}\n\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"wdGcDV","date":"1603765395","viewed":6,"name":"Sound Test 0x00000006","username":"harry7557558","description":"physics isu","likes":0,"published":2,"flags":8,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Explore the relations between the sound frequency and the perceived loudness\n\n\/\/ See Common tab for details\n\n\n\/\/ visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord\/iResolution.xy;\n    float w = 0.1*calcSound(0.01*uv.x+iTime);\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ May have problems with some web browsers \/ hardwares\n\/\/ Rewind (reset time) if the waveform looks weird after a while\n\n\n\/\/ The frequency is calculated as:\n\/\/ f = 100Hz*e^(0.1*time)\n\n\n\/\/ Set `ps` to:\n\n\/\/ 0: amplitude independent to the frequency (constant amplitude)\n\/\/ 1: amplitude inversely propotional to the frequency\n\/\/ 2: amplitude inversely propotional to the square of the frequency\n\/\/ n: amplitude inversely propotional to the nth power of the frequency\n\n\/\/ The amplitude should be the same for all ps at f=262Hz (t\u224810s)\n\n#define ps 1\n\n\n\nfloat calcSound(float t){\n    float freq = 100.*exp(0.1*t); \/\/ frequency\n    float amp = pow(262.\/freq,float(ps));  \/\/ amplitude\n    float pos = amp*sin(6.283185*freq*t);  \/\/ vibration position\n    return pos;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"\/\/ see Common tab\n\nvec2 mainSound( in int samp,float time) {\n    return vec2(calcSound(time));\n}\n\n","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"sdc3R2","date":"1630185108","viewed":195,"name":"Tooth (neural volume)","username":"harry7557558","description":"I just see a lot of siren shaders and want to have a try.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["volume","tooth","neural","network","siren"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Volume source: https:\/\/klacansky.com\/open-scivis-datasets\/ (1.43MB, modified)\n\n\/\/ Ground truth:\n\/\/ https:\/\/harry7557558.github.io\/Graphics\/raytracing\/webgl_volume\/index.html#volume=tooth&visual=skinbone&colormap=cThermometer&iso=0.500\n\/\/ (much faster rendering, looks better\/worse?)\n\n\/\/ Trained in TensorFlow with Adam optimizer, mean squared error, equal weight for each voxel\n\n\n\/\/ Siren neural net, defined in -1 < x,y,z < 1\nfloat neuralVolume(in vec3 p) {\nvec4 f00=sin(p.x*vec4(.135,-.92,.997,.893)+p.y*vec4(.345,.911,-.651,-1.521)+p.z*vec4(-.825,.656,-.139,.463)+vec4(-.428,.988,-.046,-.945));\nvec4 f01=sin(p.x*vec4(.025,1.443,-1.637,.75)+p.y*vec4(-1.56,-1.163,-.861,.431)+p.z*vec4(-1.054,.9,.071,.182)+vec4(-.201,1.218,-.115,-.13));\nvec4 f02=sin(p.x*vec4(1.734,-.576,-2.458,1.011)+p.y*vec4(.851,.527,.45,3.14)+p.z*vec4(-1.08,-.05,.364,.691)+vec4(.826,-.068,.883,.768));\nvec4 f03=sin(p.x*vec4(.613,-1.078,-.187,-1.355)+p.y*vec4(.051,-2.254,1.874,-.106)+p.z*vec4(1.081,-1.454,2.599,1.164)+vec4(1.106,-.922,-.243,.976));\nvec4 f10=sin(mat4(.237,1.184,-.33,-.309,.159,-.064,-1.225,.508,-.225,-.165,.229,-.875,.076,.21,.066,-.435)*f00\n    +mat4(.314,1.199,.731,-.684,-.823,-.291,-.164,-.045,-.91,-.19,.737,-.423,-.123,.186,-.421,.414)*f01\n    +mat4(-.115,-.24,-.15,-.717,.602,.069,-.02,1.011,.675,.108,.622,-.361,.271,-.1,-.129,.324)*f02\n    +mat4(-.423,-.41,.885,-.368,.071,.488,.829,1.093,-.33,-.02,.687,.951,-.645,-.794,1.003,-1.404)*f03\n    +vec4(-.314,.42,.682,.317));\nvec4 f11=sin(mat4(.623,-.917,-.059,-.484,.052,-.276,.139,-.057,.517,.572,-.709,-.641,-.634,.198,-.309,.73)*f00\n    +mat4(.848,-.171,-1.178,-.745,-.204,-.572,-.527,-.213,1.727,.241,.068,.143,-.447,.469,.724,.306)*f01\n    +mat4(.76,-.992,.072,-.405,-.568,-.705,.697,.529,-.335,.303,.432,.145,.04,-.056,.288,.171)*f02\n    +mat4(-.274,.7,-.054,-.363,.056,-.209,.752,.272,-.394,.361,.048,.035,-.176,.607,-.182,.402)*f03\n    +vec4(.498,.69,.346,.271));\nvec4 f12=sin(mat4(-.002,-.7,.11,-.593,1.26,-.066,-.275,-.545,-.502,.698,.187,-.258,-.593,-.014,.767,.504)*f00\n    +mat4(-.788,-.514,-.677,.159,-.181,.25,1.02,.09,.432,-.637,-.284,-1.395,-.355,.422,.785,.94)*f01\n    +mat4(.921,1.168,-.1,-.368,.65,-.37,-.272,-.237,.1,-.382,-1.027,-.366,.283,-.588,.271,.115)*f02\n    +mat4(-.317,1.604,.237,.099,.279,-.171,-.186,-.055,-.186,.185,.531,.769,-1.034,-.079,.731,.179)*f03\n    +vec4(.315,.32,.234,-.247));\nvec4 f13=sin(mat4(.432,.461,-.251,-.908,.118,.238,-.62,.765,.697,.838,.623,-.889,.589,-1.182,.556,.012)*f00\n    +mat4(.439,.094,.068,-.764,-.284,-.376,-.227,.695,-.842,.786,.325,.366,.96,-.432,-1.067,-.669)*f01\n    +mat4(-1.989,-.098,-.284,-.049,.168,.028,-.32,.836,-.263,.361,.243,-.538,.396,.685,-.115,-.6)*f02\n    +mat4(.142,.179,-.491,-.033,.666,-.194,.313,-.496,.953,-.925,.257,.116,-.007,-.351,-.388,1.296)*f03\n    +vec4(-.286,.268,.283,.384));\nvec4 f20=sin(mat4(1.067,.576,.5,-1.351,1.617,.496,-.806,-.089,-.99,.11,.77,-.887,.573,.052,-1.012,1.272)*f10\n    +mat4(-.509,.281,.883,-.813,-.399,-1.383,-.242,1.315,-.499,.01,-.12,1.965,-.121,-.214,-2.116,-1.099)*f11\n    +mat4(.901,.547,.566,-2.171,-.461,-.476,.454,.768,-1.299,-.416,.3,-.383,.142,-.181,-.009,.49)*f12\n    +mat4(-.097,.154,.28,1.032,-.722,.505,-.243,-.543,-.404,-.341,-1.44,.607,-1.119,-.307,.489,-1.45)*f13\n    +vec4(-.528,.114,-1.355,.252));\nvec4 f21=sin(mat4(-.557,1.041,-.158,.194,-.752,.698,-.197,-.19,-.001,-.476,-.422,.448,-.181,.869,.953,-.999)*f10\n    +mat4(.201,.42,-.784,-.225,.706,-.481,-.053,-.872,.126,-.226,-.153,-.126,-.046,.366,-.939,-.012)*f11\n    +mat4(-.417,-.122,-1.034,.703,.524,-.386,.321,-.627,.381,.476,.171,-.402,.319,.038,.652,-.168)*f12\n    +mat4(-.266,.401,1.156,-.259,-.405,1.071,.893,.748,-.134,.318,.808,.448,.217,-.316,-.825,.276)*f13\n    +vec4(.122,.251,-.471,-.455));\nvec4 f22=sin(mat4(-.305,1.162,.973,-.676,.767,-1.133,1.428,-.979,-1.136,1.027,-1.219,.286,.618,.265,1.458,-.905)*f10\n    +mat4(.54,-.608,-.982,.567,.95,-.17,-.41,.435,-.303,.344,.365,.071,.476,-1.229,.844,-.176)*f11\n    +mat4(.638,-.702,.295,.409,.565,-.454,-1.215,.15,.073,-.058,-1.183,.654,.733,-.836,-.686,-.318)*f12\n    +mat4(.014,-.521,.263,-.234,-1.002,.819,.821,-.636,-1.256,-1.13,1.972,-.295,-.522,.21,-1.572,.714)*f13\n    +vec4(.185,-.447,.147,.098));\nvec4 f23=sin(mat4(-1.731,.056,.409,.383,.686,-.257,-.788,.816,-.286,.455,-.436,-.631,-.877,-.547,-.16,1.115)*f10\n    +mat4(.72,.585,1.283,-.416,-.108,.838,.228,-.616,-.188,-.517,-1.421,.339,-.07,.594,.406,1.143)*f11\n    +mat4(-.033,.243,1.652,.793,-.308,1.091,.522,-.488,-.253,.923,.113,-.276,-.714,-.292,-.316,-.049)*f12\n    +mat4(-.091,-.93,-.056,.757,-.748,-.943,-.746,.662,.657,-.903,-.781,.594,.302,.593,-1.175,-.572)*f13\n    +vec4(.231,-.572,.081,.417));\nvec4 f30=sin(mat4(.315,.409,.083,.363,-1.403,.808,-.4,-.939,-.884,.19,-.307,-.108,.514,-.2,.185,-.058)*f20\n    +mat4(-.128,.494,.029,-.702,.599,-.318,-.25,-.187,1.227,-.095,.094,-.128,.654,-.295,-.511,.316)*f21\n    +mat4(.183,.325,.106,.282,-.856,.088,-.24,-.001,.817,-.571,.114,-.437,-.973,.449,-.11,.282)*f22\n    +mat4(-.667,-.02,-.083,.162,.015,-.363,-.605,-.683,.239,-.088,.156,.159,.832,-.301,.224,.395)*f23\n    +vec4(.043,-.11,-.304,-.07));\nvec4 f31=sin(mat4(.473,.023,.568,.182,-.401,-.025,-.402,-1.307,-.338,-.286,.112,-.784,.107,.184,-.12,.415)*f20\n    +mat4(.373,-.005,-.018,-.133,.135,.298,-.421,.479,-.151,.395,-.615,.995,-.139,.448,-.313,.08)*f21\n    +mat4(.062,.051,.221,-.043,-.012,-.262,.467,-.65,.416,.164,-.003,.844,.042,-.205,-.186,-.835)*f22\n    +mat4(-.154,-.283,.331,-.52,-.621,.373,-.804,-.261,.298,-.063,.369,.261,.243,.142,-.225,.765)*f23\n    +vec4(-.224,-.446,.427,-.272));\nvec4 f32=sin(mat4(1.812,-.311,-.889,-.265,-2.924,-.344,2.515,-1.312,-2.656,.39,1.888,-.736,1.839,-.226,-1.219,.338)*f20\n    +mat4(.158,-.342,-.45,-.489,1.195,-.193,-.442,.789,1.664,-.668,-1.055,.804,.585,-.828,.254,-.43)*f21\n    +mat4(1.203,-.327,-.743,-.423,-2.251,.4,1.369,-.552,2.255,-.175,-1.347,.844,-.784,.501,.619,-.266)*f22\n    +mat4(-2.196,.307,1.213,-.512,-2.076,-.619,1.82,-.405,.963,-.051,-.593,.212,2.068,-.046,-1.471,.712)*f23\n    +vec4(1.433,-.302,-1.556,-.575));\nvec4 f33=sin(mat4(-1.071,.971,.6,-.127,.287,-.307,-.569,.175,.125,-.304,-.32,.016,-.145,.22,.04,-.074)*f20\n    +mat4(.326,-.204,.429,-.039,.521,-.318,-.023,-.054,.328,-.067,-.014,.046,.457,-.352,.354,-.259)*f21\n    +mat4(-.581,.496,.36,-.008,.203,-.336,-.024,.028,-.571,.695,-.111,-.28,.407,-.416,-.112,-.023)*f22\n    +mat4(.312,-.463,.008,-.018,.911,-.82,-.581,-.062,-.469,.448,.222,-.078,-.069,.165,.629,.03)*f23\n    +vec4(-.116,-.003,-.303,.134));\nreturn dot(vec4(-.43,-.112,-.491,.23),f30)+dot(vec4(.378,-.747,-.252,.696),f31)+dot(vec4(-.065,-.318,.122,-.303),f32)+dot(vec4(-.521,-.659,-.376,.469),f33)-.324;\n}\n\nconst vec3 BoxRadius = vec3(0.424, 0.398, 0.678);\n\nfloat map(vec3 p) {\n    p = p \/ BoxRadius;\n    return neuralVolume(-p);\n}\nvec3 mapNormal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return -normalize(map(p) - vec3(map(k[0]),map(k[1]),map(k[2])));\n}\n\n\/\/ rendering quality\n#define STEP 0.01\n#define MAX_STEP 120.\n\n\/\/ adjust this number to see what happens\n#define uIso 0.5\n\n\/\/ light, comment the line in mainImage if you like\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n\/\/ colormap - https:\/\/www.shadertoy.com\/view\/NsSSRK\nvec3 cThermometer(float t) {\n  float r = .453+.122*t+.385*cos(4.177*t-2.507);\n  float g = .284+.142*t+.554*cos(4.181*t-1.918);\n  float b = .464+.05*t+.475*cos(3.217*t-.809);\n  return vec3(r, g, b);\n}\n\n\/\/ constant step raymarching + volume sampling\nvec3 vSkinBone(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)\/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) \/ step_count;\n    float iso1 = 1.0-uIso;\n    float iso2 = 0.5-0.5*uIso;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old = 0.0, v;\n    for (t = t0; t < t1; t += dt) {\n        v = map(ro+rd*t);\n        vec3 col = clamp(cThermometer(v), 0.0, 1.0);\n        float absorb = abs(v-iso2)<0.2*(1.0-uIso) ? 20.0*uIso : 0.0;\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v > iso1) break;\n        v_old = v;\n    }\n    if (v < iso1) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = map(ro+rd*t);\n            if ((v-iso1)*(v_old-iso1)<0.0) break;\n        }\n    }\n    vec3 n = mapNormal(ro+rd*t);\n    float col = 0.2+0.05*n.y+0.6*max(dot(n, light),0.0);\n    return totcol + col * totabs;\n}\n\n\/\/ ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ set camera\n    float rx = iMouse.z>0.?3.14*(iMouse.y\/iResolution.y)-1.57:0.0;\n    float rz = iMouse.z>0.?-iMouse.x\/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n    rx += 1e-4, rz += 1e-4;  \/\/ prevent dividing by zero\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)\/min(iResolution.x,iResolution.y);\n    vec3 ro = 4.0*w + 0.8*(uv.x*u+uv.y*v);\n    vec3 rd = -w;\n\n    \/\/ comment this line if you wish\n    light = normalize(w+0.5*u+0.1*v);\n\n    \/\/ calculate pixel color\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = vSkinBone(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WtcSR2","date":"1586479391","viewed":225,"name":"Triangled","username":"harry7557558","description":"Tangled + Triangulated. Diving down to Hell.\n\n(stay 1min and watch it change)","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["tunnel","sound","sdf","triangle","hexagon","square"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-.5\/k*d*d+a+b-.5*k);\n}\n\n#define _23 0.666666667\n#define rt3 1.732050808\n#define r3_2 0.866025404\n#define _23r3 1.154700538\n#define _43r3 2.309401077\n\n\nvec2 map4(vec2 p){\n    p = abs(mod(p,2.0)-1.0);\n    return vec2(min(p.x,p.y),length(p));\n}\nfloat Map4(vec3 p){\n    vec2 d = map4(p.xy);\n    return smin(length(vec2(d.x,p.z)),d.y,0.2)-0.1;\n}\n\n\nvec2 map3(vec2 p){\n\tp = mod(p+vec2(_23r3,_23),vec2(_43r3,4.));\n\tif (p.y>2.) p.y=4.-p.y;\n\tif (p.x>_23r3) p.x=_43r3-p.x;\n\tif (p.y>rt3*p.x) p=vec2(_23r3,2.)-p;\n\treturn vec2(rt3*p.y<p.x?p.y:.5*(rt3*p.x-p.y),\n\t\tp.x+rt3*p.y<_43r3?length(p):length(p-vec2(_23r3,2.)));\n}\nfloat Map3(vec3 p){\n    vec2 d = map3(p.xy);\n    return smin(length(vec2(d.x,p.z)),d.y,0.2)-0.1;\n}\n\n\nfloat map6g(vec2 p){\n    p = mod(vec2(p.x,.5*p.x+r3_2*p.y),3.);\n    if (p.y>p.x) p=p.yx;\n    if (p.x+p.y>3.) p=vec2(3)-p.yx;\n    return p.y>1.?p.x-p.y:p.x>2.?abs(p.x-p.y-2.):p.y>p.x-1.?abs(p.x-1.):p.y;\n}\nfloat map6v(vec2 p){\n    p = mod(p,vec2(1,rt3)*2.);\n    if (p.x>1.) p.x=2.-p.x;\n    if (p.y>rt3) p.y=2.*rt3-p.y;\n    if (p.y<rt3*p.x) p=vec2(1.,rt3)-p;\n    return length(p-vec2(0,_23r3));\n}\nfloat Map6(vec3 p){\n    return smin(length(vec2(map6g(p.xy),p.z)),map6v(p.xy),0.2)-0.1;\n}\n\n\nfloat map(vec3 p){\n    p.z = mod(p.z,2.0)-1.0;\n    const float o = 2.;\n    float t = iTime;\n    if (t<16.-o) return Map6(p);\n    if (t<16.) return mix(Map4(p),Map6(p),(16.-t)\/o);\n    if (t<32.-o) return Map4(p);\n    if (t<32.) return mix(Map3(p),Map4(p),(32.-t)\/o);\n    if (t<48.-o) return Map3(p);\n    if (t<48.) return mix(map3(p.xy).x-.1,Map3(p),(48.-t)\/o);\n    if (t<60.-o) return map3(p.xy).x-.1;\n    if (t<60.) return mix(map3(p.xy).y,map3(p.xy).x,(60.-t)\/o)-.1;\n    return map3(p.xy).y-.1;\n}\n\nvec3 grad(vec3 p){\n    const float e = .001;\n\tfloat a = map(vec3(p.x+e,p.y+e,p.z+e));\n\tfloat b = map(vec3(p.x+e,p.y-e,p.z-e));\n\tfloat c = map(vec3(p.x-e,p.y+e,p.z-e));\n\tfloat d = map(vec3(p.x-e,p.y-e,p.z+e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\nbool intCirc(vec2 d, vec2 c, float r, inout float t, out vec2 n){\n    if (dot(c,d)<=0.0) return false;\n\tfloat d2 = c.x*d.y-c.y*d.x; if ((d2*=d2)>r*r) return false;\n\td2 = sqrt(dot(c,c)-d2)-sqrt(r*r-d2);\n    if (d2>t) return false; else t=d2;\n\tn = (d*t-c)\/r; return true;\n}\n\nvec3 getTexture(sampler2D G, vec3 p, vec3 n){\n    return ((n=abs(n)).x*texture(G,p.yz)+n.y*texture(G,p.xz)+n.z*texture(G,p.xy)).rgb\/(n.x+n.y+n.z);\n}\n\nvoid mainImage(out vec4 fcol, in vec2 coord){\n    float t = -2.0*iTime;\n    vec3 p = vec3(0,0,t+1.0);\n    vec2 uv = (coord - 0.5*iResolution.xy) \/ length(iResolution.xy);\n    vec3 d = normalize(vec3(uv,t)-p);\n    float dk = 1.0\/length(d.xy); vec2 d0 = d.xy*dk;\n    \n    vec3 n, k;\n    t = 1e8;\n    float r = .05*max(1.-1e-7*pow(iTime,4.),.0);\n    if (intCirc(d0,vec2(-1.2*r,-0.25),r,t,n.xy)\n       ||intCirc(d0,vec2(1.2*r,-0.25),r,t,n.xy)) {\n        p += (t*=dk)*d;\n    \tk = mix(vec3(0.2),vec3(1.0),max(n.y,0.));\n    \tk *= 2.0*getTexture(iChannel1,2.0*p,n);\n    }\n    else {\n    \tt = 0.0; float dt;\n    \tfor (int i=0;i<64;i++){\n    \t    dt = map(p+t*d);\n    \t    t += dt;\n    \t    if (dt<.01 || t>40.) break;\n    \t    float a = 0.05*dt, c=cos(a),s=sin(a);\n    \t    d.xy = mat2(c,s,-s,c)*d.xy;\n    \t}\n    \tp += d*t;\n    \tn = grad(p);\n    \tk = mix(vec3(0.2),vec3(1.0),max(n.z,0.));\n    \tk *= 3.0*getTexture(iChannel0,p,n);\n    }\n    fcol.xyz = k*exp(-0.2*t*vec3(1.0,0.8,0.6));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp,float t){\n    float t0 = t;\n    float f = t>64.?392.:(t=mod(t,4.))<1.?523.:t<2.?415.:392.;\n    t = 6.283185307*mod(t,4.);\n    return vec2(sin(f*t)*max(cos(8.*t),0.)*min(exp(64.-t0),1.));\n}\n","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"7lGXWK","date":"1641335188","viewed":147,"name":"Uniform Random Showcase 2D","username":"harry7557558","description":"An idea to showcase generating uniformly random points inside 2D shapes.\nLet me know about any idea to showcase 3D random functions.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","spiral","intersection","dof","bokeh","random","star","heart","polygon","cardioid","rose","shape","union","uniform","subtraction","vesica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ An idea to showcase generating uniformly random points inside 2D shapes\n\/\/ Each random function takes exactly two random values between 0 and 1, no rejection sampling\n\n\/\/ Functions are derived based on the following principles:\n\/\/ For circles\/spiral, solve for a constant Jacobian (equals the reciprocal of shape area)\n\/\/ For polygons\/stars, divide into multiple triangles\n\/\/ For explicit curves, apply inverse CDF sampling\n\/\/ If the inverse function cannot be solved analytically, start Newton-Raphson iteration at a point of inflection\n\n\/\/ Top to bottom, left to right:\n\/\/ - a circle\n\/\/ - a sector\n\/\/ - an ellipse\n\/\/ - a piecewise-elliptical heart\n\/\/ - a square\n\/\/ - a convex quadrilateral\n\/\/ - a regular polygon\n\/\/ - a regular polygonal star\n\/\/ - the area between two concentric circles\n\/\/ - the intersection of two circles\n\/\/ - the union of two circles\n\/\/ - the subtraction of two circles\n\/\/ - a cosine-based vesica-like shape\n\/\/ - a cardioid\n\/\/ - a rose curve\n\/\/ - a logarithmic spiral\n\n\/\/ See Buffer A\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = texelFetch(iChannel0,ivec2(coord),0).xyz;\n    col = vec3(0.8,1.0,1.2)*pow(col, vec3(0.7));\n    color = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n\n\n\/\/ ================ RANDOM FUNCTIONS START ================\n\n\/\/ unit circle\nvec2 randCircle(float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  \/\/ \u03b8\n    float v = sqrt(rand2);  \/\/ r\n    return v*vec2(cos(u), sin(u));\n}\n\n\/\/ sector with abs(\u03b8)<angle\nvec2 randSector(float angle, float rand1, float rand2) {\n    float u = angle*(2.0*rand1-1.0);  \/\/ \u03b8\n    float v = sqrt(rand2);  \/\/ r\n    return v*vec2(cos(u), sin(u));\n}\n\n\/\/ ellipse with major and minor radius\nvec2 randEllipse(float rx, float ry, float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  \/\/ \u03b8\n    float v = sqrt(rand2);  \/\/ r\n    vec2 circ = v * vec2(cos(u), sin(u));  \/\/ unit circle\n    return vec2(rx, ry) * circ;  \/\/ linear transform\n}\n\n\/\/ x\u00b2-|x|y+y\u00b2 < 1\nvec2 randHeart(float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  \/\/ \u03b8\n    float v = sqrt(rand2);  \/\/ r\n    vec2 c = v*vec2(cos(u), sin(u));  \/\/ unit circle\n    c = mat2(1.0,1.0,-0.577,0.577)*c;  \/\/ ellipse\n    if (c.x<0.0) c.y=-c.y;  \/\/ mirror\n    return c;\n}\n\n\/\/ -1 <= x,y < 1\nvec2 randSquare(float rand1, float rand2) {\n    float u = 2.0*rand1-1.0;\n    float v = 2.0*rand2-1.0;\n    return vec2(u, v);\n}\n\n\/\/ convex quadrilateral defined by ccw vertices\nvec2 randQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float rand1, float rand2) {\n    float u = rand1;\n    float v = rand2;\n    p1 -= p0, p2 -= p0, p3 -= p0;  \/\/ one point and three vectors\n    float area1 = 0.5*(p1.x*p2.y-p1.y*p2.x);  \/\/ area of the first triangle\n    float area2 = 0.5*(p2.x*p3.y-p2.y*p3.x);  \/\/ area of the second triangle\n    float th = area1 \/ (area1+area2);  \/\/ threshold to decide which triangle\n    if (u > th) p1 = p2, p2 = p3, u = (u-th)\/(1.0-th);  \/\/ use the second triangle\n    else u \/= th;  \/\/ use the first triangle\n    return p0 + mix(p1, p2, u) * sqrt(v);  \/\/ sample inside triangle\n    if (u+v>1.) u=1.-u, v=1.-v; return p0 + p1*u + p2*v;  \/\/ avoid square root, may or may not be faster\n}\n\n\/\/ regular n-gon with radius 1\nvec2 randPolygon(float n, float rand1, float rand2) {\n    float u = n*rand1;\n    float v = rand2;\n    float ui = floor(u);  \/\/ index of triangle\n    float uf = fract(u);  \/\/ interpolating in triangle\n    vec2 v0 = vec2(cos(2.*PI*ui\/n), sin(2.*PI*ui\/n));  \/\/ triangle edge #1\n    vec2 v1 = vec2(cos(2.*PI*(ui+1.)\/n), sin(2.*PI*(ui+1.)\/n));  \/\/ triangle edge #2\n    return sqrt(v) * mix(v0, v1, uf);  \/\/ sample inside triangle\n}\n\n\/\/ regular n-star with normalized size\nvec2 randStar(float n, float rand1, float rand2) {\n    float u = n*rand1;\n    float v = rand2;\n    float ui = floor(u);  \/\/ index of triangle\n    float uf = fract(u);  \/\/ interpolating in rhombus\n    vec2 v0 = vec2(cos(2.*PI*ui\/n), sin(2.*PI*ui\/n));  \/\/ rhombus edge #1\n    vec2 v1 = vec2(cos(2.*PI*(ui+1.)\/n), sin(2.*PI*(ui+1.)\/n));  \/\/ rhombus edge #2\n    vec2 p = v0 * v + v1 * uf;  \/\/ sample rhombus\n    return p \/ (n*sin(2.*PI\/n)\/PI);  \/\/ normalize size\n}\n\n\/\/ ring formed by two concentric circles with radius r0 and r1\nvec2 randConcentric(float r0, float r1, float rand1, float rand2) {\n    float u = 2.0*PI*rand1;  \/\/ \u03b8\n    float v = sqrt(mix(r0*r0, r1*r1, rand2));  \/\/ r\n    return v * vec2(cos(u), sin(u));  \/\/ polar to Cartesian\n}\n\n\/\/ intersection of two circles with centers (0,\u00b1c) and radius r\nvec2 randIntersection(float c, float r, float rand1, float rand2) {\n    \/\/ https:\/\/www.desmos.com\/calculator\/sctxdxh1td\n    float u = rand1;\n    float v = 2.0*rand2-1.0;\n    float x1 = sqrt(r*r-c*c);  \/\/ x range [-x1, x1]\n    float i1 = 0.5*r*r*asin(x1\/r)+0.5*x1*sqrt(r*r-x1*x1)-c*x1;  \/\/ area under the curve from 0 t0 x1\n    u = 2.0*i1*u - i1;  \/\/ u = Integral[0,x1,sqrt(x^2+y^2-c)]\n    float x = 0.0;  \/\/ solve for the x-coordinate\n    for (int iter=0; iter<6; iter++) {  \/\/ Newton-Raphson\n        float cdf = 0.5*(r*r*asin(x\/r)+x*sqrt(r*r-x*x))-c*x;\n        float pdf = sqrt(r*r-x*x)-c;\n        x -= (cdf-u)\/pdf;\n    }\n    float y = (sqrt(r*r-x*x)-c) * v;  \/\/ y-coordinate\n    return vec2(x, y);\n}\n\n\/\/ union of two circles with centers (\u00b1c,0) and radius r\nvec2 randUnion(float c, float r, float rand1, float rand2) {\n    \/\/ https:\/\/www.desmos.com\/calculator\/ddyum0rkgw\n    float u = 2.0*rand1-1.0;\n    float v = 2.0*rand2-1.0;\n    float s = sign(u);\n    float x1 = r+c;  \/\/ (x1,0)\n    float h0 = sqrt(r*r-c*c);  \/\/ (0,h0)\n    float i0 = -0.5*(c*h0+r*r*atan(c\/h0));  \/\/ defaultIntegral(0.0)\n    float i1 = 0.25*PI*r*r;  \/\/ defaultIntegral(1.0)\n    u = mix(i0, i1, abs(u));  \/\/ x = defaultIntegral(u)\n    float x = c;  \/\/ iteration starts at a point of inflection\n    for (int iter=0; iter<6; iter++) {  \/\/ Newton-Raphson, solve for x\n        float pdf = sqrt(r*r-(x-c)*(x-c));\n        float cdf = 0.5*((x-c)*pdf+r*r*atan((x-c)\/pdf));\n        x -= (cdf-u)\/pdf;\n    }\n    float y = sqrt(r*r-(x-c)*(x-c)) * v;  \/\/ y-coordinate\n    return vec2(s*x, y);\n}\n\n\/\/ subtraction of a circle with center (c,0) from a circle with (0,0)\nvec2 randSubtraction(float c, float r, float rand1, float rand2) {\n    \/\/ https:\/\/www.desmos.com\/calculator\/jk1okdxoks\n    float u = rand1;\n    float v = 2.0*rand2-1.0;\n    float x1 = 0.5*c;  \/\/ x in [-r, x1]\n    float y1 = sqrt(r*r-0.25*c*c);  \/\/ rightmost (x1,\u00b1y1)\n    float a1 = y1*c;  \/\/ area of the middle part\n    float i1 = 0.5*(x1*sqrt(r*r-x1*x1)+r*r*asin(x1\/r))-x1*y1;\n    float a2 = 2.0*i1;  \/\/ area of the top\/bottom part\n    float th = a1\/(a1+a2);  \/\/ decide the point lie in which part\n    if (u < th) {\n        float y = y1*v;  \/\/ y-coordinate\n        float x = c*(u\/th) - sqrt(r*r-y*y);  \/\/ x-coordinate, shear a rectangle\n        return vec2(x, y);\n    }\n    u = i1 * (2.*((u-th)\/(1.-th)) - 1.);  \/\/ x = defaultIntegral(u)\n    float x = 0.0;  \/\/ solve for x-coordinate\n    for (int iter=0; iter<6; iter++) {  \/\/ Newton-Raphson\n        float cdf = 0.5*(x*sqrt(r*r-x*x)+r*r*asin(x\/r))-y1*x;\n        float pdf = sqrt(r*r-x*x)-y1;\n        x -= (cdf-u)\/pdf;\n    }\n    float y = sign(v) * (y1+(sqrt(r*r-x*x)-y1)*abs(v));  \/\/ y-coordinate, note that v in [-1, 1)\n    return vec2(x, y);\n}\n\n\/\/ |y| < cos(x)-k\nvec2 randCosine(float k, float rand1, float rand2) {\n    float u = 2.0*rand1-1.0;  \/\/ related to x\n    float v = 2.0*rand2-1.0;  \/\/ related to y\n    float x1 = acos(k);  \/\/ maximum x\n    float y1 = sin(x1) - k*x1;  \/\/ a quarter of area\n    float yt = u*y1;  \/\/ randomly chosen area position\n    float x = 0.0;  \/\/ start iteration\n    for (int iter=0; iter<6; iter++) {  \/\/ Newton-Raphson\n        float cdf = sin(x)-k*x;\n        float pdf = cos(x)-k;\n        x -= (cdf-yt)\/pdf;\n    }\n    float y = cos(x)-k;  \/\/ calculate y from x\n    return vec2(x, y*v);  \/\/ apply random to y\n}\n\n\/\/ r(\u03b8) = 1-cos(\u03b8)\nvec2 randCardioid(float rand1, float rand2) {\n    \/\/ integrate (1-cos(\u03b8))\u00b2, find the inverse on [0,2\u03c0)\n    float u = 3.0*PI*rand1;  \/\/ integral is 3\u03c0\n    float v = sqrt(rand2);  \/\/ r\n    float theta = PI;  \/\/ iteration starting point\n    for (int iter=0; iter<10; iter++) {\n        float cdf = 0.25*(sin(2.0*theta)-8.0*sin(theta)+6.0*theta);  \/\/ integral\n        float pdf = (1.0-cos(theta))*(1.0-cos(theta));  \/\/ area element\n        theta -= (cdf-u)\/pdf;  \/\/ Newton-Raphson\n    }\n    float r = 1.0-cos(theta);  \/\/ polar equation\n    return v * r * vec2(cos(theta), sin(theta));  \/\/ polar coordinate\n}\n\n\/\/ r(\u03b8) = cos(n\u03b8)\nvec2 randRose(float n, float rand1, float rand2) {\n    \/\/ integrate cos(n\u03b8)\u00b2, split into n intervals and inverse in [-\u03c0\/2n,\u03c0\/2n)\n    float u = PI*rand1;  \/\/ integral in [0,2\u03c0) is \u03c0\n    float v = sqrt(rand2);  \/\/ r\n    float ui = PI\/n*floor(2.0*n\/PI*u);  \/\/ center of each \"petal\"\n    float uf = mod(u,PI\/(2.0*n))-PI\/(4.0*n);  \/\/ parameter of each \"petal\", integralOfCosNThetaSquared(\u03b8)\n    float theta = 0.0;  \/\/ iteration starting point\n    for (int iter=0; iter<9; iter++) {\n        float cdf = 0.5*theta + sin(2.0*n*theta)\/(4.0*n);  \/\/ integral of cos(n\u03b8)\u00b2\n        float pdf = 0.5 + 0.5*cos(2.0*n*theta);  \/\/ cos(n\u03b8)\u00b2\n        theta -= (cdf-uf)\/pdf;  \/\/ Newton-Raphson\n    }\n    theta = ui + theta;  \/\/ move to petal\n    float r = cos(n*theta);  \/\/ polar equation\n    return v * r * vec2(cos(theta), sin(theta));  \/\/ polar coordinate\n}\n\n\/\/ logarithmic spiral, solvable analytically\nvec2 randSpiral(float k, float a0, float a1, float rand1, float rand2) {\n    float s0 = exp(2.0*PI*k*a0), s1 = exp(2.0*PI*k*a1);  \/\/ r = s*exp(k\u03b8)\n    \/\/ (x,y)=s*exp(k\u03b8)*(cos(\u03b8),sin(\u03b8)), \u2202(x,y)\/\u2202(s,\u03b8)=s*exp(2k\u03b8), s*exp(2k\u03b8)*\u2202(s,\u03b8)\/\u2202(u,v)=(s1\u00b2-s0\u00b2)\/4k\n    \/\/ \u2202u\u2202v=(2s\/(s1\u00b2-s0\u00b2))\u2202s*(2kexp(2k\u03b8))\u2202\u03b8, integrate and invert to find \u03b8(u) and s(v)\n    float u = rand1;  \/\/ for angle\n    float v = rand2;  \/\/ for distance\n    float theta = log(1.0-u)\/(2.0*k);  \/\/ \u03b8(u)\n    float s = sqrt(mix(s0*s0, s1*s1, v));  \/\/ s(v)\n    return s * exp(k*theta) * vec2(cos(theta),sin(theta));  \/\/ formula\n}\n\n\/\/ ================ RANDOM FUNCTIONS END. ================\n\n\n\n\/\/ scene\nvec3 intersectRay(vec3 ro, vec3 rd) {\n    vec3 col = mix(vec3(0.0), 0.1*vec3(0.2,0.3,0.8), 0.5+0.5*sin(4.0*rd.x)*cos(4.0*rd.y)*sin(4.0*rd.z));\n    vec3 p;\n    \/\/ red\n    p = ro+rd*(-(ro.y+4.0)\/rd.y);\n    if (length(p.xz-vec2(-0.8,-0.8))<0.2) col+=20.0*vec3(1.0,0.3,0.1);\n    \/\/ yellow\n    p = ro+rd*(-(ro.y+10.0)\/rd.y);\n    if (length(p.xz-vec2(3.0,2.0))<0.2) col+=20.0*vec3(1.0,0.8,0.5);\n    \/\/ blue\n    p = ro+rd*(-(ro.y+20.0)\/rd.y);\n    if (length(p.xz-vec2(0.0,-1.5))<0.2) col+=20.0*vec3(0.1,0.6,1.0);\n    \/\/ green\n    p = ro+rd*(-(ro.y+50.0)\/rd.y);\n    if (length(p.xz-vec2(-12.0,1.0))<0.2) col+=40.0*vec3(0.1,1.0,0.4);\n    return col;\n}\n\n\/\/ quasi-random\nfloat vanDerCorput(float n, float b) {\n    float x = 0.0;\n    float e = 1.0 \/ b;\n    while (n > 0.0) {\n        float d = mod(n, b);\n        x += d * e;\n        e \/= b;\n        n = floor(n \/ b);\n    }\n    return x;\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ random number seed\n    vec3 p3 = fract(fragCoord\/iResolution.xy*.1031).xyx;\n    p3 += dot(p3, p3.zyx + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    float seed = floor(65536.*h) + float(iFrame);\n\n    \/\/ camera parameters\n    const vec3 POS = vec3(3.0,3.0,0.0);\n    const float SCALE = 1.5;  \/\/ larger = smaller (more view field)\n    const float DIST = 0.2;  \/\/ larger = smaller\n    const float VIEW_FIELD = 0.5;  \/\/ larger = larger + more perspective\n    const float APERTURE = 0.02;  \/\/ larger = blurred\n\n    \/\/ sample aperture shape\n    float rand1 = vanDerCorput(seed, 2.);\n    float rand2 = vanDerCorput(seed, 3.);\n    vec2 rnd;\n\n    ivec2 shape_id = ivec2(floor(4.0*fragCoord.xy\/iResolution.xy));\n    if (shape_id.y==3) {\n        if (shape_id.x==0) rnd = randCircle(rand1, rand2);\n        if (shape_id.x==1) rnd = randSector(0.8*PI, rand1, rand2);\n        if (shape_id.x==2) rnd = randEllipse(1.2, 0.8, rand1, rand2);\n        if (shape_id.x==3) rnd = randHeart(rand1, rand2);\n    }\n    if (shape_id.y==2) {\n        if (shape_id.x==0) rnd = randSquare(rand1, rand2);\n        if (shape_id.x==1) rnd = randQuad(vec2(-1.0,-1.0), vec2(0.8,-0.9), vec2(1.0,1.2), vec2(-0.4,0.8), rand1, rand2);\n        if (shape_id.x==2) rnd = randPolygon(5., rand1, rand2);\n        if (shape_id.x==3) rnd = randStar(5., rand1, rand2);\n    }\n    if (shape_id.y==1) {\n        if (shape_id.x==0) rnd = randConcentric(0.6, 1.1, rand1, rand2);\n        if (shape_id.x==1) rnd = randIntersection(0.9, 1.6, rand1, rand2);\n        if (shape_id.x==2) rnd = randUnion(0.6, 0.8, rand1, rand2);\n        if (shape_id.x==3) rnd = randSubtraction(1.0, 1.0, rand1, rand2);\n    }\n    if (shape_id.y==0) {\n        if (shape_id.x==0) rnd = randCosine(0.4, rand1, rand2);\n        if (shape_id.x==1) rnd = randCardioid(rand1, rand2);\n        if (shape_id.x==2) rnd = randRose(5., rand1, rand2);\n        if (shape_id.x==3) rnd = randSpiral(0.2, -0.1, 0.3, rand1, rand2);\n    }\n\n    \/\/ camera\n    vec3 ro = POS+vec3(0,DIST,0);\n    vec2 randuv = vec2(vanDerCorput(seed,5.), vanDerCorput(seed,7.));\n    vec2 uv = SCALE*(2.0*fract(4.0*(fragCoord.xy+randuv-0.5)\/iResolution.xy)-1.0);\n    vec2 sc = iResolution.xy\/length(iResolution.xy);\n    vec2 offset = APERTURE*rnd;\n    ro.xz += offset;\n    vec3 rd = vec3(VIEW_FIELD*uv*sc+vec2(-0.25,0.0)-offset\/DIST, -1.0).xzy;\n\n    \/\/ calculate pixel color\n    vec3 col = intersectRay(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(int(fragCoord.x), int(fragCoord.y)), 0);\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)\/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tlcXDM","date":"1581053690","viewed":42,"name":"Unnecessary Calculation","username":"harry7557558","description":"A new discovery made after a curious attempt - every time we calculate the distance to a quadratic bezier curve by solving a cubic equation, we made an unnecessary calculation.","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["sdf","bezier","root"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tA new discovery made after a curious attempt - every time we \n\tcalculate the distance to a quadratic bezier curve by \n\tsolving a cubic equation, we made an unnecessary calculation.\n\n\tThe usual way to solve cubic equation has 4 cases. Each case \n\tis represented in a different color - orange, purple, blue, \n\tand green. But in this demo, no matter how you choose three \n\tcontrol points, the green won't appear.\n\n\tI get this based on my observation without mathematical prove. \n\tIf you see green appear, please let me know.\n\n*\/\n\nvec3 col;  \/\/ color as global variable\n\n#define PI 3.14159265\n#define _13 0.33333333\n#define PI_3 1.04719755\nfloat SDBezier2(vec2 A, vec2 B, vec2 C, in vec2 P) {\n\tvec2 C2 = A-2.0*B+C, C1 = 2.0*(B-A), C0 = A-P, E;\n\tfloat t = 0.5\/dot(C2,C2),\n\t\ta = dot(C2,C1)*t, b = (2.0*dot(C2,C0)+dot(C1,C1))*t, c = dot(C1,C0)*t;\n\tfloat a2 = 9.0*a*a, p = (-a2*_13+b)*_13, q = 0.11111111*a*a2+0.5*(c-a*b),\n\t\tp3 = p*p*p, delta = q*q+p3;\n\tfloat sd, E2;\n\tif (delta>0.0) {  \/\/ one real root, show in orange\n\t\tdelta = sqrt(delta);\n\t\tt = (delta>q?pow(delta-q,_13):-pow(q-delta,_13))\n            -(delta+q>0.0?pow(delta+q,_13):-pow(-delta-q,_13));\n\t\tt = clamp(t-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t\tcol = vec3(.9,.6,.2);\n\t}\n\telse {  \/\/ three real roots\n        t = sqrt(-p), q = _13*acos(q\/(p*t)), p = 2.0*t;\n\t\t\/\/ the ever-existing real root, show in purple\n\t\tt = clamp(p*cos(q)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t\tcol = vec3(.8,.4,.6);\n\t\t\/\/ show in blue\n\t\tt = clamp(-p*cos(q-PI_3)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, E2 = dot(E,E);\n\t\tif (E2<sd) sd = E2, col = vec3(.3,.6,.9);\n\t\t\/\/ show in green, this color doesn't show up\n        \/\/ which means the following lines are unnecessary\n\t\tt = clamp(-p*cos(q+PI_3)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, E2 = dot(E,E);\n\t\tif (E2<sd) sd = E2, col = vec3(.4,.7,.6);\n\t}\n\treturn sqrt(sd);\n}\n\n\nfloat hash(float x){  \/\/ [-1,1)\n    return fract(sin(12.9898*x+12.87)*43758.5453)*2.0-1.0;\n}\nfloat noise(float x, float d){\n    return mix(hash(floor(x)+d),hash(ceil(x)+d),fract(x));\n}\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    float a = noise(iTime,0.5);\n    vec2 A = vec2(sin(a),cos(a))*noise(iTime,0.0);\n    a = noise(iTime,1.5);\n    vec2 B = vec2(sin(a),cos(a))*noise(iTime,1.0);\n    a = noise(iTime,2.5);\n    vec2 C = vec2(sin(a),cos(a))*noise(iTime,2.0);\n\n    vec2 p = 4.0*(Pos-0.5*iResolution.xy)\/length(iResolution.xy);\n    float d = SDBezier2(A,B,C,p);\n\tcol *= 1.0-exp(-3.0*abs(d));\n\tcol *= 0.8+0.2*cos(150.0*d);\n\tcol = mix(col,vec3(1.0),1.0-smoothstep(0.0,0.02,abs(1.2*d)));\n    Col = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3l2XWc","date":"1570296570","viewed":8,"name":"Untitled 0x00000001","username":"harry7557558","description":"temp","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\n#define EPSILON 1e-3\n\n#define MAX_STEP 1024\n#define MAX_DIST 200.0\n\n#define Unit 2000.0\n\n\nfloat map(vec3 p) {\n    float sd=sd_regularstar(1.618,1.0,5,p.xy);\n    sd = opExtrusion(sd,2.0,p+vec3(0,0,0));\n    return max(abs(abs(sd) - 0.3) - 0.1, p.z - 0.5);\n}\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = map(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = map(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = map(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = map(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n \/ (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d, vec3 light) {\n    \/\/ cast ray\n    float t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (map(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(p + t * d);\n\t\tt += dt;\n        if (dt < -EPSILON) return vec3(1.0,0.0,0.0);\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            vec3 col = vec3(1.0,1.0,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn t*t*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    \/\/ shadow\n    d -= 2.0 * dot(d, n)*n;\n\tfloat r = 1.0;\n\tt = 0.01;\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(P + t * light);\n\t\tr = min(r, 15.0 * dt \/ t);\n\t\tif (r < 0.001 || t > 2.0) break;\n\t\tt += clamp(dt, 1.0, 2.0)*clamp(length(p) \/ Unit, 0.002, 0.2);\n\t}\n\tr = clamp(r,0.0,1.0);\n    \n    \/\/ final result\n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.9*dif*r + 0.2*pow(max(dot(d,light),0.0),4.0) + 0.1)*vec3(0.9,0.8,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 4.0*(cos(0.4*iTime)+1.0)+3.0;\n    float r = sqrt(150.0-h*h) + 1.0*(cos(iTime)+1.0) + 8.0;\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 ctr = vec3(0.0,0.0,0.0);\n    vec3 dir = ctr-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(-0.3, 0.1, 1));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)\/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)\/float(AA)),Unit);\n        col += castRay(pos,normalize(d),light);\n    }\n    col\/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\nfloat det(vec2 a, vec2 b){\n    return a.x*b.y-b.x*a.y;\n}\n\nfloat sd_circle(float r, in vec2 p) {\n\treturn length(p) - r;\n}\n\nfloat sd_segment(vec2 v1, vec2 v2, in vec2 p) {\n\tfloat t = dot(v2 - v1, p - v1);\n\tif (t < 0.0) return length(p - v1);\n\tif (t > dot(v2-v1, v2-v1)) return length(p - v2);\n\treturn abs(det(normalize(v2 - v1), p - v1));\n}\n\nfloat sd_box(vec2 Min, vec2 Max, in vec2 p) {\t\/\/ order doesn't matter\n\tif (p.x > Min.x == p.x < Max.x) {\n\t\tif (p.y > Min.y == p.y < Max.y) {\n\t\t\treturn -min(min(abs(p.x - Min.x), abs(p.x - Max.x)), min(abs(p.y - Min.y), abs(p.y - Max.y)));\n\t\t}\n\t\treturn min(abs(p.y - Min.y), abs(p.y - Max.y));\n\t}\n\telse if (p.y > Min.y == p.y < Max.y) return min(abs(p.x - Min.x), abs(p.x - Max.x));\n\treturn min(min(length(p - Min), length(p - Max)), min(length(p - vec2(Min.x, Max.y)), length(p - vec2(Max.x, Min.y))));\n}\n\nfloat sd_triangle(vec2 a, vec2 b, vec2 c, in vec2 p) {\n\ta -= p, b -= p, c -= p;\n\tif ((int(det(a, b) > 0.0) + int(det(b, c) > 0.0) + int(det(c, a) > 0.0)) % 3 != 0) {\t\t\/\/ outside\n\t\tfloat t, m, d = 1e+30, td;\n\t\tt = dot(a - b, a), m = dot(b-a,b-a); if (t > 0.0 && t < m) d = abs(det(a, b - a)) \/ sqrt(m);\n\t\tt = dot(b - c, b), m = dot(c-b,c-b); if (t > 0.0 && t < m) { td = abs(det(b, c - b)) \/ sqrt(m); if (td < d) d = td; }\n\t\tt = dot(c - a, c), m = dot(a-c,a-c); if (t > 0.0 && t < m) { td = abs(det(c, c - a)) \/ sqrt(m); if (td < d) d = td; }\n\t\ttd = length(a); if (td < d) d = td;\n\t\ttd = length(b); if (td < d) d = td;\n\t\ttd = length(c); if (td < d) d = td;\n\t\treturn d;\n\t}\n\telse {\t\/\/ inside\n\t\tfloat d = abs(det(a, normalize(b - a)));\n\t\tfloat td = abs(det(b, normalize(c - b))); if (td < d) d = td;\n\t\ttd = abs(det(c, normalize(a - c))); if (td < d) d = td;\n\t\treturn -d;\n\t}\n}\n\nfloat sd_regularpolygon(float r, int n, in vec2 P) {\t\/\/ first vertex at (0,r)\n\tfloat ang = 2.0 * PI \/ float(n);\n\tfloat rang = atan(P.x,P.y);\n\tfloat a = rang - ang * float(int(rang \/ ang)); if (a < 0.0) a += ang;\n\tvec2 p = length(P) * vec2(cos(a), sin(a)) - vec2(r, 0.0), e = r * vec2(cos(ang) - 1.0, sin(ang));\n\ta = dot(p, e);\n\tif (a < 0.0) return length(p); if (a > dot(e,e)) return length(p - e);\n\treturn det(p, normalize(e));\n}\n\nfloat sd_regularstar(float R, float r, int N, in vec2 P) {\t\/\/ 0<r<R, first vertex at (0,R)\n\tfloat ang = 2.0 * PI \/ float(N);\n\tfloat rang = atan(P.x,P.y);\n\tfloat a = rang - ang * float(int(rang \/ ang)); if (a < 0.0) a += ang;\n\tif (a > 0.5*ang) a = ang - a; ang \/= 2.0;\n\tvec2 p = length(P) * vec2(cos(a), sin(a)) - vec2(R, 0), e = r * vec2(cos(ang), sin(ang)) - vec2(R, 0.0);\n\ta = dot(p, e);\n\tif (a < 0.0) return length(p);\n\tif (a > dot(e,e)) return length(P) < r ? -length(p - e) : length(p - e);\n\treturn det(p, normalize(e));\n}\n\nfloat sd_sector(float r, float ang, in vec2 p) {\t\/\/ centered at origin, range [-ang, ang], 0<ang<\u03c0\n\tfloat a = atan(p.y \/ p.x); if (p.x < 0.0) a += p.y > 0.0 ? PI : -PI; a = abs(a) - ang;\n\tfloat sd = length(p);\n\tif (a < 0.0) {\n\t\tif (sd > r) return sd - r;\n\t\tif (a > -PI \/ 2.0) sd = max(sd - r, sd*sin(a));\n\t\telse sd = max(sd - r, -sd);\n\t\treturn sd;\n\t}\n\tif (a > PI \/ 2.0) return sd;\n\tif (sd*cos(a) < r) return sd * sin(a);\n\treturn sqrt(sd*sd + r * r - 2.0 * r*sd*cos(a));\n}\n\nfloat sd_arc(float r, float ang, in vec2 p) {\t\/\/ centered at origin, range [-ang, ang], 0<ang<\u03c0\n\tfloat a = atan(p.y \/ p.x); if (p.x < 0.0) a += p.y > 0.0 ? PI : -PI; a = abs(a) - ang;\n\tfloat sd = length(p); if (a < 0.0) return abs(sd - r);\n\treturn length(vec2(p.x - r * cos(ang), abs(p.y) - r * sin(ang)));\n}\n\nfloat sd_ellipse(float a, float b, in vec2 P) {\t\/\/ a,b > 0\n\tvec2 p = abs(P);\n    if (p.x > p.y) { p = p.yx; float c=a; a=b, b=c; }\n\tfloat l = b * b - a * a;\n\tfloat m = a * p.x \/ l, m2 = m * m;\n\tfloat n = b * p.y \/ l, n2 = n * n;\n\tfloat c = (m2 + n2 - 1.0) \/ 3.0, c3 = c * c * c;\n\tfloat q = c3 + m2 * n2*2.0;\n\tfloat d = c3 + m2 * n2;\n\tfloat g = m + m * n2;\n\tfloat co;\n\tif (d < 0.0) {\n\t\tfloat p = acos(q \/ c3) \/ 3.0;\n\t\tfloat s = cos(p);\n\t\tfloat t = sin(p)*sqrt(3.0);\n\t\tfloat rx = sqrt(-c * (s + t + 2.0) + m2);\n\t\tfloat ry = sqrt(-c * (s - t + 2.0) + m2);\n\t\tco = (ry + (l > 0.0 ? rx : -rx) + abs(g) \/ (rx*ry) - m) \/ 2.0;\n\t}\n\telse {\n\t\tfloat h = 2.0*m*n*sqrt(d);\n\t\tfloat s = q + h > 0.0 ? pow(q + h, 1.0 \/ 3.0) : -pow(-q - h, 1.0 \/ 3.0);\n\t\tfloat u = q > h ? pow(q - h, 1.0 \/ 3.0) : -pow(h - q, 1.0 \/ 3.0);\n\t\tfloat rx = -s - u - c * 4.0 + 2.0*m2;\n\t\tfloat ry = (s - u)*sqrt(3.0);\n\t\tfloat rm = sqrt(rx*rx + ry * ry);\n\t\tfloat p = ry \/ sqrt(rm - rx);\n\t\tco = (p + 2.0*g \/ rm - m) \/ 2.0;\n\t}\n\tvec2 closestPoint = vec2(a*co, b*sqrt(1.0 - co * co));\n\tfloat sd = length(closestPoint - p);\n\tif (p.y > closestPoint.y) return sd;\n\treturn -sd;\n}\nfloat sd_ellipse_fast(float a, float b, in vec2 p) {\n\tfloat k0 = length(vec2(p.x \/ a, p.y \/ b));\n\tfloat k1 = length(vec2(p.x \/ (a*a), p.y \/ (b*b)));\n\treturn k0 * (k0 - 1.0) \/ k1;\n}\n\n\n\n\n\nfloat SD_sphere(float r, in vec3 p) {\n\treturn length(p) - r;\n}\n\nfloat SD_segment(vec3 v1, vec3 v2, in vec3 p) {\n\tfloat t = dot(v2-v1, p-v1);\n\tif (t < 0.0) return length(p - v1);\n\tif (t > dot(v2-v1, v2-v1)) return length(p-v2);\n\treturn length(cross(normalize(v2-v1), p-v1));\n}\n\nfloat SD_box(vec3 b, in vec3 p) {\n\tvec3 d = vec3(abs(p.x), abs(p.y), abs(p.z)) - b;\n\treturn length(max(d,0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat SD_torus(float R, float r, in vec3 p) {\t\t\/\/ xoy\n\tfloat d = length(p.xy) - R;\n\treturn sqrt(d * d + p.z * p.z) - r;\n}\n\nfloat SD_cylinder_z(float r, float min_z, float max_z, in vec3 p) {\t\/\/ perpendicular to xoy, min_z<max_z\n\tfloat d = length(p.xy) - r;\n\tif (p.z < max_z && p.z > min_z) return max(d, max(min_z - p.z, p.z - max_z));\n\tif (d < 0.0) return p.z > max_z ? p.z - max_z : min_z - p.z;\n\treturn p.z > max_z ? sqrt(d*d + (p.z - max_z)*(p.z - max_z)) : sqrt(d*d + (p.z - min_z)*(p.z - min_z));\n}\nfloat SD_cylinder(vec3 v1, vec3 v2, float r, in vec3 p) {\n\tvec3 dr = v2 - v1; float h = length(dr); dr \/= h;\n\tfloat t = dot(dr, p - v1), d = length(cross(p - v1, dr)) - r;\n\tif (t < 0.0) {\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn -t;\n\t}\n\tif (t > h) {\n\t\tt -= h;\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn t;\n\t}\n\tif (d > 0.0) return d;\n\treturn max(max(-t, t - h), d);\n}\nfloat SD_cylinder(vec3 c, vec3 dir, float r, float h, in vec3 p) {\t\/\/ dir unit vectors\n\tc -= p;\n\tfloat t = -dot(dir, c);\n\tfloat d = length(cross(c, dir)) - r;\n\tif (t < 0.0) {\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn -t;\n\t}\n\tif (t > h) {\n\t\tt -= h;\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn t;\n\t}\n\tif (d > 0.0) return d;\n\treturn max(max(-t, t - h), d);\n}\n\nfloat SD_cone(vec3 c, vec3 dir, float r, float h, in vec3 p) {\t\/\/ dir unit vector,  h,r > 0.0\n\tc -= p;\n\tfloat t = -dot(dir, c);\n\tfloat d = length(cross(c, dir));\n\tif (t > h) {\n\t\tif (d < r) return t - h;\n\t\td -= r, t -= h; return sqrt(d * d + t * t);\n\t}\n\tif (t < 0.0) {\n\t\tif (r * d + h * t < 0.0) return sqrt(d * d + t * t);\n\t\treturn (h * d - r * t) \/ sqrt(h * h + r * r);\n\t}\n\tif (r * (d - r) + h * (t - h) > 0.0) {\n\t\td -= r, t -= h; return sqrt(d * d + t * t);\n\t}\n\td = (h * d - r * t) \/ sqrt(h * h + r * r);\n\tif (d > 0.0) return d;\n\treturn max(d, t - h);\n}\n\nfloat SD_ellipsoid(float xy, float z, in vec3 p) {\t\/\/ exact, rotating ellipse\n\treturn sd_ellipse(xy, z, vec2(length(p.xy), p.z));\n}\nfloat SD_ellipsoid(float a, float b, float c, in vec3 p) {\t\/\/ not exact, problem occurs inside and far outside\n\tfloat k0 = length(vec3(p.x \/ a, p.y \/ b, p.z \/ c));\n\tfloat k1 = length(vec3(p.x \/ (a*a), p.y \/ (b*b), p.z \/ (c*c)));\n\treturn k0 * (k0 - 1.0) \/ k1;\n}\n\nfloat SD_Bezier2(vec3 A, vec3 B, vec3 C, in vec3 P) {\n\tvec3 C2 = A - 2.0 * B + C, C1 = 2.0 * (B - A), C0 = A - P;\n\tfloat t = 2.0 * dot(C2, C2)\n\t\t, a = 3.0 * dot(C2, C1) \/ t, b = (2.0 * dot(C2, C0) + dot(C1, C1)) \/ t, c = dot(C1, C0) \/ t;\n\tfloat a2 = a * a, p = (-a2 \/ 3.0 + b) \/ 3.0, q = (a*a2 \/ 13.5 - a * b \/ 3.0 + c) \/ 2.0;\n\tfloat p3 = p * p*p, delta = q * q + p3;\n#define E (C2*t + C1)*t + C0\n\tif (delta > 0.0) {\n\t\tdelta = sqrt(delta);\n\t\tt = (delta > q ? pow(delta - q, 1.0\/3.0) : -pow(q - delta, 1.0\/3.0)) - (delta + q > 0.0 ? pow(delta + q, 1.0\/3.0) : -pow(-delta - q, 1.0\/3.0)) - a \/ 3.0;\n\t\treturn t > 1.0 ? length(P - C) : t < 0.0 ? length(C0) : length(E);\n\t}\n\telse {\n\t\tq = acos(-q \/ sqrt(-p3)) \/ 3.0, p = 2.0 * sqrt(-p), a \/= 3.0;\n\t\tt = p * cos(q) - a;\n\t\tfloat sd = t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E);\n\t\tt = -p * cos(q + PI \/ 3.0) - a;\n\t\tsd = min(sd, t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E));\n\t\tt = -p * cos(q - PI \/ 3.0) - a;\n\t\tsd = min(sd, t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E));\n\t\treturn sqrt(sd);\n\t}\n#undef E\n}\n\n\nfloat s_union(in float a, in float b, in float k) {\n\tfloat h = 0.5 + 0.5*(b - a) \/ k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn (1.0 - h)*b + h * a - k * h * (1.0 - h);\n}\nfloat s_int(in float a, in float b, in float k) {\n\tfloat h = 0.5 - 0.5*(b - a) \/ k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn (1.0 - h)*b + h * a + k * h * (1.0 - h);\n}\nfloat s_sub(in float a, in float b, in float k) {\n\tfloat h = 0.5 - 0.5*(b + a) \/ k;\n\tif (h < 0.0) return a; if (h > 1.0) return -b;\n\treturn (1.0 - h)*a - h * b + k * h * (1.0 - h);\n}\nfloat opExtrusion(float sd2, float h, in vec3 P) {\t\/\/ exact, extrude toward z-axis\n\tif (P.z >= 0.0 && P.z <= h) return sd2 > 0.0 ? sd2 : max(sd2, max(-P.z, P.z - h));\n\tif (P.z > h) return sd2 > 0.0 ? sqrt(sd2*sd2 + (P.z - h)*(P.z - h)) : P.z - h;\n\tif (P.z < 0.0) return sd2 > 0.0 ? sqrt(sd2*sd2 + P.z*P.z) : -P.z;\n}\n\n\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"wstGRH","date":"1569197670","viewed":5,"name":"Untitled 0x00000004","username":"harry7557558","description":"Sketchbook No.1","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define omega 1.0\n\n#define MAX_STEP 1024\n#define MAX_DIST 200.0\n#define EPSILON 1e-4\n\n#define PI 3.14159265358979\n\nfloat sdCylinder(vec3 p, float th, float r){\n    p.z=abs(p.z)-th;\n    float d = length(p.xy)-r;\n\tif (p.z<0.0) return d>0.0?d:max(d,max(-th-p.z,p.z));\n\treturn d<0.0?p.z:sqrt(d*d+p.z*p.z);\n}\n\nfloat sdCube(vec3 p, float r){\n    p=abs(p)-r;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0);\n}\n\nfloat sdDisk(vec3 p){\n    return sdCylinder(p,0.06,1.2);\n}\n\nfloat sdAxis(vec3 p){\n    return sdCylinder(p+vec3(0.0,0.0,0.2),1.3,0.07);\n}\n\nfloat sdDice(vec3 p){\n    return sdCube(p-vec3(0.9,0.0,0.2),0.1);\n}\n\nfloat map(vec3 p){\n    float sd=min(sdDisk(p),sdAxis(p));\n    sd=min(sd,sdDice(p));\n    return sd-0.02;\n}\n\nvec3 calcGrad(vec3 p){\n\tfloat k_111 = map(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = map(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = map(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = map(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n \/ (4.0 * EPSILON);\n}\n\nfloat calcShadow(vec3 p, vec3 light){\n    float t=0.01, dt;\n    for (int i=0;i<64;i++){\n        dt=map(p+t*light);\n        if (dt>MAX_DIST) break;\n        if (dt<EPSILON) return 0.5;\n        t+=dt;\n    }\n    return 1.0;\n}\n\nvec3 castRay(vec3 p, vec3 d, vec3 light){\n    float t=100.0*EPSILON, dt;\n    for (int i=0;i<MAX_STEP;i++){\n        dt = map(p+t*d);\n        t+=dt;\n        if (dt<EPSILON){\n            p=p+t*d;\n            vec3 n=calcGrad(p);\n            float k=0.3+0.7*max(dot(n,light),0.0);\n            k*=calcShadow(p,light);\n            vec3 col;\n            if (sdDice(p)-0.02<EPSILON) col=k*vec3(0.7,0.8,0.9);\n            else if (sdAxis(p)-0.02<EPSILON) col=k*vec3(0.9,0.8,0.7);\n            else if ((t=atan(p.y,p.x))>PI\/3.0) col=k*vec3(0.8,1.0,1.0);\n            else if (t<-PI\/3.0) col=k*vec3(1.0,0.8,1.0);\n            else col=k*vec3(1.0,1.0,0.8);\n            return col;\n        }\n        if (t>MAX_DIST) return vec3(0);\n        if (t<-EPSILON) return vec3(1,0,0);\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Unit = 0.75*length(iResolution);\n    float h = 2.0;\n    float r = 5.0;\n    float t = -omega*iTime;\n    vec3 pos = vec3(r*cos(t), r*sin(t), h);\n    vec3 dir = vec3(0.0,0.0,-0.1)-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 l = normalize(vec3(0.4, 0.3, 0.7));\n    l = vec3(l.x*cos(t)-l.y*sin(t),l.x*sin(t)+l.y*cos(t),l.z);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)\/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)\/float(AA)),Unit);\n        col += castRay(pos,normalize(d),l);\n    }\n    col\/=float(AA*AA);\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wdc3RB","date":"1569197432","viewed":176,"name":"Untitled 0x00000007","username":"harry7557558","description":"simple test of non-recursive ray tracing","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n#define EPSILON 1e-5\n\nstruct Sphere{\n    vec3 O;\n    float r;\n};\nbool sphInt(in Sphere S, in vec3 P, in vec3 d, out float t, out vec3 n) {\t\/\/ doesn't work when inside\n\tvec3 p = P - S.O; if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= S.r*S.r) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(S.r*S.r - rd2); if (t < EPSILON) return false;\n\tn = (p + t * d) \/ S.r; return true;\n}\nconst Sphere sph1 = Sphere(vec3(-2.0,-2.0,1.0),1.0);\nconst Sphere sph2 = Sphere(vec3(3.0,-2.0,1.3),1.3);\nconst Sphere sph3 = Sphere(vec3(1.0,3.0,1.8),1.8);\nconst Sphere sph4 = Sphere(vec3(1.0,1.0,0.4),0.4);\n\n\nvec3 traceRay(vec3 p, vec3 d, vec3 light){\n    vec3 col=vec3(1.0), ecol;\n    for (int i=0;i<64;i++){\n    \tfloat t, mt=1e+12; vec3 n, mn; bool r=false;\n    \tt=-p.z\/d.z;\n        if (t>EPSILON){\n            mt=t, mn=vec3(0.0,0.0,1.0), r=true;\n            vec3 q=p+t*d;\n            ecol = ((int(floor(q.x))&1)==(int(floor(q.y))&1)) ? vec3(135,206,250)\/256.0 : vec3(148,166,188)\/256.0;\n        }\n    \tif (sphInt(sph1,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(221,160,221)\/256.0;\n    \tif (sphInt(sph2,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(173,216,230)\/256.0;\n    \tif (sphInt(sph3,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(255,182,193)\/256.0;\n    \tif (sphInt(sph4,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(244,164,96)\/256.0;\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n            col*=ecol;\n        }\n        else {\n            col *= vec3(max(dot(d,light),0.0));\n            break;\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*(cos(0.4*iTime)+2.0);\n    float r = sqrt(40.0-h*h) + 0.5*(cos(iTime)+1.0) + 3.0;\n    vec3 pos = 2.0*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0)-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(0.0,0.0,1.0));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)\/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)\/float(AA)),Unit);\n        col += traceRay(pos,normalize(d),light);\n    }\n    col\/=float(AA*AA);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dcGRf","date":"1578366574","viewed":140,"name":"Untitled 0x00000008","username":"harry7557558","description":"test 100% reflective surface","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n\n\/\/ Modeling\n\n#define MIN_D 1e-2\n#define MAX_D 1e+3\n#define RTMinD 1e-2\n#define RTMaxD 1e+12\n\nconst float h=0.5, h1=0.51, w=1.618, s=10.0, wp=1.0;\nconst vec2 r = vec2(s,s*w);\n\nfloat surf(vec3 p, out vec3 grad) {\n    float m=length(p.xy), n=m-iTime;\n    float r=h*sin(n);\n    m=h*cos(n)\/m;\n    grad.x=p.x*m;\n    grad.y=p.y*m;\n    grad.z=1.0;\n    \/\/return (p.z+r)\/sqrt(dot(grad,grad)+1.0);\n    return 0.9*(p.z+r)\/length(grad);\n}\nbool surfint(vec3 p, vec3 d, out float t, out vec3 n){\n    if (d.z>0.0 && p.z>h1) return false;\n    float sd;\n    t=10.0*MIN_D;\n    if (d.z<0.0&&p.z>h1) t=-(p.z-1.0)\/d.z;\n    for (int i=0;i<100;i++){\n        sd=surf(p+t*d,n);\n        if (sd<-MIN_D) return false;\n        t+=sd;\n        if (t>MAX_D) return false;\n        if (t<MIN_D) break;\n    }\n    return true;\n}\n\nbool sphint(vec3 p, vec3 d, out float t, out vec3 n){\n    p.z-=h1+1.0;\n    if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= 1.0) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(1.0 - rd2); if (t < RTMinD) return false;\n\tn = p + t * d; return true;\n}\n\n\/\/ a debugging function, it looks nice so I decide to keep it\n\/\/ example image at iTime=1.90 see https:\/\/i.imgur.com\/flZjpMR.png\n\/*bool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    const float s=3.0;\n    float t1 = d.x+d.y\/w, t2 = p.x+p.y\/w, delta=4.0*s;\n    float a=2.*t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=sqrt(b*b-2.*a*c); if (delta<0.) return false;\n    delta=sqrt(delta)\/a; b=-b\/a;\n    t1=b+delta,t2=b-delta;\n    if (t1<RTMinD) t1=RTMaxD; if (t2<RTMinD) t2=RTMaxD;\n    t=min(t1,t2); if (t>=RTMaxD) return false;\n    vec3 q=p+t*d;\n    t1=0.5\/s*(q.x+q.y\/w), n=vec3(t1,t1\/w,-1.);\n    t1=length(n.xy\/vec2(1.,w)), t2=length(n.xy\/vec2(1.\/w*w));\n  \tdelta=t1*(t1-1.0)\/t2\/length(n.xy);\n    if (abs(delta)>0.1) return false;\n    n=normalize(n);\n    return true;\n}*\/\nbool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    float t1 = d.x+d.y\/w, t2 = p.x+p.y\/w, delta=4.0*s;\n    float a=t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=b*b-4.*a*c; if (delta<0.) return false;\n    a*=2.0,delta=sqrt(delta)\/a; b=-b\/a;\n    t1=b+delta,t2=b-delta;\n    vec3 q;\n#define Test(t0) q=p+t0*d; \\\n  a=0.5\/s*(q.x+q.y\/w), n=vec3(a,a\/w,-1.); \\\n  b=length(q.xy\/r), c=length(q.xy\/(r*r)), a=b*(b-1.0)\/c*length(n); \\\n  if (abs(a)<wp) t=t0;\n    t=RTMaxD;\n    if (t1>RTMinD) {Test(t1)}\n    if (t2>RTMinD&&t2<t) {Test(t2)}\n    if (t==RTMaxD) return false;\n    q=p+t*d;\n    a=0.5\/s*(q.x+q.y\/w), n=normalize(vec3(a,a\/w,-1.));\n    return true;\n}\n\n\n\/\/ Rendering\n\n#define sunpos normalize(vec3(1.0,-1.0,0.5))\n#define fogcol vec3(1.0,0.7,0.4)\n#define skycol vec3(0.6,0.8,1.0)\n#define suncol vec3(0.9,0.8,0.5)\n#define fogD 0.008\n\nvec3 skycolor(vec3 d){\n    vec3 col;\n    float sky=(0.2-0.8)*max(d.z,0.0)+0.8;\n    col=sky*skycol;\n    float horizon=pow(1.0-d.z*d.z,100.0);\n    col=mix(col,vec3(1.0),horizon);\n    float sun=max(dot(d,sunpos),0.0);\n    col+=pow(sun,150.0)*suncol;\n    return col;\n}\nfloat fog(vec3 d){\n    if (d.z<=0.0) return 1.0;\n    return pow(1.0-d.z*d.z,200.0);\n}\n\nvec3 calcCol(vec3 p, vec3 d){\n    float a=0.0;\n    for (int i=0;i<16;i++){\n    \tfloat t=0.0, mt=MAX_D; vec3 n, mn; bool r=false;\n        if (sphint(p,d,t,n)) r=true, mn=n, mt=t; \t\/\/ vec3(135,250,206)\/256.0;\n        if (trackint(p,d,t,n) && t<mt) r=true, mn=n, mt=t; \t\/\/ vec3(250,206,135)\/256.0\n        if (surfint(p,d,t,n) && t<mt) mt=t, mn=normalize(n), r=true; \t\/\/ vec3(135,206,250)\/256.0\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n        \ta+=mt;\n        }\n        else { \/\/ calculate sky color as final output\n            a=exp(-fogD*a);\n            vec3 sky=skycolor(d);\n            sky=mix(sky,fogcol,fog(d));\n            return mix(fogcol,sky,a);\n        }\n    }\n    return fogcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = cos(0.4*iTime)+2.0;\n    float r = 0.5*(cos(iTime)+1.0) + 10.0;\n    vec3 pos = 5.0*cos(0.5*iTime)*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0+h1)-pos;\n\n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n\n    vec3 col = vec3(0.0,0.0,0.0), ecol;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)\/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)\/float(AA)),Unit);\n        ecol = calcCol(pos,normalize(d));\n    \tif (dot(ecol,vec3(0.3,0.59,0.11))<0.1) ecol=fogcol;\n        col+=ecol;\n    }\n\n    fragColor = vec4(col\/float(AA*AA),1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WtK3Ry","date":"1579568369","viewed":264,"name":"Untitled 0x0000000D","username":"harry7557558","description":"basically a copy of my c++ code [url]https:\/\/github.com\/Harry7557558\/Graphics\/blob\/light2d\/light2d%20(no%20recursion).cpp[\/url] (not gl)","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["light2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, in vec2 p) {\n\tc = texelFetch(iChannel0, ivec2(p), 0);\n    c \/= float(iFrame+1);\n}\n\n\n\/\/ Bug fix history:\n\/\/ Buffer A line 70 originally uses 0.0*R!=0.0 to test NAN.\n\/\/ Shader optimizer foiled this trick.\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265358979\n\n\/\/ set SAMPLE to a smaller value if you have a slow machine\n#define SAMPLE 64\n#define EPSILON 1e-4\n#define MAX_STEP 64\n#define MAX_DIST 10.0\n#define MAX_RECU 50\n\nvec2 CENTER = vec2(0.0, 0.0);\nfloat SCALE = 100.0;\nfloat BULB = 2.0;\nfloat INDEX = 1.5;\n\n\nfloat hash(vec2 x){\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec2 Refract(vec2 I, vec2 N, float n1, float n2, out float R) {\n\tfloat eta = n1 \/ n2;\n\tfloat ci = -dot(N, I);\n\tif (ci < 0.) ci = -ci, N = -N;\n\tfloat ct = sqrt(1.0 - eta * eta * (1.0 - ci * ci));\n\tvec2 r = I * eta + N * (eta * ci - ct);\n\tfloat Rs = (n1 * ci - n2 * ct) \/ (n1 * ci + n2 * ct);\n\tfloat Rp = (n1 * ct - n2 * ci) \/ (n1 * ct + n2 * ci);\n\tR = 0.5 * (Rs * Rs + Rp * Rp);\n\treturn r;\n}\n\n\nfloat sdBulb(vec2 p) {\n\t\/\/return length(p - vec2(3.0)) - 1.0;\n\t\/\/return length(vec2(abs(p.x) - 3.0, abs(p.y) - 3.0)) - 0.5;\n\treturn length(vec2(p.x, p.y - 3.0)) - 1.0;\n}\n\nfloat sdObj(vec2 p) {\n\t\/\/return length(p)-1.0;\t\/\/ circle\n\t\/\/return (abs(p.x)>0.8?length(vec2(abs(p.x)-0.8,p.y)):abs(p.y))-0.8;\t\/\/ capsule\n\t\/\/return max(abs(p.x) - 1.2, abs(p.y) - 0.75);\t\/\/ rectangle\n\t\/\/return max(length(vec2(p.x,p.y-0.4))-1.0,p.y-0.5);\t\/\/ semi-circle\n\treturn min(max(abs(p.x),abs(p.y)-1.2), max(abs(p.x)-0.7,abs(p.y-0.5)))-0.2;\t\/\/ cross\n\t\/\/p=abs(p); return min((p.y>1.0?length(p-vec2(0.65,1.0)):abs(p.x-0.65))-0.2, max(p.x-0.65,p.y)-0.2);\t\/\/ letter H\n}\n\nvec2 gradient(vec2 p) {\n\tfloat k = 0.001;\n\tfloat u = sdObj(vec2(p.x + k, p.y)) - sdObj(vec2(p.x - k, p.y));\n\tfloat v = sdObj(vec2(p.x, p.y + k)) - sdObj(vec2(p.x, p.y - k));\n\treturn vec2(u, v) * (0.5 \/ k);\n}\n\nfloat traceRay(vec2 p, vec2 d) {\n\tint N = 0;\n\twhile (N++ < MAX_RECU) {\n\t\tfloat t = 10.0*EPSILON, dt, sdb, sdo, ot, it, R;\n\t\tvec2 q, n, r;\n\t\tint i; for (i = 0; i < MAX_STEP; i++) {\n\t\t\tq = p + d * t;\n\t\t\tsdb = sdBulb(q);\n\t\t\tif (sdb <= EPSILON) return BULB;\n\t\t\tsdo = sdObj(q);\n\t\t\tdt = sdb > sdo ? sdo : sdb;\n\t\t\tif (abs(dt) <= EPSILON) {\n\t\t\t\tn = normalize(gradient(q)), r;\n\t\t\t\tif (dt >= 0.0) r = Refract(d, n, 1.0, INDEX, R);\n\t\t\t\telse r = Refract(d, n, INDEX, 1.0, R);\n\t\t\t\tif (isnan(R)) R = 1.0;  \/\/ bug fixed: 0.0*R!=0.0 got optimized\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt += abs(dt);\n\t\t\tif (t > MAX_DIST) return 0.0;\n\t\t}\n\t\tif (i == MAX_STEP) return 0.0;\n\n\t\tt = hash(q + d * R + iTime);\n\t\tif (t < R) p = q, d = reflect(d, n);\n\t\telse p = q, d = r;\n\t}\n\treturn 0.0;\n}\n\nfloat Sample(vec2 p) {\n\tfloat c = 0.0;\n\tfloat s = 1.0 \/ SCALE, h = -0.5 \/ SCALE;\n\tfor (int i = 0; i < SAMPLE + min(iFrame, 0); i++) {\n\t\tfloat a = 2.0 * PI * (float(i) + hash(p + vec2(i) + iTime)) \/ float(SAMPLE);\n\t\tvec2 d = vec2(cos(a), sin(a));\n\t\tc += traceRay(p + vec2(hash(p + iTime - float(i))) * s, d);\n\t}\n\treturn c \/ float(SAMPLE);\n}\n\nvoid mainImage( out vec4 col, in vec2 coord ) {\n\tSCALE = 0.2*sqrt(iResolution.x*iResolution.y);\n\tvec2 p = (coord - iResolution.xy * 0.5) * (1.0 \/ SCALE) + CENTER * 0.5;\n\tfloat c = Sample(p);\n\tcol = vec4(vec3(c), 1.0);\n    col += texelFetch(iChannel0, ivec2(coord), 0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Wdsfzj","date":"1588824320","viewed":9,"name":"Untitled 0x00000017","username":"harry7557558","description":"school project","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["archer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define eps 1e-5\n\n\nconst vec3 light = normalize(vec3(0.3, -0.2, 1));\n\nvec3 calcGrad(vec3 p){\n    const float e = .001;\n\tfloat a = map(p+vec3(e,e,e));\n\tfloat b = map(p+vec3(e,-e,-e));\n\tfloat c = map(p+vec3(-e,e,-e));\n\tfloat d = map(p+vec3(-e,-e,e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\nvec3 castRay(vec3 p, vec3 d) {\n    float t = 0.0, dt;\n\tfor (int i = 0; i < 256; i++) {\n\t\tdt = map(p + t * d);\n\t\tt += dt;\n        if (dt<-eps) return vec3(1,0,0);\n\t\tif (dt<eps) break;\n\t\tif (t>20.0) return vec3(0.0);\n\t}\n\tp = p + t * d;\n    vec3 n = calcGrad(p);\n    d-=2.0*dot(d,n)*n;\n\tvec3 bkg = vec3(0.2, 0.15, 0.1);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n    return bkg+dif+spc;\n}\n\n#define SC 2.0\n#define Center vec3(0,0,0.8)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n#if 0\n    vec2 p = iMouse.w>0.?iMouse.xy:-iMouse.zw;\n    float t = p.x\/iResolution.x*4.0*PI;\n    float a = PI*(p.y\/iResolution.y-0.3);\n#else\n    float t = 0.6*sin(0.2*iTime)+0.05, a = 0.2;\n#endif\n    vec3 pos = 8.*SC*vec3(cos(a)*cos(t),cos(a)*sin(t), sin(a));\n\n    vec3 w = normalize(pos);\n    vec3 u=normalize(vec3(-w.y,w.x,0));\n    vec3 v=cross(w,u);\n    mat3 M=-mat3(u,v,w);\n\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d=M*vec3(0.5*iResolution.xy-(fragCoord.xy+vec2(i,j)\/float(AA)),SC*length(iResolution.xy));\n        col += castRay(pos+Center,normalize(d));\n    }\n    col\/=float(AA*AA);\n\n    \/\/col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\n\/\/ all sdf functions copy-pasted from iq\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p\/r);\n  float k1 = length(p\/(r*r));\n  return k0*(k0-1.0)\/k1;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))\/baba;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nmat3 axisAngle(vec3 a, float t) {  \/\/ actually returns its inverse\/transpose\n\ta = normalize(a); float ct = cos(t), st = sin(t);\n\treturn mat3(\n\t\tct + a.x*a.x*(1.-ct), a.x*a.y*(1.-ct) - a.z*st, a.x*a.z*(1.-ct) + a.y*st,\n\t\ta.y*a.x*(1.-ct) + a.z*st, ct + a.y*a.y*(1.-ct), a.y*a.z*(1.-ct) - a.x*st,\n\t\ta.z*a.x*(1.-ct) - a.y*st, a.z*a.y*(1.-ct) + a.x*st, ct + a.z*a.z*(1.-ct)\n\t);\n}\n\n\n\/\/=========================================================================================\n\n\nfloat mapBase(vec3 p){\n    float d = length(p.xy)-1.0;\n    return max(d,abs(p.z+0.1)-0.1);\n}\n\nfloat mapArch(vec3 p){\n    \/\/vec3 q = axisAngle(vec3(0,-1,0),0.15)*axisAngle(vec3(1,0,0),0.2)*(p-vec3(0,0,0.97));\n    vec3 q=mat3(0.988771,0,-0.149438,-0.0296888,0.980067,-0.196438,0.146459,0.198669,0.969061)*(p-vec3(0,0,0.97));\n    float c = sdEllipsoid(q,vec3(0.3,1.0,1.0-0.1*p.z));\n    q = p-vec3(0,-16,-0.4);\n\tfloat pz2 = (p.z-1.)*(p.z-1.);\n    c = smax(c,sdEllipsoid(q,vec3(2.0,15.8,16.0)),smax(0.05*(1.0-pz2),0.0,0.01));\n    float h = sdCapsule(p,vec3(0.05,-0.3,0.97),vec3(0.2+exp(0.15*p.y)-1.0,0.35,0.9),0.25+0.08*p.y-pz2);\n    float s = length(p-vec3(0.27,0.35,1.0))-0.25;\n    float v = sdCylinder(p,vec3(0.35,0.3,0.9),vec3(0.55,0.3,0.9),0.55*(p.y-0.1)+0.2*(p.x-0.3));\n    h=smin(h,v,0.1);\n    return smin(c,h,0.1);\n}\n\nfloat mapArm(vec3 p){\n    \/\/vec3 q = axisAngle(vec3(0,0,1),-0.3)*axisAngle(vec3(0,-1,0),0.1)*axisAngle(vec3(1,0,0),0.1)*(p-vec3(0.43,-0.37,1.0));\n    vec3 q = mat3(0.950564,0.294044,-0.0998334,-0.303565,0.947618,-0.0993347,0.0653952,0.12473,0.990033)*(p-vec3(0.43,-0.37,1.0));\n    return sdEllipsoid(q,vec3(0.05,0.11,0.25));\n}\n\nfloat mapBody(vec3 p){\n    float b = length(p.xy-vec2(-0.1,0.4-0.1*p.z))-0.21+0.01*p.z;\n    b = smax(b,abs(p.z-0.5)-0.5,0.05);\n    float c = sdEllipsoid(p-vec3(-0.1,0.35,0.9),vec3(0.35,0.4,0.35));\n    c = smin(b,c,0.2);\n    float u = length(p.xy-vec2(-0.1,0.47))-max(0.23-p.x*p.x,0.);\n    u = smax(u,abs(p.z-0.1*p.y-1.35)-0.35,max(0.1*(2.0-p.z),0.));\n    c = smin(u,c,0.2);\n    return c;\n}\n\nfloat map(vec3 p) {\n    float sb = max(min(length(p.xy),min(length(p.xz),length(p.yz))),length(p)-3.0)-0.01;\n    sb = min(sb, min(length(p-vec3(3,0,0)),length(p-vec3(0,3,0)))-0.1);\n    sb = min(sb, mapBase(p));\n    \/\/sb=1e12;\n    float sd = smin(mapArch(p),mapBody(p),0.2);\n    sd=min(sd,mapArm(p));\n    return 0.5*min(sb,sd);\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"sdBczG","date":"1643902096","viewed":18,"name":"WaveEquation_9ec8","username":"harry7557558","description":"I see people made cool simulations with buffers, so I decided to give it a try.\nOne of the most basic things I can do with buffers is solve the wave equation. All parameters are in SI units. Mouseable.","likes":0,"published":2,"flags":32,"usePreview":0,"tags":["ripples","wave","simulation","water","equation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Common: parameters and differential equation\n\/\/ Buffer A\/B: forware Euler integration\n\/\/ Image: rendering\n\n\n\/\/ get vec4(u, dudx, dudy, 1)\nvec4 getVal(sampler2D sampler, vec2 xy) {\n    float u = getU(xy);\n    float ux1 = getU(xy+nds.xy);\n    float ux0 = getU(xy-nds.xy);\n    float uy1 = getU(xy+nds.yx);\n    float uy0 = getU(xy-nds.yx);\n    float ux = (ux1-ux0) \/ (2.*nds.x);\n    float uy = (uy1-uy0) \/ (2.*nds.x);\n    return vec4(u, ux, uy, 1);\n}\n\n\/\/ ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1. \/ rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*view_box;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n\/\/ raymarhing, return RGB\nvec3 render(vec3 ro, vec3 rd, float t0, float t1) {\n    float t = t0;\n    for (int i=0; i<64; i++) {\n        vec3 p = ro+rd*t;\n        vec4 vn = getVal(iChannel0, p.xy);\n        float dt = 0.6*(p.z-vn.x) \/ length(vn.yzw);\n        t += dt;\n        if (t<=t0 || t>=t1) return vec3(0.1);\n        if (abs(dt)<.001) break;\n    }\n    vec3 n = normalize(getVal(iChannel0, (ro+rd*t).xy).yzw);\n    rd = reflect(rd, n);\n    return vec3(0.5,0.5,1.0)*(.1+.5*n.z+.5*max(rd.z,0.));\n}\n\n\/\/ main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0,0,0,1);\n#if 0\n    \/\/ 2D\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n    vec3 col = vec3(normalize(getVal(iChannel0,xy).yzw).z);\n    fragColor = vec4(col,1);\n#else\n    \/\/ 3D\n    float perspective = 4.0;\n    float scale = 0.6*height;\n    float rx = 0.15*PI;\n    float rz = -0.3*PI;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = scale*perspective*w + view_box-vec3(0,0,.1);\n    vec2 uv = 2.*fragCoord.xy\/iResolution.xy - 1.;\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, perspective*iResolution.y);\n    rd = normalize(rd);\n    float t0, t1;\n    if (boxIntersection(ro-view_box, rd, t0, t1)) {\n        fragColor.xyz = render(ro, rd, t0, t1);\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec4 sp = diffequ(iChannel0, time, xy, uniforms_call);\n    float u = sp.x,\n          ut = sp.y,\n          utt = sp.z;\n\n    ut += delta_t * utt;\n    u += delta_t * ut;\n\n    \/\/ clamp it to show independence from float buffer extension\n    fragColor = clamp( vec4(u, 0.5+nm1*ut, 0,0), 0.,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n\n\/\/ pass uniform variables to common\n#define uniforms_params vec3 iResolution, vec4 iMouse, int iFrame\n#define uniforms_call iResolution, iMouse, iFrame\n\n\/\/ simulation dimension in meters\n#define height (2.)\n#define width (height*(iResolution.x\/iResolution.y))\n#define view_box (.5*vec3(width,height,1))\n\n\/\/ time in seconds (2 buffers, 60 fps)\n#define delta_t (1.\/(60.*2.))\n#define time (float(iFrame)*(delta_t))\n\n\/\/ speed of wave in m\/s, large => unstable\n\/\/ in reality: some number between 0.4 and 2.2\n#define speed (0.3)\n\n\/\/ sampling buffer, normalize between 0 and 1??\n#define nm1 (.03\/speed)\n#define getU(xy) (texture(sampler,(xy)\/vec2(width,height)).x)\n#define getUt(xy) ((texture(sampler,(xy)\/vec2(width,height)).y-.5)\/nm1)\n\n\/\/ numerical differentiation step in meters\n#define nds vec2(height\/iResolution.y,0)\n\n\n\/\/ returns vec4(u, \u2202u\/\u2202t, \u2202\u00b2u\/\u2202t\u00b2)\n\/\/ sampler wrap must be \"clamp\"\nvec4 diffequ(sampler2D sampler, float t, vec2 xy, uniforms_params) {\n    float u = getU(xy);\n    float ut = getUt(xy);\n\n    float ux1 = getU(xy+nds.xy);\n    float ux0 = getU(xy-nds.xy);\n    float uy1 = getU(xy+nds.yx);\n    float uy0 = getU(xy-nds.yx);\n\n    float uxx = (ux1+ux0-2.*u) \/ (nds.x*nds.x);\n    float uyy = (uy1+uy0-2.*u) \/ (nds.x*nds.x);\n\n    float v = speed;\n    float utt = v*v*(uxx+uyy); \/\/ wave equation\n    utt -= 0.1*ut;  \/\/ damping\n\n    \/\/ mouse interaction\n    if (iMouse.z > 0.) {\n        vec2 pos = vec2(width,height)*iMouse.xy\/iResolution.xy;\n        u += 1.0*exp(-1000.*dot(xy-pos,xy-pos))*delta_t;\n    }\n    \/\/ initial state\n    if (iFrame < 1) {\n        vec2 pos = vec2(.4,.3)*vec2(width,height);\n        u = .5 + .2*exp(-1000.*dot(xy-pos,xy-pos));\n        ut = utt = 0.;\n    }\n    return vec4(u, ut, utt, 1);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Forward Euler\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = vec2(width,height)*fragCoord\/iResolution.xy;\n\n    vec4 sp = diffequ(iChannel0, time, xy, uniforms_call);\n    float u = sp.x,\n          ut = sp.y,\n          utt = sp.z;\n\n    ut += delta_t * utt;\n    u += delta_t * ut;\n\n    \/\/ clamp it to show independence from float buffer extension\n    fragColor = clamp( vec4(u, 0.5+nm1*ut, 0,0), 0.,1.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ttcSWM","date":"1581034919","viewed":13,"name":"Web Camera","username":"harry7557558","description":"something I made for myself, since the camera app doesn't work properly.","likes":0,"published":2,"flags":2,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"\/presets\/webcam.png","previewfilepath":"\/presets\/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, in vec2 p){\n    c = texture(iChannel0,p\/iResolution.xy);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"slSXz1","date":"1627062342","viewed":62,"name":"dmojistan logo","username":"harry7557558","description":"hehe","likes":0,"published":2,"flags":0,"usePreview":0,"tags":["render","main"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Dmojistan logo\n\nvec3 Render_Main(float x, float y) {\n    float m = x*x + y*y;\n    float t = acos(cos(5.0*atan(x,-y)));\n    float r = -0.032*log(exp(-0.03*exp(3.1*t)-2.7*t-6.8)+exp(0.46*abs(t)-25.2));\n    float d = min(max(m-1.7,1.45-m), sqrt(m)-r);\n    float sd = 1.0-d\/length(vec2(dFdx(d),dFdy(d)));\n    return clamp(sd, 0.0, 1.0) * vec3(0.98, 0.86, 0.02);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)\/min(iResolution.x, iResolution.y);\n    float t = mix(0.0, 3.1415926, smoothstep(0.0,1.0,min(mod(iTime,4.0),3.5)\/3.5));\n    float a = 2.0*t-1.375 - 1.7*sin(2.0*t-0.942);\n    uv = 1.8*mat2(cos(a),sin(a),-sin(a),cos(a))*uv;\n    vec3 col = Render_Main(uv.x, uv.y);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NscXRj","date":"1633474218","viewed":249,"name":"isp-glassball-11-mix","username":"harry7557558","description":"Experimental.\nhttps:\/\/github.com\/harry7557558\/Shadertoy\/tree\/master\/isp-glass","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["scattering","emission","henyeygreenstein","glassball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat rand01() { return float(randu()) * (1.\/4294967296.); }\n\n\n\nvec3 light(vec3 rd) {\n    \/\/return vec3(0.0);\n    vec3 col = texture(iChannel1, rd.yzx).xyz;\n    vec3 bri = vec3(1.0) + vec3(1.0) * pow(max(dot(rd, normalize(vec3(-0.2, -0.5, 0.5))), 0.), 4.);\n    return col * bri;\n}\n\n\n\/\/ sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.0) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n\/\/ scattering \/ importance sampling functions\n\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 \/ n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.0) ci = -ci, n = -n;\n    float ct = 1.0 - eta * eta * (1.0 - ci * ci);\n    if (ct < 0.0) return rd + 2.0*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) \/ (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) \/ (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return rand01() > R ?\n        rd * eta + n * (eta * ci - ct)  \/\/ refraction\n        : rd + 2.0*ci*n;  \/\/ reflection\n}\n\nvec3 sampleUniformSphere() {\n    float u = 2.0*PI*rand01();\n    float v = 2.0*rand01()-1.0;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.0-v*v), v);\n}\n\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.0) return sampleUniformSphere();\n    if (g >= 1.0) return wi;\n    if (g <= -1.0) return -wi;\n    float us = rand01();\n    float vs = 2.0*PI*rand01();\n    float z = (1.0+g*g-pow((1.0-g*g)\/(2.0*g*(us+(1.0-g)\/(2.0*g))),2.0))\/(2.0*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.0-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_lambertian = 1;\nconst int mat_refractive = 2;\n\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XljGzV\nvec3 hsl2rgb(float h, float s, float l) {\n    vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\/\/ https:\/\/www.shadertoy.com\/view\/Nd33zB\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n\/\/ play around this\nvoid calcAbsorb(in vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    p -= vec3(0, 0, 1);  \/\/ center of sphere\n    vec3 q = p; q.xz = mat2(0.9,0.2,-0.2,0.9)*q.xz;\n    emi = (abs(q.z+0.01)<0.02 && max(length(q.xy)-0.6, sin(7.0*PI*length(q.xy)))<0.) || length(abs(q)-vec3(0,0,0.25))<0.1 ?\n         8.0*ryb2rgb(hsl2rgb(atan(q.y,q.x)\/(2.0*PI)+0.5, 1.0, 0.5)) : vec3(0.0);\n    tabs = vec3(0.0);\n    sabs = vec3(0.9, 0.95, 0.99);\n    k = clamp(-100.0*p.z+0.5, 0., 20.);\n    g = 0.5;\n}\n\nvoid calcScatter(in vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1.0, hit_p = rand01();\n    float dt = 0.01;\n    m_emi = vec3(0.0);\n    for (float t = 1e-4; t < mt-dt; t += dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+0.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p\/hit_p)\/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0.0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1.0), t_col = vec3(0.0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n        if (is_inside != (length(ro-vec3(0,0,1))<1.0)) return vec3(1, 0, 0);\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0.0);\n        int material = mat_background;\n\n        \/\/ plane\n        t = -ro.z \/ rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = vec3(0.9, 0.95, 0.98);\n            material = mat_lambertian;\n        }\n\n        \/\/ object\n        t = min_t;\n        if (intersectSphere(vec3(0.0, 0.0, 1.0), 1.0, ro, rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1.0);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1.0);\n                material = mat_refractive;\n            }\n        }\n\n        \/\/ update ray\n        if (material == mat_background) {\n            col = light(rd);\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  \/\/ ray hits into the surface\n        if (material == mat_lambertian) {  \/\/ diffuse\n            rd = sampleCosWeighted(min_n);\n        }\n        else if (material == mat_refractive) {  \/\/ steel ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.0) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ random number seed\n    seed = uint(fragCoord.x)*uint(fragCoord.y)*uint(iFrame+1);\n    seed = randu() + 161u*uint(fragCoord.y);\n    seed = randu() + 239u*uint(fragCoord.x);\n    seed = randu() + 197u*uint(iFrame+1);\n\n    \/\/ camera\n    float rx = iMouse.z==0.?0.3:2.0*(iMouse.y\/iResolution.y)-0.5;\n    float rz = iMouse.z==0.?-1.2:-iMouse.x\/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(rand01(),rand01())-0.5)\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    \/\/ calculate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)\/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"fd3Szj","date":"1633474669","viewed":159,"name":"isp-glassball-12-mix","username":"harry7557558","description":"Experimental.\nhttps:\/\/github.com\/harry7557558\/Shadertoy\/tree\/master\/isp-glass","likes":8,"published":1,"flags":32,"usePreview":1,"tags":["scattering","emission","henyeygreenstein","glassball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ fork https:\/\/www.shadertoy.com\/view\/NscXRj\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\nuint seed = 0u;\nuint randu() { return seed = seed * 1664525u + 1013904223u; }\nfloat rand01() { return float(randu()) * (1.\/4294967296.); }\n\n\n\nvec3 light(vec3 rd) {\n    vec3 col = texture(iChannel1, rd.yzx).xyz;\n    vec3 bri = vec3(1.0) + vec3(1.0) * pow(max(dot(rd, normalize(vec3(-0.2, -0.5, 0.5))), 0.), 4.);\n    return 0.1 * col * bri;\n}\n\n\n\/\/ sphere intersection function\nbool intersectSphere(vec3 o, float r, vec3 ro, vec3 rd,\n        inout float t, inout vec3 n) {\n    ro -= o;\n    float b = -dot(ro, rd), c = dot(ro, ro) - r * r;\n    float delta = b * b - c;\n    if (delta < 0.0) return false;\n    delta = sqrt(delta);\n    float t1 = b - delta, t2 = b + delta;\n    if (t1 > t2) t = t1, t1 = t2, t2 = t;\n    if (t1 > t || t2 < 0.) return false;\n    t = t1 > 0. ? t1 : t2;\n    n = normalize(ro + rd * t);\n    return true;\n}\n\n\n\/\/ scattering \/ importance sampling functions\n\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = rand01();\n    float an = 2.0*PI*rand01();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 \/ n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.0) ci = -ci, n = -n;\n    float ct = 1.0 - eta * eta * (1.0 - ci * ci);\n    if (ct < 0.0) return rd + 2.0*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) \/ (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) \/ (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return rand01() > R ?\n        rd * eta + n * (eta * ci - ct)  \/\/ refraction\n        : rd + 2.0*ci*n;  \/\/ reflection\n}\n\nvec3 sampleUniformSphere() {\n    float u = 2.0*PI*rand01();\n    float v = 2.0*rand01()-1.0;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.0-v*v), v);\n}\n\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.0) return sampleUniformSphere();\n    if (g >= 1.0) return wi;\n    if (g <= -1.0) return -wi;\n    float us = rand01();\n    float vs = 2.0*PI*rand01();\n    float z = (1.0+g*g-pow((1.0-g*g)\/(2.0*g*(us+(1.0-g)\/(2.0*g))),2.0))\/(2.0*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.0-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_lambertian = 1;\nconst int mat_refractive = 2;\n\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XljGzV\nvec3 hsl2rgb(float h, float s, float l) {\n    vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\/\/ https:\/\/www.shadertoy.com\/view\/Nd33zB\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n\/\/ play around this\nvoid calcAbsorb(in vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    p -= vec3(0, 0, 1);  \/\/ center of sphere\n    emi = vec3(0.0);\n    vec3 q = p;\n    float a = 0.4*q.z;\n    q.xy = mat2(cos(a), -sin(a), sin(a), cos(a)) * q.xy;\n    vec3 c = mix(vec3(0.8,0.2,0.1), vec3(0.1,0.2,0.8), 0.5+0.5*q.z);\n    for (float i=0.; i<4.; i++) {\n        float d = 0.5+0.5*asin(sin(6.0*atan(q.y, q.x)));\n        float r = length(q);\n        if (d<0.05 && r<1.0) emi += 30.0*exp2(i)*c * max(vec3(-1.6)+vec3(2.)*r+vec3(0.2)*cos(20.*PI*r), vec3(0.));\n        q *= 2.0;\n        c = mix(c, vec3(0,1,0.5), 0.2);\n    }\n    tabs = vec3(0.0);\n    sabs = vec3(1.0);\n    k = 0.0;\n    g = 0.5;\n}\n\nvoid calcScatter(in vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1.0, hit_p = rand01();\n    float dt = 0.015;\n    m_emi = vec3(0.0);\n    for (float t = 1e-4; t < mt-dt; t += dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+0.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p\/hit_p)\/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0.0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1.0), t_col = vec3(0.0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n        \/\/if (is_inside != (length(ro-vec3(0,0,1))<1.0)) return vec3(1, 0, 0);\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0.0);\n        int material = mat_background;\n\n        \/\/ plane\n        t = -ro.z \/ rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = vec3(0.9, 0.95, 0.98);\n            material = mat_lambertian;\n        }\n\n        \/\/ object\n        t = min_t;\n        if (intersectSphere(vec3(0.0, 0.0, 1.0), 1.0, ro, rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1.0);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1.0);\n                material = mat_refractive;\n            }\n        }\n\n        \/\/ update ray\n        if (material == mat_background) {\n            col = light(rd);\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  \/\/ ray hits into the surface\n        if (material == mat_lambertian) {  \/\/ diffuse\n            rd = sampleCosWeighted(min_n);\n        }\n        else if (material == mat_refractive) {  \/\/ steel ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.0) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ random number seed\n    seed = uint(fragCoord.x)*uint(fragCoord.y)*uint(iFrame+1);\n    seed = randu() + 161u*uint(fragCoord.y);\n    seed = randu() + 239u*uint(fragCoord.x);\n    seed = randu() + 197u*uint(iFrame+1);\n\n    \/\/ camera\n    float rx = iMouse.z==0.?0.3:2.0*(iMouse.y\/iResolution.y)-0.5;\n    float rz = iMouse.z==0.?-1.2:-iMouse.x\/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(rand01(),rand01())-0.5)\/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    \/\/ calculate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)\/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"3dBcR3","date":"1587029897","viewed":89,"name":"sdLine Continuity","username":"harry7557558","description":"Use a power higher than 2 to increase the continuity of line segment primitive for modeling","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","smooth","g2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Time measured with Shadertoy unofficial plugin by Patu\n\n\/\/ 1.00ms\nfloat sdLine(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba),0.,1.);\n    return length(pa-ba*h);\n}\n\n\/\/ 1.15ms\nfloat sdLine4(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)\/dot(ba,ba);\n    pa -= ba*h;\n    h = max(abs(h-.5)-.5,0.);\n    return sqrt(length(vec2(dot(pa,pa),h*h*dot(ba,ba))));\n}\n\n\/\/ 1.25ms\nfloat sdLine3(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)\/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(u*u*u+v*v*v,1.\/3.);\n}\n\n\/\/ 1.5ms-1.6ms\nfloat sdLineN(vec3 p, vec3 a, vec3 b, float n){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)\/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(pow(u,n)+pow(v,n),1.\/n);\n}\n\/\/ n=2:    G1\n\/\/ 2<n<3:  G2 with divergent 3rd derivative, looks like G1\n\/\/ n=3:    G2, looks like G2\n\/\/ 3<n<4:  G3 with divergent 4th derivative\n\/\/ n\u22654:    G3+\n\n\n\nvec3 a, b;\nfloat map(vec3 p){\n    return sdLineN(p,a,b,3.-cos(iTime))-1.0;\n}\nvec3 grad(vec3 p){\n    const float e = .001;\n\tfloat a = map(p+vec3(e,e,e));\n\tfloat b = map(p+vec3(e,-e,-e));\n\tfloat c = map(p+vec3(-e,e,-e));\n\tfloat d = map(p+vec3(-e,-e,e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\n\n#define res iResolution.xy\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec3 p = vec3(0,0,10.);\n    float sc = 1.\/length(res);\n    vec3 d = normalize(vec3(10.*(coord-.5*res)*sc,0.)-p);\n    \n    if (iMouse.z>0.){\n        vec2 uv = 3.*(iMouse.xy-.5*res)*sc;\n        a = 1.2*normalize(vec3(uv,cos(2.*length(uv)))), b=-a;\n    }\n    else{\n        \/\/float c = cos(iTime), s = sin(iTime);\n        float c = 1., s = 0.;\n        a = vec3(1.2*c,.4*c,-s), b=-a;\n    }\n    \n    \/\/ the usual raymarching code\n    col = vec4(0,0,0,1);\n    float t=0., dt;\n    for (int i=0;i<64;i++){\n        dt = map(p+t*d);\n        t += dt;\n        if (dt<.001) break;\n        if (t>100.) return;\n    }\n    col.xyz=vec3(.9*max(dot(grad(p+t*d),vec3(.55)),0.)+.1);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ws2yzG","date":"1586887130","viewed":4,"name":"\ufeffCross-Platform Test","username":"harry7557558","description":"This shader is used to test shaders on different hardware and operating system.\n\n[url=\"https:\/\/www.example.com\"]example[\/url] [url]https:\/\/www.example.com[\/url]\n[b]bold[\/b] [i]italic[\/i]","likes":0,"published":2,"flags":42,"usePreview":0,"tags":["nan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"\/media\/a\/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"\/media\/ap\/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"\/media\/a\/\/media\/previz\/cubemap00.png","previewfilepath":"\/media\/ap\/\/media\/previz\/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n\n    \/\/ Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \/\/ Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"\/presets\/webcam.png","previewfilepath":"\/presets\/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    \/\/ A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"Sound","description":"","type":"sound"}]}]